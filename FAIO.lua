
-- Version: beta.0.98.10d
-- Author: foo0oo

local FAIO = {}
-- Menu Items
	-- general Menu
local OverallPath = {}
OverallPath[1] = { ".FAIO" }
OverallPath[2] = { ".FAIO", "Target selector" }
OverallPath[3] = { ".FAIO", "Target selector", "Target exclusions" }
OverallPath[4] = { ".FAIO", "Ward awareness" }
OverallPath[5] = { ".FAIO", "Creep control" }
OverallPath[6] = { ".FAIO", "Orbwalker" }
OverallPath[7] = { ".FAIO", "Orbwalker", "Orbwalk to enemy options" }
OverallPath[8] = { ".FAIO", "Orbwalker", "Orbwalk to mouse options" }
OverallPath[9] = { ".FAIO", "dodgeIT" }
OverallPath[10] = { ".FAIO", "Last hitter" }
OverallPath[11] = { ".FAIO", "Last hitter", "Drawings" }
OverallPath[12] = { ".FAIO", "Last hitter", "Auto mode options" }
OverallPath[13] = { ".FAIO", "Last hitter", "Use orb attacks" }
OverallPath[14] = { ".FAIO", "Auto Kill Steal" }
OverallPath[15] = { ".FAIO", "Auto Kill Steal", "Invoker" }
OverallPath[16] = { ".FAIO", "Item Usage", "Offensive items" }
OverallPath[17] = { ".FAIO", "Item Usage", "Offensive items", "Combo usage" }
OverallPath[18] = { ".FAIO", "Item Usage", "Offensive items", "Combo usage", "Items" }
OverallPath[19] = { ".FAIO", "Item Usage", "Offensive items", "Auto Usage", "Armlet" }
OverallPath[20] = { ".FAIO", "Item Usage", "Offensive items", "Auto Usage", "Hurricane Pike" }
OverallPath[21] = { ".FAIO", "Item Usage", "Offensive items", "Auto Usage", "Blade Mail" }
OverallPath[22] = { ".FAIO", "Item Usage", "Offensive items", "OnUnitOrder Usage" }
OverallPath[23] = { ".FAIO", "Item Usage", "Linkens breaker" }
OverallPath[24] = { ".FAIO", "Item Usage", "Utility Items" }
OverallPath[25] = { ".FAIO", "Item Usage", "Defensive Items" }
OverallPath[26] = { ".FAIO", "Item Usage", "Defensive Items", "BKB" }
OverallPath[27] = { ".FAIO", "Hero Scripts", "Strength heroes", "Axe" }
OverallPath[28] = { ".FAIO", "Hero Scripts", "Strength heroes", "Centaur" }
OverallPath[29] = { ".FAIO", "Hero Scripts", "Strength heroes", "Magnataur" }
OverallPath[30] = { ".FAIO", "Hero Scripts", "Strength heroes", "Magnataur", "Auto reverse polarity" }
OverallPath[31] = { ".FAIO", "Hero Scripts", "Strength heroes", "Magnataur", "Skewer combo" }
OverallPath[32] = { ".FAIO", "Hero Scripts", "Strength heroes", "Clockwerk" }
OverallPath[33] = { ".FAIO", "Hero Scripts", "Strength heroes", "Huskar" }
OverallPath[34] = { ".FAIO", "Hero Scripts", "Strength heroes", }
OverallPath[35] = { ".FAIO", "Hero Scripts", "Strength heroes", "Timbersaw" }
OverallPath[36] = { ".FAIO", "Hero Scripts", "Strength heroes", "Ursa" }
OverallPath[37] = { ".FAIO", "Hero Scripts", "Strength heroes", "Legion Commander" }
OverallPath[38] = { ".FAIO", "Hero Scripts", "Strength heroes", "Slardar" }
OverallPath[39] = { ".FAIO", "Hero Scripts", "Strength heroes", "Nightstalker" }
OverallPath[40] = { ".FAIO", "Hero Scripts", "Strength heroes", "Chaos Knight" }
OverallPath[41] = { ".FAIO", "Hero Scripts", "Strength heroes", "Kunkka Ghostship Helper" }
OverallPath[42] = { ".FAIO", "Hero Scripts", "Strength heroes", "Undying" }
OverallPath[43] = { ".FAIO", "Hero Scripts", "Strength heroes", "Pudge" }
OverallPath[44] = { ".FAIO", "Hero Scripts", "Strength heroes", "Earthshaker" }
OverallPath[45] = { ".FAIO", "Hero Scripts", "Strength heroes", "Pudge", "Hook helper" }
OverallPath[46] = { ".FAIO", "Hero Scripts", "Strength heroes", "Pudge", "Misc" }
OverallPath[47] = { ".FAIO", "Hero Scripts", "Agility heroes", "Ember Spirit" }
OverallPath[48] = { ".FAIO", "Hero Scripts", "Agility heroes", "Templar Assassin" }
OverallPath[49] = { ".FAIO", "Hero Scripts", "Agility heroes", "Clinkz" }
OverallPath[50] = { ".FAIO", "Hero Scripts", "Agility heroes", "Arc Warden" }
OverallPath[51] = { ".FAIO", "Hero Scripts", "Agility heroes", "Arc Warden", "Drawings" }
OverallPath[52] = { ".FAIO", "Hero Scripts", "Agility heroes", "Arc Warden", "Main hero blink usage" }
OverallPath[53] = { ".FAIO", "Hero Scripts", "Agility heroes", "Morphling" }
OverallPath[54] = { ".FAIO", "Hero Scripts", "Agility heroes", "Morphling", "Balance Board" }
OverallPath[55] = { ".FAIO", "Hero Scripts", "Agility heroes", "Anti-Mage" }
OverallPath[56] = { ".FAIO", "Hero Scripts", "Agility heroes", "Phantom Assassin" }
OverallPath[57] = { ".FAIO", "Hero Scripts", "Agility heroes", "Phantom Assassin", "Auto dagger" }
OverallPath[58] = { ".FAIO", "Hero Scripts", "Agility heroes", "Nyx Assassin" }
OverallPath[59] = { ".FAIO", "Hero Scripts", "Agility heroes", "Shadow Fiend" }
OverallPath[60] = { ".FAIO", "Hero Scripts", "Agility heroes", "Viper" }
OverallPath[61] = { ".FAIO", "Hero Scripts", "Agility heroes", "Vengeful Spirit" }
OverallPath[62] = { ".FAIO", "Hero Scripts", "Agility heroes", "Drow Ranger" }
OverallPath[63] = { ".FAIO", "Hero Scripts", "Agility heroes", "Troll warlord" }
OverallPath[64] = { ".FAIO", "Hero Scripts", "Intelligence heroes", "Skywrath Mage" }
OverallPath[65] = { ".FAIO", "Hero Scripts", "Intelligence heroes", "Necrophos" }
OverallPath[66] = { ".FAIO", "Hero Scripts", "Intelligence heroes", "Necrophos", "auto pulse" }
OverallPath[67] = { ".FAIO", "Hero Scripts", "Intelligence heroes", "Necrophos", "auto pulse", "pulse farm" }
OverallPath[68] = { ".FAIO", "Hero Scripts", "Intelligence heroes", "Necrophos", "auto pulse", "pulse harass" }
OverallPath[69] = { ".FAIO", "Hero Scripts", "Intelligence heroes", "Necrophos", "panic mode" }
OverallPath[70] = { ".FAIO", "Hero Scripts", "Intelligence heroes", "Outworld Devourer" }
OverallPath[71] = { ".FAIO", "Hero Scripts", "Intelligence heroes", "Outworld Devourer", "Kill steal" }
OverallPath[72] = { ".FAIO", "Hero Scripts", "Intelligence heroes", "Outworld Devourer", "Auto save with prison" }
OverallPath[73] = { ".FAIO", "Hero Scripts", "Intelligence heroes", "Silencer" }
OverallPath[74] = { ".FAIO", "Hero Scripts", "Intelligence heroes", "Dazzle" }
OverallPath[75] = { ".FAIO", "Hero Scripts", "Intelligence heroes", "Dazzle", "Auto grave" }
OverallPath[76] = { ".FAIO", "Hero Scripts", "Intelligence heroes", "Dazzle", "Auto weave" }
OverallPath[77] = { ".FAIO", "Hero Scripts", "Intelligence heroes", "Dazzle", "Auto heal" }
OverallPath[78] = { ".FAIO", "Hero Scripts", "Intelligence heroes", "Windrunner" }
OverallPath[79] = { ".FAIO", "Hero Scripts", "Intelligence heroes", "Queen of Pain" }
OverallPath[80] = { ".FAIO", "Hero Scripts", "Intelligence heroes", "Visage" }
OverallPath[81] = { ".FAIO", "Hero Scripts", "Intelligence heroes", "Puck" }
OverallPath[82] = { ".FAIO", "Hero Scripts", "Intelligence heroes", "Natures Prophet" }
OverallPath[83] = { ".FAIO", "Hero Scripts", "Intelligence heroes", "Natures Prophet", "Drawings" }
OverallPath[84] = { ".FAIO", "Hero Scripts", "Intelligence heroes", "Invoker", "General" }
OverallPath[85] = { ".FAIO", "Hero Scripts", "Intelligence heroes", "Invoker", "Panel" }
OverallPath[86] = { ".FAIO", "Hero Scripts", "Intelligence heroes", "Invoker", "Panel", "Custom indicator" }
OverallPath[87] = { ".FAIO", "Hero Scripts", "Intelligence heroes", "Invoker", "Fast Skills" }
OverallPath[88] = { ".FAIO", "Hero Scripts", "Intelligence heroes", "Invoker", "Cancel Channelling abilities" }
OverallPath[89] = { ".FAIO", "Hero Scripts", "Intelligence heroes", "Invoker", "Instance helper" }
OverallPath[90] = { ".FAIO", "Hero Scripts", "Intelligence heroes", "Invoker", "Custom Combo", "Combo 1" }
OverallPath[91] = { ".FAIO", "Hero Scripts", "Intelligence heroes", "Invoker", "Custom Combo", "Combo 2" }
OverallPath[92] = { ".FAIO", "Hero Scripts", "Intelligence heroes", "Invoker", "Custom Combo", "Combo 3" }
OverallPath[93] = { ".FAIO", "Hero Scripts", "Intelligence heroes", "Invoker", "Dynamic Combo", }
OverallPath[94] = { ".FAIO", "Hero Scripts", "Intelligence heroes", "Invoker", "Invoker Spell Panel" }
OverallPath[95] = { ".FAIO", "Hero Scripts", "Intelligence heroes", "Zuus" }
OverallPath[96] = { ".FAIO", "Hero Scripts", "Intelligence heroes", "Dark Willow" }
OverallPath[97] = { ".FAIO", "Hero Scripts", "Intelligence heroes", "Ogre Magi" }
OverallPath[98] = { ".FAIO", "Hero Scripts", "Intelligence heroes", "Ancient Apparition" }
OverallPath[99] = { ".FAIO", "Hero Scripts", "Intelligence heroes", "Witch Doctor" }
OverallPath[100] = { ".FAIO", "Hero Scripts", "Intelligence heroes", "Shadow Shaman" }
OverallPath[101] = { ".FAIO", "Hero Scripts", "Intelligence heroes", "Death prophet" }
OverallPath[102] = { ".FAIO", "Hero Scripts", "Intelligence heroes", "Crystal maiden" }
OverallPath[103] = { ".FAIO", "Hero Scripts", "Intelligence heroes", "Lion" }
OverallPath[104] = { ".FAIO", "Hero Scripts", "Intelligence heroes", "Pugna" }
OverallPath[105] = { ".FAIO", "Hero Scripts", "Intelligence heroes", "Tinker" }
OverallPath[106] = { ".FAIO", "Hero Scripts", "Intelligence heroes", "Tinker", "Push mode" }
OverallPath[107] = { ".FAIO", "Hero Scripts", "Intelligence heroes", "Tinker", "Rocket spam" }
OverallPath[108] = { ".FAIO", "Hero Scripts", "Intelligence heroes", "Tinker", "Tinker panel" }
OverallPath[109] = { ".FAIO", "Hero Scripts", "Intelligence heroes", "Tinker", "Misc options" }
OverallPath[110] = { ".FAIO", "Hero Scripts", "Intelligence heroes", "Disruptor" }
OverallPath[111] = { ".FAIO", "Hero Scripts", "Intelligence heroes", "Disruptor", "Glimpse Combo" }
OverallPath[112] = { ".FAIO", "Hero Scripts", "Intelligence heroes", "Disruptor", "Ult Combo" }
OverallPath[113] = { ".FAIO", "Hero Scripts", "Intelligence heroes", "Disruptor", "Drawings" }
OverallPath[114] = { ".FAIO", "dodgeIT", "Dodge items order" }
OverallPath[115] = { ".FAIO", "Item Usage", "Defensive Items", "BKB", "dangerous disables" }
OverallPath[116] = { ".FAIO", "dodgeIT", "Dodge items order" }
OverallPath[117] = { ".FAIO", "dodgeIT", "Dangerous enemy skills", "Table 1" }
OverallPath[118] = { ".FAIO", "dodgeIT", "Dangerous enemy skills", "Table 2" }
OverallPath[119] = { ".FAIO", "dodgeIT", "Dangerous enemy skills", "Table 3" }
OverallPath[120] = { ".FAIO", "dodgeIT", "Select myHero skills" }
OverallPath[121] = { ".FAIO", "Current Hero" }
OverallPath[122] = { ".FAIO", "Current Hero", "Axe" }

FAIO.optionEnable = Menu.AddOptionBool(OverallPath[1], "Overall enabled {{overall}}", false)
-- Current Hero --
--FAIO.CurentHero = Menu.AddOptionBool(OverallPath[121],"CurentHero: UNKNOWN",false)
-- /\ Current Hero /\ --
FAIO.optionComboKey = Menu.AddKeyOption(OverallPath[1], "overall combo key", Enum.ButtonCode.KEY_SPACE)
FAIO.optionTargetStyle = Menu.AddOptionCombo(OverallPath[2], "0. Targeting style {{overall targeting}}", {'  locked target', '  free target'}, 1)
FAIO.optionTargetRange = Menu.AddOptionSlider(OverallPath[2], "1. Target acquisition range {{overall targeting}}",  200, 1000, 50)
FAIO.optionMoveToCursor = Menu.AddOptionBool(OverallPath[2], "2. Move to Cursor Pos {{overall targeting}}", false)
FAIO.optionLockTargetIndicator = Menu.AddOptionBool(OverallPath[2], "3.1 Draw target indicator {{overall targeting}}", false)
FAIO.optionLockTargetParticle = Menu.AddOptionCombo(OverallPath[2], "3.2 Indicator style {{overall targeting}}", {'  blinding light', '  blood bath', '  tower aggro'}, 1)
FAIO.optionTargetCheckAM = Menu.AddOptionBool(OverallPath[3], "Exclude AM with agha {{targetselect}}", false)
FAIO.optionTargetCheckLotus = Menu.AddOptionBool(OverallPath[3], "Exclude active lotus orb {{targetselect}}", false)
FAIO.optionTargetCheckBlademail = Menu.AddOptionBool(OverallPath[3], "Exclude blademail {{targetselect}}", false)
FAIO.optionTargetCheckNyx = Menu.AddOptionBool(OverallPath[3], "Exclude spiked carapace {{targetselect}}", false)
FAIO.optionTargetCheckUrsa = Menu.AddOptionBool(OverallPath[3], "Exclude enraged ursa {{targetselect}}", false)
FAIO.optionTargetCheckAbbadon = Menu.AddOptionBool(OverallPath[3], "Exclude abaddon ult {{targetselect}}", false)
FAIO.optionTargetCheckDazzle = Menu.AddOptionBool(OverallPath[3], "Exclude shallow grave {{targetselect}}", false)
FAIO.optionWardAwareness = Menu.AddOptionBool(OverallPath[4], "1. Draw indicator for enemy wards {{overall}}", false)
FAIO.optionWardAwarenessRemove = Menu.AddOptionBool(OverallPath[4], "2. Auto remove indicator {{overall}}", false)
FAIO.optionWardAwarenessClickRemove = Menu.AddOptionBool(OverallPath[4], "3. Click remove indicator {{overall}}", false)
--FAIO.optionCreepControl = Menu.AddOptionBool(OverallPath[5], "1. Enable creep control {{creep control}}", false)
--FAIO.optionCreepControlMode = Menu.AddOptionCombo(OverallPath[5], "2. Creep control style {{creep control}}", {'  legit mode', '  fast mode'}, 1)
--FAIO.optionCreepControlDelay = Menu.AddOptionSlider(OverallPath[5], "3. Legit mode delay {{creep control}}", 25, 250, 25)


FAIO.optionOrbwalkEnable = Menu.AddOptionBool(OverallPath[6], "0. Enabled {{orbwalker}}", false)
FAIO.optionOrbwalkOffset = Menu.AddOptionSlider(OverallPath[6], "1. Orbwalker offset",  0, 50, 5)
FAIO.optionOrbwalkStyle = Menu.AddOptionCombo(OverallPath[6], "2. Orbwalker style {{orbwalker}}", {'  orbwalk to enemy', '  orbwalk to mouse'}, 1)
FAIO.optionOrbwalkDistance = Menu.AddOptionSlider(OverallPath[7], "1. Minimum distance {{orbwalker enemy}}", 30, 80, 10)
FAIO.optionOrbwalkKiting = Menu.AddOptionBool(OverallPath[7], "2. kiting {{orbwalker}}", false)
FAIO.optionOrbwalkDistanceMouse = Menu.AddOptionSlider(OverallPath[8], "2. Min. distance for ranged heroes {{orbwalker mouse}}", 20, 80, 10)
FAIO.optionOrbwalkMouseStyle = Menu.AddOptionCombo(OverallPath[8], "1. Mouse orbwalk {{orbwalker mouse}}", {'  only with ranged heroes', '  with any hero'}, 1)
FAIO.optionOrbwalkMouseHold = Menu.AddOptionSlider(OverallPath[8], "3. Hold distance {{orbwalker mouse}}", 50, 250, 25)
FAIO.optionDodgeItEnable = Menu.AddOptionBool(OverallPath[9], "0. Enable {{dodgeit}}", false)
FAIO.optionLastHitEnable = Menu.AddOptionBool(OverallPath[10], "0. Enable {{lasthit}}", false)
FAIO.optionLastHitKey = Menu.AddKeyOption(OverallPath[10], "1. Activation key {{lasthit}}", Enum.ButtonCode.KEY_NONE)
FAIO.optionLastHitStyle = Menu.AddOptionCombo(OverallPath[10], "2. Targeting style {{lasthit}}", {'  last hit + deny', '  only last hit', '  only deny'}, 1)
FAIO.optionLastHitOffset = Menu.AddOptionCombo(OverallPath[10], "3.1 Offset {{lasthit}}", {'  0.00s', '  0.05s', '  0.10s', '  0.15s', '  0.20s', '  0.25s'}, 1)
FAIO.optionLastHitPredict = Menu.AddOptionBool(OverallPath[10], "3.2 Use avg damage for prediction {{lasthit}}", false)
FAIO.optionLastHitDrawCreepEnable = Menu.AddOptionBool(OverallPath[11], "1. Enable creep drawings {{lasthit}}", false)
FAIO.optionLastHitDrawRange = Menu.AddOptionBool(OverallPath[11], "0. Draw attack range {{lasthit}}", false)
FAIO.optionLastHitDrawStyle = Menu.AddOptionCombo(OverallPath[11], "1. creep info style {{lasthit}}",{'  enemy+ally creeps', '  enemy creeps only'}, 1)
FAIO.optionLastHitDrawCreepTimer = Menu.AddOptionBool(OverallPath[11], "2. Draw last hit indicator {{lasthit}}", false)
FAIO.optionLastHitAutoModeMove = Menu.AddOptionBool(OverallPath[12], "1. Move to cursor {{lasthit}}", false)
FAIO.optionLastHitAutoModeMoveRange = Menu.AddOptionSlider(OverallPath[12], "2. Min. move range {{lasthit}}",  10, 400, 10)
FAIO.optionLastHitAutoModeEnemy = Menu.AddOptionBool(OverallPath[12], "3. Harass enemy {{lasthit}}", false)
FAIO.optionLastHitAutoModeEnemySave = Menu.AddOptionBool(OverallPath[12], "4. Save harass {{lasthit}}", false)
FAIO.optionLastHitOrb = Menu.AddOptionBool(OverallPath[13], "1. Enable {{lasthit orbs}}", false)
FAIO.optionLastHitOrbMana = Menu.AddOptionSlider(OverallPath[13], "2. Mana treshold {{lasthit orbs}}",  5, 75, 5)


-- killsteal Menu
FAIO.optionKillStealEnable = Menu.AddOptionBool(OverallPath[14], "0. Killsteal with nuke skills {{killsteal}}", false)
--FAIO.optionKillStealEnableItems = Menu.AddOptionBool(OverallPath[14], "1. Killsteal with nuke items {{killsteal}}", false)
FAIO.optionKillStealInvoker = Menu.AddOptionBool(OverallPath[15], "1. Auto Sunstrike KillSteal", false)
FAIO.optionKillStealInvokerTurn = Menu.AddOptionBool(OverallPath[15], "5.2 Turn check adjustment", "amount of game ticks enemy must run in a straight line (30 ticks ~ 1 sec)", 10, 60, 5)
FAIO.optionKillStealAutoInvoke = Menu.AddOptionBool(OverallPath[15], "5.1 Auto Invoke Sunstrike", false)
FAIO.optionKillStealInvokerTPpartice = Menu.AddOptionBool(OverallPath[15], "3. Killsteal on TPing enemies", false)
FAIO.optionKillStealInvokerImmobil = Menu.AddOptionBool(OverallPath[15], "2. Killsteal on immobilized enemies", false)
FAIO.optionKillStealInvokerTreshold = Menu.AddOptionSlider(OverallPath[15], "5.3 HP Treshold adjust {{KS invo}}", 0, 25, 5)
FAIO.optionKillStealInvokerRunning = Menu.AddOptionBool(OverallPath[15], "4. Killsteal on moving targets", false)
FAIO.optionHeroInvokerCataKS = Menu.AddOptionBool(OverallPath[15], "6. Killsteal with cataclysm", false)
FAIO.optionHeroInvokerCataKSCount = Menu.AddOptionSlider(OverallPath[15], "6.1 Cataclysm target count", 1, 5, 1)



-- Items Menu
FAIO.optionItemEnable = Menu.AddOptionBool(OverallPath[16], "0. Enabled {{off items}}", false)
FAIO.optionItemStyle = Menu.AddOptionCombo(OverallPath[17], "Choose activation style", {'  max speed, no order','  ordered','  smart ordered'}, 1)
FAIO.optionItemStack = Menu.AddOptionBool(OverallPath[17], "Stack hex and silence", false)
FAIO.optionItemSoulring = Menu.AddOptionBool(OverallPath[18], "Soulring", false)
FAIO.optionItemVeil = Menu.AddOptionSlider(OverallPath[18], "Use Item Veil Of Discord",  0, 18, 1)
FAIO.optionItemHex = Menu.AddOptionSlider(OverallPath[18], "Use Item Scythe Of Vyse",  0, 18, 1)
FAIO.optionItemBlood = Menu.AddOptionSlider(OverallPath[18], "Use Item Bloodthorn ",  0, 18, 1)
FAIO.optionItemeBlade = Menu.AddOptionSlider(OverallPath[18], "Use Item Ethereal Blade",  0, 18, 1)
FAIO.optionItemOrchid = Menu.AddOptionSlider(OverallPath[18], "Use Item Orchid Malevolence",  0, 18, 1)
FAIO.optionItemAtos = Menu.AddOptionSlider(OverallPath[18], "Use Item Rod Of Atos",  0, 18, 1)
FAIO.optionItemAbyssal = Menu.AddOptionSlider(OverallPath[18], "Use Item Abyssal Blade",  0, 18, 1)
FAIO.optionItemHalberd = Menu.AddOptionSlider(OverallPath[18], "Use Item Heavens Halbert",  0, 18, 1)
FAIO.optionItemShivas = Menu.AddOptionSlider(OverallPath[18], "Use Item Shivas Guard",  0, 18, 1)
FAIO.optionItemDagon = Menu.AddOptionSlider(OverallPath[18], "Use Item Dagon",  -1, 18, 1)
FAIO.optionItemUrn = Menu.AddOptionSlider(OverallPath[18], "Use Item Urn of shadows",  0, 18, 1)
FAIO.optionItemManta = Menu.AddOptionSlider(OverallPath[18], "Use Item Manta Style",  0, 18, 1)
FAIO.optionItemMjollnir = Menu.AddOptionSlider(OverallPath[18], "Use Item Mjollnir",  0, 18, 1)
FAIO.optionItemMedallion = Menu.AddOptionSlider(OverallPath[18], "Use Item Medallion of Courage",  0, 18, 1)
FAIO.optionItemCrest = Menu.AddOptionSlider(OverallPath[18], "Use Item Solar Crest",  0, 18, 1)
FAIO.optionItemSpirit = Menu.AddOptionSlider(OverallPath[18], "Use Item Spirit Vessel",  0, 18, 1)
FAIO.optionItemNull = Menu.AddOptionSlider(OverallPath[18], "Use Item Nullifier",  0, 18, 1)
FAIO.optionItemDiffusal = Menu.AddOptionSlider(OverallPath[18], "Use Item Diffusal Blade",  0, 18, 1)
FAIO.optionItemArmlet = Menu.AddOptionBool(OverallPath[19], "0. Enable {{armlet}}", false)
FAIO.optionItemArmletHPTreshold = Menu.AddOptionSlider(OverallPath[19], "1. HP threshold {{armlet}}", 100, 500, 50)
FAIO.optionItemArmletCombo = Menu.AddOptionBool(OverallPath[19], "2. Combo usage {{armlet}}", false)
FAIO.optionItemArmletRightClick = Menu.AddOptionBool(OverallPath[19], "3. Right click activation {{armlet}}", false)
FAIO.optionItemArmletRightClickStyle = Menu.AddOptionCombo(OverallPath[19], "3.1 Right click style {{armlet}}", {'  single click', '  double click'}, 1)
FAIO.optionItemArmletIllusion = Menu.AddOptionBool(OverallPath[19], "4. Illusion activation {{armlet}}", false)
FAIO.optionItemArmletManuallyOverride = Menu.AddOptionBool(OverallPath[19], "5. Manual override {{armlet}}", false)
FAIO.optionItemHurricane = Menu.AddOptionBool(OverallPath[20], "0. Enable {{hurricane}}", false)
FAIO.optionItemHurricaneHP = Menu.AddOptionSlider(OverallPath[20], "1. HP treshold {{hurricane}}", 5 ,75, 5)
FAIO.optionItemBlademail = Menu.AddOptionBool(OverallPath[21], "0. Enable {{blade mail}}", false)
FAIO.optionItemSoulringManual = Menu.AddOptionBool(OverallPath[22], "Soulring {{onunitorder}}", false)
FAIO.optionItemVeilManual = Menu.AddOptionBool(OverallPath[22], "Veil of Discord {{onunitorder}}", false)

	-- Linkens Menu
FAIO.optionLinkensEnable = Menu.AddOptionBool(OverallPath[23], "0. Enabled {{linkens}}", false)
FAIO.optionLinkensManual = Menu.AddOptionBool(OverallPath[23], "1. Pop linkens when manually casting", false)
FAIO.optionLinkensForce = Menu.AddOptionSlider(OverallPath[23], "Use Force Staff",  0, 8, 1)
FAIO.optionLinkensEul = Menu.AddOptionSlider(OverallPath[23], "Use Eul",  0, 8, 1)
FAIO.optionLinkensHalberd = Menu.AddOptionSlider(OverallPath[23], "Use Halberd",  0, 8, 1)
FAIO.optionLinkensHex = Menu.AddOptionSlider(OverallPath[23], "Use Hex",  0, 8, 1)
FAIO.optionLinkensBlood = Menu.AddOptionSlider(OverallPath[23], "Use Bloodthorn",  0, 8, 1)
FAIO.optionLinkensOrchid = Menu.AddOptionSlider(OverallPath[23], "Use Orchid",  0, 8, 1)
FAIO.optionLinkensPike = Menu.AddOptionSlider(OverallPath[23], "Use Pike",  0, 8, 1)
FAIO.optionLinkensDiffusal = Menu.AddOptionSlider(OverallPath[23], "Use Diffusal",  0, 8, 1)

	-- Utility Items Menu
FAIO.optionUtilityEnable = Menu.AddOptionBool(OverallPath[24], "0. Enable auto usage {{util}}", false)
FAIO.optionUtilityMidas = Menu.AddOptionBool(OverallPath[24], "Auto Use Midas", false)
FAIO.optionUtilityStick = Menu.AddOptionBool(OverallPath[24], "Auto Use Stick/Wand/Cheese/Faerie", false)
FAIO.optionUtilityHealth = Menu.AddOptionSlider(OverallPath[24], "1. Treshold Hero Health", 5, 75, 5)
FAIO.optionUtilityMek = Menu.AddOptionBool(OverallPath[24], "Auto Use Mekansm", false)
FAIO.optionUtilityGreaves = Menu.AddOptionBool(OverallPath[24], "Auto Use Greaves", false)
FAIO.optionUtilityArcane = Menu.AddOptionBool(OverallPath[24], "Auto Use Arcane Boots", false)
FAIO.optionUtilityBottle = Menu.AddOptionBool(OverallPath[24], "Auto Use Bottle", false)

	-- Defensive Items Menu
FAIO.optionDefensiveItems = Menu.AddOptionBool(OverallPath[25], "0. Enable auto usage {{deff}}", false)
FAIO.optionDefensiveItemsGlimmer = Menu.AddOptionBool(OverallPath[25], "2. Glimmer Cape", false)
FAIO.optionDefensiveItemslotusOrb = Menu.AddOptionBool(OverallPath[25], "3. Lotus Orb", false)
FAIO.optionDefensiveItemsCrimson = Menu.AddOptionBool(OverallPath[25], "4. Crimson Guard", false)
FAIO.optionDefensiveItemsCrest = Menu.AddOptionBool(OverallPath[25], "5. Solar Crest", false)
FAIO.optionDefensiveItemsPipe = Menu.AddOptionBool(OverallPath[25], "6. Pipe", false)
FAIO.optionDefensiveItemsBKB = Menu.AddOptionBool(OverallPath[26], "0. Enabled {{bkb}}", false)
FAIO.optionDefensiveItemsBKBEnemies = Menu.AddOptionSlider(OverallPath[26], "1. Min. enemies around", 1, 5, 1)
FAIO.optionDefensiveItemsBKBRadius = Menu.AddOptionSlider(OverallPath[26], "2. Search radius", 500, 1000, 100)
FAIO.optionDefensiveItemsSatanic = Menu.AddOptionBool(OverallPath[25], "7. Satanic", false)
FAIO.optionDefensiveItemsThreshold = Menu.AddOptionSlider(OverallPath[25], "0.1 HP Threshold {{deff}}", 10, 50, 5)
FAIO.optionDefensiveItemsThresholdDisable = Menu.AddOptionSlider(OverallPath[25], "0.2 HP Threshold if disabled {{deff}}", 35, 100, 5)
FAIO.optionDefensiveItemsMedallion = Menu.AddOptionBool(OverallPath[25], "8. Medallion of Courage", false)
FAIO.optionDefensiveItemsGhost = Menu.AddOptionBool(OverallPath[25], "9. Ghost scepter", false)
FAIO.optionDefensiveItemsAlly = Menu.AddOptionBool(OverallPath[25], "0.3 Cast defensive items on allies {{deff}}", false)
FAIO.optionDefensiveItemsSaver = Menu.AddOptionBool(OverallPath[25], "0.4 Advanced lotus/glimmer ally saving {{deff}}", false)


	-- Hero Menu
		-- STR
FAIO.optionHeroAxe = Menu.AddOptionBool(OverallPath[27], "Axe Combo", false)
FAIO.optionHeroAxeCulling = Menu.AddOptionBool(OverallPath[27], "Auto culling blade", false)
FAIO.optionHeroAxeJump = Menu.AddOptionCombo(OverallPath[27], "Axe Jump Style", {' blink target', ' blink best position'}, 1)
FAIO.optionHeroAxeForceBlink = Menu.AddOptionBool(OverallPath[27], "Force blink", false)
FAIO.optionHeroAxeForceBlinkRange = Menu.AddOptionSlider(OverallPath[27], "Force Blink Check Range", 150, 750, 50)
FAIO.optionHeroCentaur = Menu.AddOptionBool(OverallPath[28], "0. Centaur combo", false)
FAIO.optionHeroCentaurJump = Menu.AddOptionCombo(OverallPath[28], "1. Centaur jump style", {' blink target', ' blink best position'}, 1)
FAIO.optionHeroCentaurForceBlink = Menu.AddOptionBool(OverallPath[28], "2. Force blink {{centaur}}", false)
FAIO.optionHeroCentaurForceBlinkRange = Menu.AddOptionSlider(OverallPath[28], "2.1 Force blink check range {{centaur}}", 150, 750, 50)
FAIO.optionHeroMagnus = Menu.AddOptionBool(OverallPath[29], "0. Magnus combo", false)
FAIO.optionHeroMagnusAutoUlt = Menu.AddOptionBool(OverallPath[30], "0. Enable {{magnus polarity}}", false)
FAIO.optionHeroMagnusAutoUltSkewer = Menu.AddOptionBool(OverallPath[30], "1. Use skewer to initiate {{magnus polarity}}", false)
FAIO.optionHeroMagnusAutoUltCount = Menu.AddOptionSlider(OverallPath[30], "2. Min. enemies to hit {{magnus polarity}}", 1, 5, 1)
FAIO.optionHeroMagnusAutoUltRefresher = Menu.AddOptionBool(OverallPath[30], "3. Use refresher {{magnus polarity}}", false)
FAIO.optionHeroMagnusAutoEmpower = Menu.AddOptionBool(OverallPath[29], "2. Auto empower", false)
FAIO.optionHeroMagnusSkewerCombo = Menu.AddOptionBool(OverallPath[31], "0. Enable {{magnus skewer combo}}", false)
FAIO.optionHeroMagnusSkewerComboKey = Menu.AddKeyOption(OverallPath[31], "1. Skewer combo key {{magnus skewer combo}}", Enum.ButtonCode.KEY_NONE) 
FAIO.optionHeroMagnusJump = Menu.AddOptionCombo(OverallPath[29], "0.1 Jump style {{magnus combo}}", {' blink target', ' blink best position'}, 1)
FAIO.optionHeroMagnusInitiateSkewer = Menu.AddOptionBool(OverallPath[29], "0.2 Initiate with skewer {{magnus combo}}", false)
FAIO.optionHeroMagnusSkewerInCombo = Menu.AddOptionBool(OverallPath[29], "0.3 Use skewer in full RP combo {{magnus combo}}", false)
FAIO.optionHeroMagnusReturn = Menu.AddOptionCombo(OverallPath[29], "0.4 Skewer direction {{magnus combo}}", {' origin', ' cursor'}, 1)
FAIO.optionHeroMagnusShockwaveInCombo = Menu.AddOptionBool(OverallPath[29], "0.5 Use shockwave in combo {{magnus combo}}", false)
FAIO.optionHeroMagnusComboRefresher = Menu.AddOptionBool(OverallPath[29], "0.6 Use refresher in RP combo {{magnus combo}}", false)
FAIO.optionHeroMagnuscomboKeyAltSkewer = Menu.AddKeyOption(OverallPath[29], "0.7 Alt key for skewer combo {{magnus combo}}", Enum.ButtonCode.KEY_NONE)
FAIO.optionHeroMagnuscomboKeyAltRP = Menu.AddKeyOption(OverallPath[29], "0.8 Alt key for full RP combo {{magnus combo}}", Enum.ButtonCode.KEY_NONE)
FAIO.optionHeroClock = Menu.AddOptionBool(OverallPath[32], "0. Clockwerk combo", false)
FAIO.optionHeroClockDrawIndicator = Menu.AddOptionBool(OverallPath[32], "1. Draw hookshot indicator", false)
FAIO.optionHeroHuskar = Menu.AddOptionBool(OverallPath[33], "0. Huskar Combo", false)
FAIO.optionHeroHuskarBlink = Menu.AddOptionBool(OverallPath[33], "1. Use blink in combo {{huskar}}", false)
FAIO.optionHeroHuskarBlinkRange = Menu.AddOptionSlider(OverallPath[33], "1.1 Blink distance to enemy {{huskar}}",  0, 500, 50)
FAIO.optionHeroHuskarBlinkTrigger = Menu.AddOptionSlider(OverallPath[33], "1.2 Blink trigger range {{huskar}}",  300, 900, 100)
FAIO.optionHeroHuskarHarass = Menu.AddOptionBool(OverallPath[33], "2. Use orb to harass {{huskar}}", false)
FAIO.optionHeroHuskarHarassKey = Menu.AddKeyOption(OverallPath[33], "2.1 Harass key {{huskar}}", Enum.ButtonCode.KEY_NONE) 
FAIO.optionHeroHuskarInnerVit = Menu.AddOptionCombo(OverallPath[33], "3. Inner vitality usage", {' Off', ' always in combo', ' below hp treshold'}, 1)
FAIO.optionHeroHuskarUlt = Menu.AddOptionBool(OverallPath[33], "4. Use life break in combo", false)
FAIO.optionHeroHuskarAutoVit = Menu.AddOptionBool(OverallPath[33], "5. Auto inner vitality", false)
FAIO.optionHeroHuskarAutoVitAlly = Menu.AddOptionBool(OverallPath[33], "5.1 Inner vitality on allies", false)
FAIO.optionHeroHuskarHPThreshold = Menu.AddOptionSlider(OverallPath[33], "5.2 Inner vitality hp treshold",  10, 70, 5)
FAIO.optionHeroTiny = Menu.AddOptionBool(OverallPath[34], "Tiny", false)
FAIO.optionHeroTimber = Menu.AddOptionBool(OverallPath[35], "0. Enable {{timber}}", false)
FAIO.optionHeroTimberPredict = Menu.AddOptionBool(OverallPath[35], "1. Use prediction for timberchain", false)
FAIO.optionHeroTimberWhirling = Menu.AddOptionCombo(OverallPath[35], "2. Auto use whirling death", {' Off', ' only in combo', ' always'}, 1)
FAIO.optionHeroTimberUlt = Menu.AddOptionBool(OverallPath[35], "3. Use chakram", false)
FAIO.optionHeroTimberUltTiming = Menu.AddOptionCombo(OverallPath[35], "3.1 Chakram callback timing", {' 0.0 sec', ' 0.5 sec', ' 1.0 sec', ' 1.5 sec', ' 2.0 sec', ' 2.5 sec', ' 3.0 sec', ' 3.5 sec', ' 4.0 sec', ' 4.5 sec', ' 5.0 sec'}, 1)
FAIO.optionHeroTimberBlink = Menu.AddOptionBool(OverallPath[35], "4. Use blink {{timber}}", false)
FAIO.optionHeroTimberPanicKey = Menu.AddKeyOption(OverallPath[35], "5. Panic Key {{timber}}", Enum.ButtonCode.KEY_NONE)
FAIO.optionHeroTimberPanicDir = Menu.AddOptionCombo(OverallPath[35], "6. panic direction {{timber}}", {' fountain', ' furthest away', ' cursor'}, 1)
FAIO.optionHeroTimberFastMoveKey = Menu.AddKeyOption(OverallPath[35], "7. Fast Move Key", Enum.ButtonCode.KEY_NONE)
FAIO.optionHeroUrsa = Menu.AddOptionBool(OverallPath[36], "0. Ursa Combo", false)
FAIO.optionHeroUrsaEnrageCombo = Menu.AddOptionBool(OverallPath[36], "1. Use ult in combo {{ursa}}", false)
FAIO.optionHeroUrsaEnrage = Menu.AddOptionBool(OverallPath[36], "2. Auto use enrage", false)
FAIO.optionHeroUrsaEnrageHP = Menu.AddOptionSlider(OverallPath[36], "2.1 Enrage hp treshold", 5, 75, 5)
FAIO.optionHeroUrsaEnrageEnemies = Menu.AddOptionSlider(OverallPath[36], "2.2 Min. enemies around",  1, 5, 1)
FAIO.optionHeroLegion = Menu.AddOptionBool(OverallPath[37], "0. Legion Commander combo", false)
FAIO.optionHeroLegionAutoSave = Menu.AddOptionBool(OverallPath[37], "3. Auto save allies {{legion}}", false)
FAIO.optionHeroLegionBlink = Menu.AddOptionBool(OverallPath[37], "1. Use blink in combo {{legion}}", false)
FAIO.optionHeroLegionBlinkRange = Menu.AddOptionSlider(OverallPath[37], "1.1 Min. blink range {{legion}}",  150, 500, 25)
FAIO.optionHeroLegionBKB = Menu.AddOptionBool(OverallPath[37], "2. Use bkb in combo {{legion}}", false)
FAIO.optionHeroSlardar = Menu.AddOptionBool(OverallPath[38], "Slardar Combo", false)
FAIO.optionHeroSlardarStyle = Menu.AddOptionCombo(OverallPath[38], "Slardar Jump Style", {' blink target', ' blink best position'}, 1)
FAIO.optionHeroSven = Menu.AddOptionBool(OverallPath[34], "Sven", false)
FAIO.optionHeroNS = Menu.AddOptionBool(OverallPath[39], "1. NS Combo", false)
FAIO.optionHeroNSBlink = Menu.AddOptionBool(OverallPath[39], "2. Use blink in combo {{NS}}", false)
FAIO.optionHeroCK = Menu.AddOptionBool(OverallPath[40], "1. CK Combo", false)
FAIO.optionHeroCKBlink = Menu.AddOptionBool(OverallPath[40], "2. Use blink in combo {{CK}}", false)
FAIO.optionHeroCKUlt = Menu.AddOptionBool(OverallPath[40], "3. Use ult in combo {{CK}}", false)
FAIO.optionHeroCKUltStyle = Menu.AddOptionCombo(OverallPath[40], "3.1 Ult activation style {{CK}}", {' always', ' on key down'}, 1)
FAIO.optionHeroCKUltKey = Menu.AddKeyOption(OverallPath[40], "3.2 Additional ult key {{CK}}", Enum.ButtonCode.KEY_NONE)
FAIO.optionHeroCKUltTrigger = Menu.AddOptionSlider(OverallPath[40], "3.3 Min. range to enemy to trigger ult {{CK}}", 200, 1500, 100)
FAIO.optionHeroKunkkaShip = Menu.AddOptionBool(OverallPath[41], "1. Ghostship combo", false)
FAIO.optionHeroKunkkaShipKey = Menu.AddKeyOption(OverallPath[41], "2. Kunkka ghost ship key {{kunkka}}", Enum.ButtonCode.KEY_NONE)
FAIO.optionHeroUndying = Menu.AddOptionBool(OverallPath[42], "1. Undying Combo", false)
FAIO.optionHeroUndyingBlink = Menu.AddOptionBool(OverallPath[42], "2. Use blink in combo {{Undying}}", false)
FAIO.optionHeroUndyingSoul = Menu.AddOptionBool(OverallPath[42], "3.0 Auto heal with soulrip", false)
FAIO.optionHeroUndyingSoulTreshold = Menu.AddOptionSlider(OverallPath[42], "3.1 Soulrip heal treshold", 10, 65, 5)
FAIO.optionHeroUndyingSoulCount = Menu.AddOptionSlider(OverallPath[42], "3.2 Min. soulrip units around", 1, 10, 1)
FAIO.optionHeroUndyingUlt = Menu.AddOptionBool(OverallPath[42], "4.1 Use ult in combo {{Undying}}", false)
FAIO.optionHeroUndyingUltCount = Menu.AddOptionSlider(OverallPath[42], "4.2 Min. enemy heroes around {{Undying}}", 1, 5, 1)
FAIO.optionHeroUndyingSoulKS = Menu.AddOptionBool(OverallPath[42], "5. Use soulrip for kill stealing {{Undying}}", false)
FAIO.optionHeroPudge = Menu.AddOptionBool(OverallPath[43], "1. Pudge Combo", false)
FAIO.optionHeroPudgeBlink = Menu.AddOptionBool(OverallPath[43], "2. Use blink for initiation {{pudge}}", false)
FAIO.optionHeroPudgeBlinkMinRange = Menu.AddOptionSlider(OverallPath[43], "2.1 Blink min. range {{pudge}}",  250, 1000, 50)
FAIO.optionHeroPudgeStaff = Menu.AddOptionBool(OverallPath[43], "3. Use force staff for initiation {{pudge}}", false)
FAIO.optionHeroPudgeHookCombo = Menu.AddOptionBool(OverallPath[43], "4. Use hook in combo {{pudge}}", false)
FAIO.optionHeroPudgeHookComboMaxRange = Menu.AddOptionSlider(OverallPath[43], "4.1 Max hook range in combo {{pudge}}",  250, 1000, 50)
FAIO.optionHeroPudgeHook = Menu.AddOptionBool(OverallPath[45], "1. Enable hook helper {{pudge hook}}", false)
FAIO.optionHeroPudgeHookKey = Menu.AddKeyOption(OverallPath[45], "1.1 Hook helper key {{pudge hook}}", Enum.ButtonCode.KEY_NONE)
FAIO.optionHeroPudgeHookAcquiRange = Menu.AddOptionSlider(OverallPath[45], "1.2 Target acquisition range {{pudge hook}}",  250, 1000, 50)
FAIO.optionHeroPudgeHookAllies = Menu.AddOptionBool(OverallPath[45], "2.1 Also target allies {{pudge hook}}", false)
FAIO.optionHeroPudgeHookStaff = Menu.AddOptionBool(OverallPath[45], "2.2 Use force staff to avoid collision {{pudge hook}}", false)
FAIO.optionHeroPudgeHookUlt = Menu.AddOptionBool(OverallPath[45], "3. Use dismember {{pudge hook}}", false)
FAIO.optionHeroPudgeHookRot = Menu.AddOptionBool(OverallPath[45], "4. Use rot {{pudge hook}}", false)
FAIO.optionHeroPudgeHookItems = Menu.AddOptionBool(OverallPath[45], "5. Use offensive items {{pudge hook}}", false)
FAIO.optionHeroPudgeHookJuke = Menu.AddOptionSlider(OverallPath[45], "6. Anti-juke-offset {{pudge hook}}",  0, 12, 2)
FAIO.optionHeroPudgeFarm = Menu.AddOptionBool(OverallPath[46], "1. Rot farm {{pudge misc}}", false)
FAIO.optionHeroPudgeFarmHP = Menu.AddOptionSlider(OverallPath[46], "1.1 Rot farm HP treshold {{pudge misc}}", 5, 75, 5)
FAIO.optionHeroPudgeSuicide = Menu.AddOptionBool(OverallPath[46], "2. Auto suicide {{pudge misc}}", false)
FAIO.optionHeroEarthshaker = Menu.AddOptionBool(OverallPath[44], "1. Earthshaker Combo {{earth}}", false)
FAIO.optionHeroEarthshakerBlink = Menu.AddOptionBool(OverallPath[44], "2. Use blink in combo {{earth}}", false)
FAIO.optionHeroEarthshakerBlinkStyle = Menu.AddOptionCombo(OverallPath[44], "2.1 Blink style {{earth}}", {' blink to cursor', ' blink to best position'}, 1)
FAIO.optionHeroEarthshakerUlt = Menu.AddOptionBool(OverallPath[44], "3. Use ult in combo {{earth}}", false)
FAIO.optionHeroEarthshakerUltTiming = Menu.AddOptionCombo(OverallPath[44], "3.1 Ult usage timing {{earth}}", {' instant', ' max stun time'}, 1)
FAIO.optionHeroEarthshakerUltStyle = Menu.AddOptionCombo(OverallPath[44], "3.2 Ult usage style {{earth}}", {' always', ' on key down'}, 1)
FAIO.optionHeroEarthshakerUltEchoes = Menu.AddOptionSlider(OverallPath[44], "3.3 Minimum echoes created {{earth}}", 2, 10, 1)
FAIO.optionHeroEarthshakerUltKey = Menu.AddKeyOption(OverallPath[44], "3.4 Additional ult key {{earth}}", Enum.ButtonCode.KEY_NONE)
FAIO.optionHeroEarthshakerRefresher = Menu.AddOptionBool(OverallPath[44], "4. Use refresher in combo {{earth}}", false)



		-- AGI
FAIO.optionHeroEmber = Menu.AddOptionBool(OverallPath[47], "0. Ember Combo", false)

FAIO.optionHeroEmberBlink = Menu.AddOptionBool(OverallPath[47], "1. Use blink in combo {{ember}}", false)
FAIO.optionHeroEmberUlt = Menu.AddOptionBool(OverallPath[47], "2. Use ult in combo {{ember}}", false)
FAIO.optionHeroEmberUltInit = Menu.AddOptionCombo(OverallPath[47], "2.1 Ult usage {{ember}}", {' always', ' on move restricted only'}, 1)
FAIO.optionHeroEmberUltInitRange = Menu.AddOptionSlider(OverallPath[47], "2.2 Max ult initiation range {{ember}}", 500, 1500, 50)
FAIO.optionHeroEmberUltStyle = Menu.AddOptionCombo(OverallPath[47], "2.3 Ult activation style {{ember}}", {' always', ' on additional key down'}, 1)
FAIO.optionHeroEmberUltKey = Menu.AddKeyOption(OverallPath[47], "2.4 Ult additional activation key {{ember}}", Enum.ButtonCode.KEY_NONE)
FAIO.optionHeroEmberUltRem = Menu.AddOptionCombo(OverallPath[47], "2.5 Remnant usage {{ember}}", {' use all charges', ' use one charge'}, 1)
FAIO.optionHeroEmberAutoChains = Menu.AddOptionBool(OverallPath[47], "3. Auto chain after (manually) casting fist {{ember}}", false)



FAIO.optionHeroTA = Menu.AddOptionBool(OverallPath[48], "0. TA Combo", false)
FAIO.optionHeroTABlink = Menu.AddOptionBool(OverallPath[48], "1. Use blink in Combo {{TA}}", false)
FAIO.optionHeroTAHarassKey = Menu.AddKeyOption(OverallPath[48], "4. psi blades harass key {{TA}}", Enum.ButtonCode.KEY_NONE)
FAIO.optionHeroTAHarass = Menu.AddOptionBool(OverallPath[48], "2. Harass with psi blades {{TA}}", false)
FAIO.optionHeroTAHarassRange = Menu.AddOptionSlider(OverallPath[48], "3. Harass search range {{TA}}", 50,500,50)
FAIO.optionHeroClinkz = Menu.AddOptionBool(OverallPath[49], "0. Clinkz Combo", false)
FAIO.optionHeroClinkzBlink = Menu.AddOptionBool(OverallPath[49], "1. Use blink in combo", false)
FAIO.optionHeroClinkzBlinkRange = Menu.AddOptionSlider(OverallPath[49], "1.1 Blink distance to enemy",  200, 600, 50)
FAIO.optionHeroClinkzUlt = Menu.AddOptionBool(OverallPath[49], "3. Auto Ultimate  {{clinkz}}", false)
FAIO.optionHeroClinkzHarass = Menu.AddOptionBool(OverallPath[49], "2. Harass with searing", false)
FAIO.optionHeroClinkzHarassKey = Menu.AddKeyOption(OverallPath[49], "2.1 Harass key {{clinkz}}", Enum.ButtonCode.KEY_NONE)
FAIO.optionHeroArcWarden = Menu.AddOptionBool(OverallPath[50], "1.0 Arc Warden Combo", false)
FAIO.optionHeroArcWardenMagnetic = Menu.AddOptionBool(OverallPath[50], "1.1 Use magnetic field", false)
FAIO.optionHeroArcWardenSpark = Menu.AddOptionBool(OverallPath[50], "1.2 Use spark", false)
FAIO.optionHeroArcWardenFlux = Menu.AddOptionBool(OverallPath[50], "1.3 Use flux", false)
FAIO.optionArcWardenComboUlt = Menu.AddOptionBool(OverallPath[50], "1.4 Cast ult in combo {{arc warden}}", false)
FAIO.optionArcWardenTempestParticle = Menu.AddOptionBool(OverallPath[50], "1.5 Draw particle on locked enemy", false)
FAIO.optionArcWardenTempestKey = Menu.AddKeyOption(OverallPath[50], "2.1 Clone combo key", Enum.ButtonCode.KEY_NONE)
FAIO.optionArcWardenPushKey = Menu.AddKeyOption(OverallPath[50], "2.2 Clone push key", Enum.ButtonCode.KEY_NONE)
FAIO.optionArcWardenPushTPRange = Menu.AddOptionSlider(OverallPath[50], "2.3 Min. TP range", 500, 3500, 250)
FAIO.optionHeroArcWardenPanelKey = Menu.AddKeyOption(OverallPath[51], "Toggle key {{arc panel}}", Enum.ButtonCode.KEY_NONE)
FAIO.optionHeroArcWardenPanelMove = Menu.AddOptionBool(OverallPath[51], "Panel moveable {{arc panel}}", false)
FAIO.optionArcWardenMainBlink = Menu.AddOptionBool(OverallPath[52], "1. Use blink on main {{arc warden blink}}", false)
FAIO.optionArcWardenBlinkTrigger = Menu.AddOptionSlider(OverallPath[52], "2. Blink trigger range {{arc warden blink}}", 100, 800, 50)
FAIO.optionArcWardenBlinkRange = Menu.AddOptionSlider(OverallPath[52], "3. Blink jump distance {{arc warden blink}}", 100, 600, 50)
FAIO.optionHeroMorphling = Menu.AddOptionBool(OverallPath[53], "0. Morphling Combo", false)
FAIO.optionHeroMorphlingKill = Menu.AddOptionBool(OverallPath[53], "1. Draw kill indicator {{morph}}", false)
FAIO.optionHeroMorphHPBalance = Menu.AddOptionBool(OverallPath[53], "2. Balance HP {{morph}}", false)
FAIO.optionHeroMorphHPBalanceDeviation = Menu.AddOptionSlider(OverallPath[53], "2.1 Balance deviation {{morph}}",  50, 250, 25)
FAIO.optionHeroMorphDrawBoard = Menu.AddOptionBool(OverallPath[54], "0. Draw balace board {{morph}}", false)
FAIO.optionHeroMorphBoardToggleKey = Menu.AddKeyOption(OverallPath[54], "1. Toggle Key for balance board", Enum.ButtonCode.KEY_NONE)
FAIO.optionHeroMorphDrawBoardXPos = Menu.AddOptionSlider(OverallPath[54], "2. X-Pos adjustment {{morph}}", -500, 500, 10)
FAIO.optionHeroMorphDrawBoardYPos = Menu.AddOptionSlider(OverallPath[54], "3. Y-Pos adjustment {{morph}}", -500, 500, 10)
FAIO.optionHeroMorphReplicate = Menu.AddOptionBool(OverallPath[53], "4. Replicate combo", false)
FAIO.optionHeroMorphReplicateBack = Menu.AddOptionBool(OverallPath[53], "4.1 Auto replicate back", false)
FAIO.optionHeroMorphReplicateBackHP = Menu.AddOptionSlider(OverallPath[53], "4.2 Replicate back HP treshold",  5, 50, 5)
FAIO.optionHeroAntiMage = Menu.AddOptionBool(OverallPath[55], "1. Anti-Mage Combo", false)
FAIO.optionHeroAntiMageBlink = Menu.AddOptionBool(OverallPath[55], "2. Use Anti-Mage blink in combo", false)
FAIO.optionHeroAntiMageVoid = Menu.AddOptionBool(OverallPath[55], "3. Auto use mana void if target killable", false)
FAIO.optionHeroPA = Menu.AddOptionBool(OverallPath[56], "1. PA Combo", false)
FAIO.optionHeroPADagger = Menu.AddOptionBool(OverallPath[57], "1. Auto use dagger", false)
FAIO.optionHeroPADaggerThreshold = Menu.AddOptionSlider(OverallPath[57], "4. Mana treshold {{PA}}", 20, 80, 10)
FAIO.optionHeroPADaggerToggleKey = Menu.AddKeyOption(OverallPath[57], "2. Toggle Key {{PA}}", Enum.ButtonCode.KEY_NONE)
FAIO.optionHeroPADaggerDraw = Menu.AddOptionBool(OverallPath[57], "3. draw toggle state {{PA}}", false)
FAIO.optionHeroNyx = Menu.AddOptionBool(OverallPath[58], "1. Nyx Combo", false)
FAIO.optionHeroNyxBlink = Menu.AddOptionBool(OverallPath[58], "2. Use blink in combo {{Nyx}}", false)
FAIO.optionHeroSF = Menu.AddOptionBool(OverallPath[59], "0. Enable {{SF}}", false)
FAIO.optionHeroSFEulCombo = Menu.AddKeyOption(OverallPath[59], "1. Eul-Requiem-Combo key {{SF}}", Enum.ButtonCode.KEY_NONE)
FAIO.optionHeroSFDrawReqDMG = Menu.AddOptionBool(OverallPath[59], "1.1 Draw ult damage {{SF}}", false)
FAIO.optionHeroSFBlink = Menu.AddOptionBool(OverallPath[59], "2. Use blink in combo {{SF}}", false)
FAIO.optionHeroSFBlinkRange = Menu.AddOptionSlider(OverallPath[59], "2.1 Blink range to enemy {{SF}}", 200, 600, 50)
FAIO.optionHeroSFComboRaze = Menu.AddOptionBool(OverallPath[59], "4. Use raze in combo {{SF}}", false)
FAIO.optionHeroSFDrawRazeCircle = Menu.AddOptionBool(OverallPath[59], "5. Draw raze AoEs {{SF}}", false)
FAIO.optionHeroViper = Menu.AddOptionBool(OverallPath[60], "1. Viper Combo", false)
FAIO.optionHeroViperBlink = Menu.AddOptionBool(OverallPath[60], "2. Use blink in combo {{viper}}", false)
FAIO.optionHeroViperBlinkRange = Menu.AddOptionSlider(OverallPath[60], "2.1 Blink range to enemy {{viper}}", 100, 550, 50)
FAIO.optionHeroViperHarass = Menu.AddOptionBool(OverallPath[60], "3. Orb harass {{viper}}", false)
FAIO.optionHeroViperHarassKey = Menu.AddKeyOption(OverallPath[60], "3.1 Orb harass key {{viper}}", Enum.ButtonCode.KEY_NONE)
FAIO.optionHeroViperFarm = Menu.AddOptionBool(OverallPath[60], "4. Nethertoxin farm helper {{viper}}", false)
FAIO.optionHeroViperFarmMana = Menu.AddOptionSlider(OverallPath[60], "4.1 Nethertoxin mana threshold {{viper}}", 10, 80, 10)
FAIO.optionHeroViperFarmCount = Menu.AddOptionSlider(OverallPath[60], "4.2 Nethertoxin creep count {{viper}}", 1, 5, 1)
FAIO.optionHeroViperForceUlt = Menu.AddOptionBool(OverallPath[60], "1.1 Force movement to ult range", false)
FAIO.optionHeroVS = Menu.AddOptionBool(OverallPath[61], "1. Vengeful Combo", false)
FAIO.optionHeroVSBlink = Menu.AddOptionBool(OverallPath[61], "2. Use blink in combo {{vengeful}}", false)
FAIO.optionHeroVSBlinkRange = Menu.AddOptionSlider(OverallPath[61], "2.1 Blink range to enemy {{vengeful}}", 100, 400, 50)
FAIO.optionHeroVSStun = Menu.AddOptionBool(OverallPath[61], "3. Force stun first", false)
FAIO.optionHeroDrow = Menu.AddOptionBool(OverallPath[62], "0. Enable {{Drow Ranger}}", false)
FAIO.optionHeroDrowBlink = Menu.AddOptionBool(OverallPath[62], "1. Use Blink in combo {{Drow Ranger}}", false)
FAIO.optionHeroDrowBlinkRange = Menu.AddOptionSlider(OverallPath[62], "1.1 Blink range to enemy {{Drow Ranger}}", 200, 600, 50)
FAIO.optionHeroDrowGust = Menu.AddOptionBool(OverallPath[62], "2. Use gust in combo {{Drow Ranger}}", false)
FAIO.optionHeroDrowGustMode = Menu.AddOptionCombo(OverallPath[62], "2.1 Gust mode {{Drow Ranger}}", {' only if needed', ' always'}, 1)
FAIO.optionHeroDrowHarass = Menu.AddOptionBool(OverallPath[62], "3. Use Frost Arrow to harass {{Drow Ranger}}", false)
FAIO.optionHeroDrowHarassKey = Menu.AddKeyOption(OverallPath[62], "3.1 harass key {{Drow Ranger}}", Enum.ButtonCode.KEY_NONE)
FAIO.optionHeroTroll = Menu.AddOptionBool(OverallPath[63], "0. Enable {{troll warlord}}", false)
FAIO.optionHeroTrollBlink = Menu.AddOptionBool(OverallPath[63], "1. Use blink in combo {{troll warlord}}", false)
FAIO.optionHeroTrollBlinkInit = Menu.AddOptionSlider(OverallPath[63], "1.1 Min. blink initiation range {{troll warlord}}", 200, 1000, 50)
FAIO.optionHeroTrollRageRange = Menu.AddOptionSlider(OverallPath[63], "2. Melee/Ranged switch range {{troll warlord}}", 150, 500, 50)
FAIO.optionHeroTrollRageForceMM = Menu.AddOptionBool(OverallPath[63], "2.1 Force movement to slowed enemies {{troll warlord}}", false)
FAIO.optionHeroTrollUlt = Menu.AddOptionBool(OverallPath[63], "3. Use ult in combo {{troll warlord}}", false)
FAIO.optionHeroTrollUltStyle = Menu.AddOptionCombo(OverallPath[63], "3.1 Ult activation style {{troll warlord}}", {' always', ' in melee range', ' always on key down', ' melee on key down'}, 1)
FAIO.optionHeroTrollUltKey = Menu.AddKeyOption(OverallPath[63], "3.2 Ult activation style {{troll warlord}}", Enum.ButtonCode.KEY_NONE)
FAIO.optionHeroTrollAutoSwitch = Menu.AddOptionBool(OverallPath[63], "4. Auto switch stance when right clicking {{troll warlord}}", false)


FAIO.optionHeroSky =  Menu.AddOptionBool(OverallPath[64], "0. Enable {{sky}}", false)
FAIO.optionHeroSkyBlink =  Menu.AddOptionBool(OverallPath[64], "0.1 Use blink in combo {{sky}}", false)
FAIO.optionHeroSkyBlinkRange = Menu.AddOptionSlider(OverallPath[64], "0.2 blink distance to enemy {{sky}}", 200, 750, 50)
FAIO.optionHeroSkyDrawDMG =  Menu.AddOptionBool(OverallPath[64], "1. draw dmg indicators {{sky}}", false)
FAIO.optionHeroSkyHarass =  Menu.AddOptionBool(OverallPath[64], "2. use bolt to harass {{sky}}", false)
FAIO.optionHeroSkyHarassKey = Menu.AddKeyOption(OverallPath[64], "2.1 harass key {{sky}}", Enum.ButtonCode.KEY_NONE)

FAIO.optionHeroSkyStyle = Menu.AddOptionCombo(OverallPath[64], "3. combo style {{sky}}", {' max damage', ' mana saving'}, 1)
FAIO.optionHeroNecro =  Menu.AddOptionBool(OverallPath[65], "0. Enable {{necro}}", false)

FAIO.optionHeroNecroComboScythe = Menu.AddOptionCombo(OverallPath[65], "0.1 use ult in combo {{necro}}", {' Off', ' always w/o HP check', ' only if killable'}, 1)
FAIO.optionHeroNecroBlink =  Menu.AddOptionBool(OverallPath[65], "0.2 use blink in combo {{necro}}", false)
FAIO.optionHeroNecroBlinkRange = Menu.AddOptionSlider(OverallPath[65], "0.3 blink distance to enemy {{necro}}", 200, 600, 50)
FAIO.optionHeroNecroDrawDMG =  Menu.AddOptionBool(OverallPath[65], "1. draw dmg indicators {{necro}}", false)
FAIO.optionHeroNecroScythe =  Menu.AddOptionBool(OverallPath[65], "2. auto scythe {{necro}}", false)
FAIO.optionHeroNecroPulse =  Menu.AddOptionBool(OverallPath[66], "0. enabled {{pulse}}", false)
FAIO.optionHeroNecroPulseCreeps =  Menu.AddOptionBool(OverallPath[67], "1. enabled {{pulse}}", false)
FAIO.optionHeroNecroPulseCreepsMana = Menu.AddOptionSlider(OverallPath[67], "1.1 mana treshold {{pulse}}",  10, 90, 5)
FAIO.optionHeroNecroPulseCreepsCount = Menu.AddOptionSlider(OverallPath[67], "1.2 creep count {{pulse}}", 1, 5, 1)
FAIO.optionHeroNecroShroudFarm =  Menu.AddOptionBool(OverallPath[67], "2. auto shroud regen {{pulse}}", false)
FAIO.optionHeroNecroShroudFarmCount = Menu.AddOptionSlider(OverallPath[67], "2.1 stack count {{pulse}}", 1, 15, 1)
FAIO.optionHeroNecroShroudFarmSave =  Menu.AddOptionBool(OverallPath[67], "2.2 save activation {{pulse}}", false)
FAIO.optionHeroNecroShroudFarmTreshold = Menu.AddOptionSlider(OverallPath[67], "2.3 treshold {{pulse}}",  5, 75, 5)
FAIO.optionHeroNecroPulseHeroes =  Menu.AddOptionBool(OverallPath[68], "1. enabled {{pulse harass}}", false)
FAIO.optionHeroNecroPulseHeroesMana = Menu.AddOptionSlider(OverallPath[68], "2. mana treshold {{pulse harass}}", 5, 85, 5)
FAIO.optionHeroNecroShroudPanic =  Menu.AddOptionBool(OverallPath[69], "0. enabled {{necro panic}}", false)
FAIO.optionHeroNecroShroudPanicHP = Menu.AddOptionSlider(OverallPath[69], "1. HP treshold {{necro panic}}", 5, 75, 5)
FAIO.optionHeroOD =  Menu.AddOptionBool(OverallPath[70], "0. Enable {{OD}}", false)
FAIO.optionHeroODBlink =  Menu.AddOptionBool(OverallPath[70], "1. Use blink in combo {{OD}}", false)
FAIO.optionHeroODBlinkRange = Menu.AddOptionSlider(OverallPath[70], "1.1 Blink range to enemy {{OD}}", 200, 600, 50)
FAIO.optionHeroODKillsteal =  Menu.AddOptionBool(OverallPath[71], "0. Enable {{OD kill}}", false)
FAIO.optionHeroODKillstealOrb =  Menu.AddOptionBool(OverallPath[71], "1. Use arcane orb to KS {{OD kill}}", false)
FAIO.optionHeroODKillstealPrison =  Menu.AddOptionBool(OverallPath[71], "2. Use astral prison to KS {{OD kill}}", false)
FAIO.optionHeroODKillstealEclipse =  Menu.AddOptionBool(OverallPath[71], "3. Use sanitys eclipse to KS {{OD kill}}", false)
FAIO.optionHeroODKillstealEclipseHittable = Menu.AddOptionSlider(OverallPath[71], "3.1 Min. enemies to hit {{OD kill}}", 1, 5, 1)
FAIO.optionHeroODKillstealEclipseKillable = Menu.AddOptionSlider(OverallPath[71], "3.2 Min. enemies to kill {{OD kill}}", 1, 5, 1)
FAIO.optionHeroODAutoPrisonDefend =  Menu.AddOptionBool(OverallPath[70], "3. Auto disable with prison {{OD}}", false)
FAIO.optionHeroODAutoPrisonSave =  Menu.AddOptionBool(OverallPath[72], "0. enable {{OD prison save}}", false)
FAIO.optionHeroODAutoPrisonSaveSelf =  Menu.AddOptionBool(OverallPath[72], "1. Self save {{OD prison save}}", false)
FAIO.optionHeroODAutoPrisonSaveAlly =  Menu.AddOptionBool(OverallPath[72], "2. Ally save {{OD prison save}}", false)
FAIO.optionHeroODAutoPrisonHP = Menu.AddOptionSlider(OverallPath[72], "3. HP treshold {{OD prison save}}", 5, 30, 5)
FAIO.optionHeroSilencer =  Menu.AddOptionBool(OverallPath[73], "0. Enable {{Silencer}}", false)
FAIO.optionHeroSilencerBlink =  Menu.AddOptionBool(OverallPath[73], "1. Use blink in combo {{Silencer}}", false)
FAIO.optionHeroSilencerBlinkRange = Menu.AddOptionSlider(OverallPath[73], "1.1 Blink range to enemy {{Silencer}}",  200, 600, 50)
FAIO.optionHeroSilencerHarass =  Menu.AddOptionBool(OverallPath[73], "3. use glaives to harass {{Silencer}}", false)
FAIO.optionHeroSilencerHarassKey = Menu.AddKeyOption(OverallPath[73], "3.1 harass key {{Silencer}}", Enum.ButtonCode.KEY_NONE)
FAIO.optionHeroSilencerGlobal =  Menu.AddOptionBool(OverallPath[73], "4. auto interrupt with global {{Silencer}}", false)
FAIO.optionHeroDazzle =  Menu.AddOptionBool(OverallPath[74], "0. Enable {{dazzle}}", false)
FAIO.optionHeroDazzleAutoGrave =  Menu.AddOptionBool(OverallPath[75], "0. Auto use grave {{dazzle}}", false)
FAIO.optionHeroDazzleHP = Menu.AddOptionSlider(OverallPath[75], "1. HP treshold {{dazzle}}", 5, 50, 5)
FAIO.optionHeroDazzleAutoWeave =  Menu.AddOptionBool(OverallPath[76], "0. Auto use weave {{dazzle}}", false)
FAIO.optionHeroDazzleAutoWeaveCount = Menu.AddOptionSlider(OverallPath[76], "1. Min. enemies to hit {{dazzle}}", 1, 5, 1)
FAIO.optionHeroDazzleAutoHeal =  Menu.AddOptionBool(OverallPath[77], "0. Auto use heal {{dazzle}}", false)
FAIO.optionHeroDazzleAutoHealHP = Menu.AddOptionSlider(OverallPath[77], "1. HP threshold {{dazzle}}", 5, 75, 5)
FAIO.optionHeroDazzleHealKS =  Menu.AddOptionBool(OverallPath[74], "4. Shadow wave kill steal {{dazzle}}", false)
FAIO.optionHeroWindrunner =  Menu.AddOptionBool(OverallPath[78], "0. Enable {{windrunner}}", false)
FAIO.optionHeroWindrunnerPredict =  Menu.AddOptionBool(OverallPath[78], "1. Use prediction for shackleshot", false)
FAIO.optionHeroWindrunnerUlt =  Menu.AddOptionBool(OverallPath[78], "3. Auto use ultimate {{windrunner}}", false)

FAIO.optionHeroWindrunnerWind = Menu.AddOptionSlider(OverallPath[78], "4. Auto use windrun", 0, 5, 1)
FAIO.optionHeroWindrunnerBlinkShackle =  Menu.AddOptionBool(OverallPath[78], "2. Use Blink dagger {{windrunner}}", false)
FAIO.optionWindrunnerDrawIndicator =  Menu.AddOptionBool(OverallPath[78], "5. Draw shackle indicator {{windrunner}}", false)
FAIO.optionHeroWindrunnerBranchShackle =  Menu.AddOptionBool(OverallPath[78], "6. Branch-blink-shackle {{windrunner}}", false)
FAIO.optionHeroQoP =  Menu.AddOptionBool(OverallPath[79], "Queen of Pain Combo", false)
FAIO.optionHeroQoPblink =  Menu.AddOptionBool(OverallPath[79], "Use blink in combo {{QoP}}", false)

FAIO.optionHeroQoPAutoUlt = Menu.AddOptionCombo(OverallPath[79], "Auto Cast Ult {{QoP}}", {' OFF', ' only with aghanim', ' ALWAYS'}, 1)
FAIO.optionHeroVisage =  Menu.AddOptionBool(OverallPath[80], "0. Visage Combo", false)
FAIO.optionHeroVisageDMGStacks = Menu.AddOptionSlider(OverallPath[80], "1. Familiar attacks before stun", 1, 10, 1)
FAIO.optionHeroVisageInstStunKey = Menu.AddKeyOption(OverallPath[80], "2. Instant stun key", Enum.ButtonCode.KEY_NONE)
FAIO.optionHeroVisageKS =  Menu.AddOptionBool(OverallPath[80], "3. Soul assumption kill steal", false)
FAIO.optionHeroVisageFamiliarSave =  Menu.AddOptionBool(OverallPath[80], "4. Auto save familiars", false)
FAIO.optionHeroVisageFamiliarCancel =  Menu.AddOptionBool(OverallPath[80], "5. Auto cancel channelling", false)
FAIO.optionHeroVisagePanicKey = Menu.AddKeyOption(OverallPath[80], "6. Panic key", Enum.ButtonCode.KEY_NONE)
FAIO.optionHeroPuck =  Menu.AddOptionBool(OverallPath[81], "1. Puck Combo", false)

FAIO.optionHeroPuckJump = Menu.AddOptionCombo(OverallPath[81], "1.1 Puck Jump Style", {' blink target', ' blink best position'}, 1)
FAIO.optionHeroPuckPanic =  Menu.AddOptionBool(OverallPath[81], "2. Puck Panic", false)
FAIO.optionHeroPuckPanicKey = Menu.AddKeyOption(OverallPath[81], "2.3 Puck Panic Key", Enum.ButtonCode.KEY_NONE)

FAIO.optionHeroPuckPanicDirection = Menu.AddOptionCombo(OverallPath[81], "2.1 Puck Panic Direction", {' fountain', ' cursor'}, 1)
FAIO.optionHeroPuckComboAltKey = Menu.AddKeyOption(OverallPath[81], "1.3 Puck Alt Key", Enum.ButtonCode.KEY_NONE)
FAIO.optionHeroPuckDefend =  Menu.AddOptionBool(OverallPath[81], "2.2 Auto defend {{puck}}", false)
FAIO.optionHeroPuckOrbInit =  Menu.AddOptionBool(OverallPath[81], "1.2 Orb Initiation {{puck}}", false)
FAIO.optionHeroProphet =  Menu.AddOptionBool(OverallPath[82], "Prophet Helper", false)
FAIO.optionHeroProphetToggleKey = Menu.AddKeyOption(OverallPath[82], "Toggle Key {{prophet}}", Enum.ButtonCode.KEY_NONE)
FAIO.optionProphetDrawToggle =  Menu.AddOptionBool(OverallPath[83], "1. Draw Toggle Notification {{prophet}}", false)
FAIO.optionProphetDrawKS =  Menu.AddOptionBool(OverallPath[83], "2. Draw KS Notification {{prophet}}", false)
FAIO.optionProphetDrawKSminimap =  Menu.AddOptionBool(OverallPath[83], "3. Draw KS Target on Minimap {{prophet}}", false)
FAIO.optionHeroInvoker =  Menu.AddOptionBool(OverallPath[84], "1. Invoker Combo", false)
FAIO.optionHeroInvokerBlink =  Menu.AddOptionBool(OverallPath[84], "1.0 Use blink in combo", false)
FAIO.optionHeroInvokerSwitch =  Menu.AddOptionBool(OverallPath[84], "1.2 Auto switch dynamic mode", false)
FAIO.optionHeroInvokerForceDynamic =  Menu.AddOptionBool(OverallPath[84], "1.3 Force dynamic mode", false)
FAIO.optionHeroInvokerAltKey = Menu.AddKeyOption(OverallPath[84], "1.6 Invoker Alt Key", Enum.ButtonCode.KEY_NONE)
FAIO.optionHeroInvokerCustom1Key = Menu.AddKeyOption(OverallPath[84], "1.7 Select custom combo 1", Enum.ButtonCode.KEY_NONE)
FAIO.optionHeroInvokerCustom2Key = Menu.AddKeyOption(OverallPath[84], "1.8 Select custom combo 2", Enum.ButtonCode.KEY_NONE)
FAIO.optionHeroInvokerCustom3Key = Menu.AddKeyOption(OverallPath[84], "1.9 Select custom combo 3", Enum.ButtonCode.KEY_NONE)
FAIO.optionHeroInvokerToggleKey = Menu.AddKeyOption(OverallPath[85], "Panel toggle key {{invoker}}", Enum.ButtonCode.KEY_NONE)

FAIO.optionHeroInvokerSkillshotStyle = Menu.AddOptionCombo(OverallPath[84], "1.1 Skillshot Style {{invoker}}", {' prediction', ' cursor'}, 1)
FAIO.optionHeroInvokerTornadoItems =  Menu.AddOptionBool(OverallPath[84], "1.4 Activate items before tornado", false)
--FAIO.optionHeroInvokerDisableBuildIn =  Menu.AddOptionBool(OverallPath[84], "1.5 Disable hake build-in invo features", false)
--FAIO.optionHeroInvokerDisableBuildInGetOption = Menu.GetOption({ "Hero Specific", "Invoker" }, "Euls/Tornado Combo Helper")
FAIO.optionHeroInvokerAutoInvoke =  Menu.AddOptionBool(OverallPath[85], "4. Auto Invoke", false)
FAIO.optionHeroInvokerPanelCD = Menu.AddOptionSlider(OverallPath[85], "3. Show skill cooldowns {{invoker}}", 0, 2, 1)
FAIO.optionHeroInvokerPanelXPos = Menu.AddOptionSlider(OverallPath[85], "1. X-position {{invoker}}", -200, 500, 10)
FAIO.optionHeroInvokerPanelYPos = Menu.AddOptionSlider(OverallPath[85], "2. Y-position {{invoker}}", -500, 500, 10)
FAIO.invokerPanelSizeOption = Menu.AddOptionSlider(OverallPath[85], "0. Panel Size {{invoker}}", 20, 40, 2)
FAIO.optionHeroInvokerPanelShort =  Menu.AddOptionBool(OverallPath[86], "Enable {{invoker custom}}", false)
FAIO.optionHeroInvokerPanelShortXPos = Menu.AddOptionSlider(OverallPath[86], "X-position short {{invoker custom}}", -700, 700, 20)
FAIO.optionHeroInvokerPanelShortYPos = Menu.AddOptionSlider(OverallPath[86], "Y-position short {{invoker custom}}", -700, 700, 20)
FAIO.optionHeroInvokerIcewallEnable =  Menu.AddOptionBool(OverallPath[87], "Fast ice wall {{invoker ice}}", false)
FAIO.optionHeroInvokerIcewallKey = Menu.AddKeyOption(OverallPath[87], "Fast ice wall key {{invoker ice}}", Enum.ButtonCode.KEY_NONE)
FAIO.optionHeroInvokerAlacrityEnable =  Menu.AddOptionBool(OverallPath[87], "Fast alacrity {{invoker ala}}", false)
FAIO.optionHeroInvokerAlacrityKey = Menu.AddKeyOption(OverallPath[87], "Fast alacrity key {{invoker ala}}", Enum.ButtonCode.KEY_NONE)
FAIO.optionHeroInvokerTornadoEnable =  Menu.AddOptionBool(OverallPath[87], "Fast tornado {{invoker nado}}", false)
FAIO.optionHeroInvokerTornadoKey = Menu.AddKeyOption(OverallPath[87], "Fast tornado key {{invoker nado}}", Enum.ButtonCode.KEY_NONE)

FAIO.optionHeroInvokerTornadoStyle = Menu.AddOptionCombo(OverallPath[87], "Fast tornado style {{invoker nado}}", {' enemy prediction', ' mouse cursor'}, 1)

FAIO.optionInvokerGhostWalkKey = Menu.AddKeyOption(OverallPath[87], "Fast GhostWalk key", Enum.ButtonCode.KEY_NONE)
FAIO.optionHeroInvokerCancelEnable =  Menu.AddOptionBool(OverallPath[88], "0. Enable {{invoker chanel}}", false)
FAIO.optionHeroInvokerCancelTPFog =  Menu.AddOptionBool(OverallPath[88], "2. Auto cancel TP in Fog", false)
FAIO.optionHeroInvokerCancelBara =  Menu.AddOptionBool(OverallPath[88], "3. Auto cancel bara charge", false)
FAIO.optionHeroInvokerCancelChannelling =  Menu.AddOptionBool(OverallPath[88], "1. Auto cancel channelling spells", false)
FAIO.optionHeroInvokerInstanceHelper =  Menu.AddOptionBool(OverallPath[89], "auto instance switch", false)
local InvokerInstanceDelay = {' 0.00', ' 0.25', ' 0.50', ' 0.75', ' 1.00', ' 1.25', ' 1.50', ' 1.75', ' 2.00', ' 2.25', ' 2.50', ' 2.75', ' 3.00'}
local InvokerComboSkillMin = {' none', ' tornado', ' emp', ' chaos_meteor', ' deafening_blast', ' sun_strike', ' ice_wall', ' cold_snap', ' forge_spirit', ' alacrity', ' euls', ' atos'}
local InvokerComboSkillMax = {' none', ' tornado', ' emp', ' chaos_meteor', ' deafening_blast', ' sun_strike', ' ice_wall', ' cold_snap', ' forge_spirit', ' alacrity', ' euls', ' atos', ' refresher'}
FAIO.optionHeroInvokerInstanceDelay = Menu.AddOptionCombo(OverallPath[89], "delay between instance switch", InvokerInstanceDelay, 1)
FAIO.optionHeroInvokerCombo1Skill1 = Menu.AddOptionCombo(OverallPath[90], "C1 Skill 1", InvokerComboSkillMin, 1)
FAIO.optionHeroInvokerCombo1Skill2 = Menu.AddOptionCombo(OverallPath[90], "C1 Skill 2", InvokerComboSkillMin, 1)
FAIO.optionHeroInvokerCombo1Skill3 = Menu.AddOptionCombo(OverallPath[90], "C1 Skill 3", InvokerComboSkillMin, 1)
FAIO.optionHeroInvokerCombo1Skill4 = Menu.AddOptionCombo(OverallPath[90], "C1 Skill 4", InvokerComboSkillMax, 1)
FAIO.optionHeroInvokerCombo1Skill5 = Menu.AddOptionCombo(OverallPath[90], "C1 Skill 5", InvokerComboSkillMax, 1)
FAIO.optionHeroInvokerCombo1Skill6 = Menu.AddOptionCombo(OverallPath[90], "C1 Skill 6", InvokerComboSkillMax, 1)
FAIO.optionHeroInvokerCombo2Skill1 = Menu.AddOptionCombo(OverallPath[91], "C2 Skill 1", InvokerComboSkillMin, 1)
FAIO.optionHeroInvokerCombo2Skill2 = Menu.AddOptionCombo(OverallPath[91], "C2 Skill 2", InvokerComboSkillMin, 1)
FAIO.optionHeroInvokerCombo2Skill3 = Menu.AddOptionCombo(OverallPath[91], "C2 Skill 3", InvokerComboSkillMin, 1)
FAIO.optionHeroInvokerCombo2Skill4 = Menu.AddOptionCombo(OverallPath[91], "C2 Skill 4", InvokerComboSkillMax, 1)
FAIO.optionHeroInvokerCombo2Skill5 = Menu.AddOptionCombo(OverallPath[91], "C2 Skill 5", InvokerComboSkillMax, 1)
FAIO.optionHeroInvokerCombo2Skill6 = Menu.AddOptionCombo(OverallPath[91], "C2 Skill 6", InvokerComboSkillMax, 1)
FAIO.optionHeroInvokerCombo3Skill1 = Menu.AddOptionCombo(OverallPath[92], "C3 Skill 1", InvokerComboSkillMin, 1)
FAIO.optionHeroInvokerCombo3Skill2 = Menu.AddOptionCombo(OverallPath[92], "C3 Skill 2", InvokerComboSkillMin, 1)
FAIO.optionHeroInvokerCombo3Skill3 = Menu.AddOptionCombo(OverallPath[92], "C3 Skill 3", InvokerComboSkillMin, 1)
FAIO.optionHeroInvokerCombo3Skill4 = Menu.AddOptionCombo(OverallPath[92], "C3 Skill 4", InvokerComboSkillMax, 1)
FAIO.optionHeroInvokerCombo3Skill5 = Menu.AddOptionCombo(OverallPath[92], "C3 Skill 5", InvokerComboSkillMax, 1)
FAIO.optionHeroInvokerCombo3Skill6 = Menu.AddOptionCombo(OverallPath[92], "C3 Skill 6", InvokerComboSkillMax, 1)
FAIO.optionHeroInvokerDynCS = Menu.AddOptionSlider(OverallPath[93], "1. invoker_cold_snap {{invoker dyn}}", 0, 9, 1)
FAIO.optionHeroInvokerDynFS = Menu.AddOptionSlider(OverallPath[93], "2. invoker_forge_spirit {{invoker dyn}}", 0, 9, 1)
FAIO.optionHeroInvokerDynAL = Menu.AddOptionSlider(OverallPath[93], "3. invoker_alacrity {{invoker dyn}}", 0, 9, 1)
FAIO.optionHeroInvokerDynIW = Menu.AddOptionSlider(OverallPath[93], "4. invoker_ice_wall {{invoker dyn}}", 0, 9, 1)
FAIO.optionHeroInvokerDynTO = Menu.AddOptionSlider(OverallPath[93], "5. invoker_tornado {{invoker dyn}}", 0, 9, 1)
FAIO.optionHeroInvokerDynEMP = Menu.AddOptionSlider(OverallPath[93], "6. invoker_emp {{invoker dyn}}", 0, 9, 1)
FAIO.optionHeroInvokerDynSS = Menu.AddOptionSlider(OverallPath[93], "7. invoker_sun_strike {{invoker dyn}}", 0, 9, 1)
FAIO.optionHeroInvokerDynCM = Menu.AddOptionSlider(OverallPath[93], "8. invoker_chaos_meteor {{invoker dyn}}", 0, 9, 1)
FAIO.optionHeroInvokerDynDB = Menu.AddOptionSlider(OverallPath[93], "9. invoker_deafening_blast {{invoker dyn}}", 0, 9, 1)
FAIO.optionHeroInvokerDynOrder =  Menu.AddOptionBool(OverallPath[93], "0. USE CUSTOM PRIORITIES {{invoker dyn}}", false)	
FAIO.invokerDisplayOption =  Menu.AddOptionBool(OverallPath[94], "Enable {{invoker spell panel}}", false)
FAIO.invokerDisplaySizeOption = Menu.AddOptionSlider(OverallPath[94], "Cooldown Display Size", 21, 200, 5)
FAIO.invokerDisplayY = Menu.AddOptionSlider(OverallPath[94], "Y position", -500, 500, 10)
FAIO.invokerDisplayX = Menu.AddOptionSlider(OverallPath[94], "X position", -200, 200, 10)
FAIO.invokerDisplaySortAbilitiesOption =  Menu.AddOptionBool(OverallPath[94], "Sort Abilities by Name {{invoker spell panel}}", false)
FAIO.optionHeroZuus =  Menu.AddOptionBool(OverallPath[95], "1. Zuus Combo", false)
FAIO.optionHeroZuusFarmKey = Menu.AddKeyOption(OverallPath[95], "2. arc farm key", Enum.ButtonCode.KEY_NONE)
FAIO.optionHeroZuusHarassKey = Menu.AddKeyOption(OverallPath[95], "3. arc harass key", Enum.ButtonCode.KEY_NONE)
FAIO.optionHeroZuusHarassMana = Menu.AddOptionSlider(OverallPath[95], "3.1 harass arc mana threshold", 10, 90, 10)
FAIO.optionHeroZuusKillsteal =  Menu.AddOptionBool(OverallPath[95], "4. killsteal", false)
FAIO.optionHeroZuusUltCount = Menu.AddOptionSlider(OverallPath[95], "4.1 wrath kill count", 1, 5, 1)
FAIO.optionHeroZuusUltCountRefresher = Menu.AddOptionSlider(OverallPath[95], "4.2 refresher wrath kill count", 1, 5, 1)
FAIO.optionHeroZuusBlink =  Menu.AddOptionBool(OverallPath[95], "5. use blink in combo {{zuus}}", false)
FAIO.optionHeroZuusRightClick =  Menu.AddOptionBool(OverallPath[95], "6. use right click attacks in combo {{zuus}}", false)
FAIO.optionHeroWillow =  Menu.AddOptionBool(OverallPath[96], "1. Dark Willow Combo", false)
FAIO.optionHeroWillowBlink =  Menu.AddOptionBool(OverallPath[96], "2. Use blink in combo {{Willow}}", false)
FAIO.optionHeroWillowBlinkRange = Menu.AddOptionSlider(OverallPath[96], "2.1 Blink range to enemy {{Willow}}",  100, 450, 50)
FAIO.optionHeroOgre =  Menu.AddOptionBool(OverallPath[97], "1. Ogre Combo", false)
FAIO.optionHeroOgreBlink =  Menu.AddOptionBool(OverallPath[97], "2. Use blink in combo {{ogre}}", false)
FAIO.optionHeroAA =  Menu.AddOptionBool(OverallPath[98], "1. AA Combo", false)
FAIO.optionHeroAABlink =  Menu.AddOptionBool(OverallPath[98], "2. Use blink in combo {{AA}}", false)
FAIO.optionHeroAABlinkRange = Menu.AddOptionSlider(OverallPath[98], "3. Blink distance {{AA}}", 100, 600, 50)
FAIO.optionHeroWD =  Menu.AddOptionBool(OverallPath[99], "1. WD Combo", false)
FAIO.optionHeroWDBlink =  Menu.AddOptionBool(OverallPath[99], "2. Use blink in combo {{WD}}", false)
FAIO.optionHeroWDBlinkRange = Menu.AddOptionSlider(OverallPath[99], "3. Blink distance {{WD}}", 100, 500, 50)
FAIO.optionHeroSS =  Menu.AddOptionBool(OverallPath[100], "1. Shaman Combo", false)
FAIO.optionHeroSSBlink =  Menu.AddOptionBool(OverallPath[100], "2. Use blink in combo {{SS}}", false)
FAIO.optionHeroSSBlinkRange = Menu.AddOptionSlider(OverallPath[100], "3. Blink distance {{SS}}", 100, 350, 50)
FAIO.optionHeroSSForceHex =  Menu.AddOptionBool(OverallPath[100], "4. Force hex before ether shock", false)
FAIO.optionHeroDP =  Menu.AddOptionBool(OverallPath[101], "1. Death Prophet Combo", false)
FAIO.optionHeroDPBlink =  Menu.AddOptionBool(OverallPath[101], "2. Use blink in combo {{DP}}", false)
FAIO.optionHeroDPBlinkRange = Menu.AddOptionSlider(OverallPath[101], "3. Blink distance {{DP}}", 100, 550, 50)
FAIO.optionHeroCM =  Menu.AddOptionBool(OverallPath[102], "1. Crystal Maiden Combo", false)
FAIO.optionHeroCMBlink =  Menu.AddOptionBool(OverallPath[102], "2. Use blink in combo {{CM}}", false)
FAIO.optionHeroCMBlinkRange = Menu.AddOptionSlider(OverallPath[102], "3. Blink distance {{CM}}", 100, 550, 50)
FAIO.optionHeroCMUlt =  Menu.AddOptionBool(OverallPath[102], "4.0 Ult combo {{CM}}", false)
FAIO.optionHeroCMUltMin = Menu.AddOptionSlider(OverallPath[102], "4.1 Min. enemies to hit with ult {{CM}}", 1, 5, 1)
FAIO.optionHeroCMUltKey = Menu.AddKeyOption(OverallPath[102], "4.2 Ult combo key {{CM}}", Enum.ButtonCode.KEY_NONE)
FAIO.optionHeroLion =  Menu.AddOptionBool(OverallPath[103], "1. Lion Combo", false)
FAIO.optionHeroLionBlink =  Menu.AddOptionBool(OverallPath[103], "2.0 Use blink in combo {{Lion}}", false)
FAIO.optionHeroLionBlinkRange = Menu.AddOptionSlider(OverallPath[103], "2.1 Blink distance {{Lion}}", 100, 550, 50)
FAIO.optionHeroLionUlt =  Menu.AddOptionBool(OverallPath[103], "3. Use ult in combo {{Lion}}", false)

FAIO.optionHeroLionUltStyle = Menu.AddOptionCombo(OverallPath[103], "3.1 Ult activation style {{Lion}}", {' always', ' on key down'}, 1)
FAIO.optionHeroLionUltKey = Menu.AddKeyOption(OverallPath[103], "3.2 Additional ult key {{Lion}}", Enum.ButtonCode.KEY_NONE)
FAIO.optionHeroPugna =  Menu.AddOptionBool(OverallPath[104], "1. Pugna Combo", false)
FAIO.optionHeroPugnaBlink =  Menu.AddOptionBool(OverallPath[104], "2. Use blink in combo {{Pugna}}", false)
FAIO.optionHeroPugnaBlinkRange = Menu.AddOptionSlider(OverallPath[104], "3. Blink distance {{Pugna}}", 100, 600, 50)
FAIO.optionHeroPugnaWard =  Menu.AddOptionBool(OverallPath[104], "4.0 Use ward in combo", false)
FAIO.optionHeroPugnaWardCount = Menu.AddOptionSlider(OverallPath[104], "4.1 Min. heroes in ward range", 1, 5, 1)
FAIO.optionHeroPugnaInvis =  Menu.AddOptionBool(OverallPath[104], "5. Use invis while life draining {{Pugna}}", false)
FAIO.optionHeroTinker =  Menu.AddOptionBool(OverallPath[105], "1. Tinker Combo", false)
FAIO.optionHeroTinkerBlink =  Menu.AddOptionBool(OverallPath[105], "2. Use blink in combo {{tinker}}", false)
FAIO.optionHeroTinkerBlinkRange = Menu.AddOptionSlider(OverallPath[105], "2.1 Blink distance {{tinker}}", 100, 600, 50)

FAIO.optionHeroTinkerPushMode = Menu.AddOptionCombo(OverallPath[106], "1. Tinker push mode", {' toggle', ' pressed'}, 1)
FAIO.optionHeroTinkerPushKey = Menu.AddKeyOption(OverallPath[106], "2. Tinker push key {{tinker}}", Enum.ButtonCode.KEY_NONE)
FAIO.optionHeroTinkerPushReset =  Menu.AddOptionBool(OverallPath[106], "3. Reset with move command", false)
FAIO.optionHeroTinkerPushMarch = Menu.AddOptionSlider(OverallPath[106], "4. Max. march casts per wave", 1, 3, 1)
FAIO.optionHeroTinkerRocket =  Menu.AddOptionBool(OverallPath[107], "1. Enable rocket spam mode {{tinker}}", false)
FAIO.optionHeroTinkerRocketKey = Menu.AddKeyOption(OverallPath[107], "2. Tinker rocket key {{tinker}}", Enum.ButtonCode.KEY_NONE)
FAIO.optionHeroTinkerRocketMove =  Menu.AddOptionBool(OverallPath[107], "3. Move to cursor {{tinker rocket}}", false)
FAIO.optionHeroTinkerRocketBlink =  Menu.AddOptionBool(OverallPath[107], "4. Blink to cursor {{tinker rocket}}", false)
FAIO.optionHeroTinkerRocketBlinkMin = Menu.AddOptionSlider(OverallPath[107], "4.1 Blink minimum range {{tinker rocket}}", 200, 1000, 100)
FAIO.optionHeroTinkerPanelKey = Menu.AddKeyOption(OverallPath[108], "1. Panel toggle key {{tinker panel}}", Enum.ButtonCode.KEY_NONE)
FAIO.optionHeroTinkerPanelMove =  Menu.AddOptionBool(OverallPath[108], "2. moveable panel", false)
FAIO.optionHeroTinkerMiscFailUlt =  Menu.AddOptionBool(OverallPath[109], "1. Failswitch ult {{tinker misc}}", false)
FAIO.optionHeroTinkerMiscFailRockets =  Menu.AddOptionBool(OverallPath[109], "2. Failswitch rockets", false)
FAIO.optionHeroTinkerMiscGlimmer =  Menu.AddOptionBool(OverallPath[109], "3. Auto glimmer {{tinker misc}}", false)
FAIO.optionHeroTinkerMiscBlink =  Menu.AddOptionBool(OverallPath[109], "4. Auto blink after rearm {{tinker misc}}", false)

FAIO.optionHeroDisruptor =  Menu.AddOptionBool(OverallPath[110], "1. Disruptor Combo {{disruptor}}", false)
FAIO.optionHeroDisruptorBlink =  Menu.AddOptionBool(OverallPath[110], "2. Use blink in combo {{disruptor}}", false)
FAIO.optionHeroDisruptorBlinkRange = Menu.AddOptionSlider(OverallPath[110], "2.1 Blink distance {{disruptor}}", 100, 600, 50)
FAIO.optionHeroDisruptorGlimpseCombo =  Menu.AddOptionBool(OverallPath[111], "1. Enable glimpse combo {{disruptor}}", false)
FAIO.optionHeroDisruptorGlimpseComboKey = Menu.AddKeyOption(OverallPath[111], "2. Glimpse combo key {{disruptor}}", Enum.ButtonCode.KEY_NONE)
FAIO.optionHeroDisruptorGlimpseComboMove =  Menu.AddOptionBool(OverallPath[111], "3. Move to cursor if not in range {{disruptor glimpse}}", false)
FAIO.optionHeroDisruptorGlimpseComboMoveDis =  Menu.AddOptionBool(OverallPath[111], "3.1 Disable movement AFTER combo {{disruptor glimpse}}", false)
FAIO.optionHeroDisruptorUltCombo =  Menu.AddOptionBool(OverallPath[112], "1. Enable ult combo {{disruptor}}", false)
FAIO.optionHeroDisruptorUltComboKey = Menu.AddKeyOption(OverallPath[112], "2. Ult combo key {{disruptor}}", Enum.ButtonCode.KEY_NONE)
FAIO.optionHeroDisruptorUltComboMove =  Menu.AddOptionBool(OverallPath[112], "3. Move to cursor if not in range {{disruptor ult}}", false)
FAIO.optionHeroDisruptorUltComboMoveDis =  Menu.AddOptionBool(OverallPath[112], "3.1 Disable movement AFTER combo {{disruptor ult}}", false)
FAIO.optionHeroDisruptorComboIndicator =  Menu.AddOptionBool(OverallPath[113], "1. Draw combo indicator {{disruptor}}", false)
FAIO.optionHeroDisruptorGlimpseParticle =  Menu.AddOptionBool(OverallPath[113], "2. Draw glimpse position {{disruptor}}", false)


-- Local Wrapper --
local Wrap = require("scripts.modules.WrapUtility")
--/\ Local Wrapper /\ --

	-- global Variables
FAIO.IconPath = "resource/flash3/images/small_boost_icons/"
FAIO.font = Renderer.LoadFont("Tahoma", 22, Enum.FontWeight.EXTRABOLD)
FAIO.invokerDisplayspellIconPath = "resource/flash3/images/spellicons/"
FAIO.skywrathFont = Renderer.LoadFont("Tahoma", 12, Enum.FontWeight.EXTRABOLD)
FAIO.arcWardenfont = Renderer.LoadFont("Arial", 18, Enum.FontWeight.EXTRABOLD)
FAIO.heroIconPath = "resource/flash3/images/heroes/"
FAIO.itemIconPath = "resource/flash3/images/items/"

local CurentHero = nil
FAIO.LockedTarget = nil
FAIO.myUnitName = nil
FAIO.lastCastTime = 0
FAIO.lastCastTime2 = 0
FAIO.lastCastTime3 = 0
FAIO.lastTick = 0
FAIO.delay = 0
FAIO.itemDelay = 0
FAIO.lastItemCast = 0
FAIO.lastDefItemPop = 0
FAIO.lastItemTick = 0
FAIO.ItemCastStop = false
FAIO.isArmletManuallyToggled = false
FAIO.isArmletManuallyToggledTime = 0
FAIO.armletDelayer = 0
FAIO.ControlledUnitCastTime = 0
FAIO.ControlledUnitPauseTime = 0
FAIO.lastAttackTime = 0
FAIO.lastAttackTime2 = 0
FAIO.LastTarget = nil
FAIO.LastTickManta1 = 0
FAIO.LastTickManta2 = 0
FAIO.ArcWardenEntity = nil
FAIO.ArcWardenEntityAnimationStart = 0
FAIO.ArcWardenEntityAnimationEnd = 0
FAIO.arcWardenPanelX = 0
FAIO.arcWardenPanelY = 0
FAIO.ArcTempestLockedTarget = nil
FAIO.ArcTempestLockedTargetParticle = 0
FAIO.ArcTempestLockedTargetParticleHero = nil
FAIO.arcWardenMagneticCastTime = 0
FAIO.arcWardenPushMode = false
FAIO.arcWardenPusher = false
FAIO.arcWardenPushModeLine = false
FAIO.arcWardenStatus = 0
FAIO.ArcTempestLockedTargetPos = Vector()
FAIO.ArcTempestLockedTargetPosTimer = 0
FAIO.TempestInAttackBackswing = false
FAIO.TempestOrbwalkerDelay = 0
FAIO.ArcWardenEntityProjectileCreate = 0
FAIO.GenericUpValue = false
FAIO.lastPosition = Vector(0, 0, 0)
FAIO.PuckOrbCastTime = 0
FAIO.Toggler = false
FAIO.TogglerTime = 0
FAIO.PreInvoke = false
FAIO.InvokerComboSelector = 0
FAIO.InvokerLastCastedSkill = nil
FAIO.InvokerLastCastedSkillTime = 0
FAIO.InvokerLastChangedInstance = 0
FAIO.InvokerCaptureManualInstances = 0
FAIO.getInvokerGhostWalkKey = nil
FAIO.invokerChannellingKillstealTimer = 0
FAIO.invokerCaptureGhostwalkActivation = 0
FAIO.invokerDisplayNeedsInit = true
FAIO.invokerPanelNeedsInit = true
FAIO.InvokerCanComboStart = false
FAIO.getInvokerSettings = nil
FAIO.AttackProjectileCreate = 0
FAIO.AttackAnimationCreate = 0
FAIO.AttackParticleCreate = 0
FAIO.InAttackBackswing = false
FAIO.OrbwalkerDelay = 0
FAIO.TPParticleIndex = nil
FAIO.TPParticleTime = 0
FAIO.TPParticleUnit = nil
FAIO.TPParticlePosition = Vector()
FAIO.GlimpseParticleIndex = nil
FAIO.GlimpseParticleTime = 0
FAIO.GlimpseParticleUnit = nil
FAIO.GlimpseParticlePosition = Vector()
FAIO.GlimpseParticleIndexStart = nil
FAIO.GlimpseParticlePositionStart = Vector()
FAIO.particleNextTime = 0
FAIO.currentParticle = 0
FAIO.currentParticleTarget = nil
FAIO.skywrathDMGwithoutUlt = 0
FAIO.skywrathDMGwithUlt = 0
FAIO.skywrathComboSelect = false
FAIO.clockwerkHookUpValue = false
FAIO.enemyCanBeShackled = false
FAIO.dodgeTiming = 0
FAIO.dodgerProjectileAdjustmentTick = 0
FAIO.saverTiming = 0
FAIO.VisageInstStunLockTarget = nil
FAIO.VisagePanicTarget = nil
FAIO.morphlingComboSelect = false
FAIO.morphlingTotalDMG = 0
FAIO.morphlingTotalDMGwoWave = 0
FAIO.MorphBalanceTimer = 0
FAIO.MorphBalanceSelectedHP = 0
FAIO.MorphBalanceSelected = 0
FAIO.MorphBalanceToggler = true
FAIO.SFParticleUpdateTime = 0
FAIO.wardCaptureTiming = 0
FAIO.sentryImageHandle = nil
FAIO.obsImageHandle = nil
FAIO.wardDrawingRemove = 0
FAIO.necroDMGwithoutUlt = 0
FAIO.necroDMGwithUlt = 0
FAIO.necroComboSelect = false
FAIO.magnusLastPos = Vector()
FAIO.SFcurrentParticle1 = 0
FAIO.SFcurrentParticle2 = 0
FAIO.SFcurrentParticle3 = 0
FAIO.armletRightClickToggle = false
FAIO.armletRightClickToggleTimer = 0
FAIO.armletRightClickDoubleClick = 0
FAIO.isArmletActive = false
FAIO.armletCurrentHPGain = 0
FAIO.armletToggleTime = 0
FAIO.armletToggleTimePingAdjuster = 0
FAIO.armletProjectileAdjustmentTick = 0
FAIO.armletDamageInstanceTable = {}
FAIO.lastHitterDelay = 0
FAIO.lastHitterKillableImage = nil
FAIO.lastHitterOrbSkill = nil
FAIO.lastHitterOrbSkillEnemy = nil
FAIO.kunkkaXMarkPosition = Vector()
FAIO.kunkkaGhostshipTimer = 0
FAIO.kunkkaXMarkCastTime = 0
FAIO.TinkerStatus = 0
FAIO.TinkerPusher = false
FAIO.TinkerPorted = false
FAIO.TinkerJungle = false
FAIO.TinkerMarched = 0
FAIO.TinkerGlimmerCastTime = 0
FAIO.TinkerPanicRearmBlink = 0
FAIO.TinkerPanelX = 0
FAIO.TinkerPanelY = 0
FAIO.TinkerPushMode = false
FAIO.TinkerPushCreeps = 3
FAIO.TinkerPushEnemies = 0
FAIO.TinkerPushAllies = 0
FAIO.TinkerPushJungle = true
FAIO.TinkerPushSave = true
FAIO.TinkerPushDefend = true
FAIO.PudgeRotComboActivation = false
FAIO.PudgeRotComboDeactivation = 0
FAIO.PudgeHookStartTimer = 0
FAIO.PudgeHookDelayer = 0
FAIO.PudgeHookRotDelayer = 0
FAIO.PudgeHookTarget = nil
FAIO.PudgeHookTargetedPos = nil
FAIO.PudgeHookHit = false
FAIO.PudgecurrentParticle = 0
FAIO.PudgecurrentParticleTarget = nil
FAIO.PudgeRotFarmToggled = false
FAIO.PudgeRotFarmToggledTime = 0

	-- global Tables
FAIO.LinkensBreakerItemOrder = {}
FAIO.ItemCastOrder = {}
FAIO.rotationTable = {}
FAIO.PuckOrbHitSim = {}
FAIO.enemyHeroTable = {}
FAIO.InvokerKSparticleProcess = {{nil, nil, 0, nil, Vector()}}
FAIO.PreInvokeSkills = {}
FAIO.preemptiveBKB = {}
FAIO.invokerCachedIcons = {}
FAIO.dodgeItTable = {}
FAIO.dodgeItReadyTable = {}
FAIO.dodgeItSkillReady = {}
FAIO.wardDispenserCount = {}
FAIO.wardProcessingTable = {}
FAIO.lastHitCreepHPPrediction = {}
FAIO.lastHitCreepHPPredictionTime = {}
FAIO.creepAttackPointData = {}
FAIO.VisageFamiliarAttackCounter = {}
FAIO.heroIconHandler = {}
FAIO.itemIconHandler = {}
FAIO.ControllableEntityTable = {}
FAIO.ControllableAttackTiming = {}
FAIO.TinkerJungleFarmPos = {}
FAIO.JungleTrackTable = {}
FAIO.ShrinePositionTable = {}

FAIO.heroList = { 
	"npc_dota_hero_axe",
	"npc_dota_hero_rattletrap", 
	"npc_dota_hero_skywrath_mage",
	"npc_dota_hero_tiny",
	"npc_dota_hero_windrunner",
	"npc_dota_hero_ember_spirit",
	"npc_dota_hero_ursa",
	"npc_dota_hero_templar_assassin",
	"npc_dota_hero_legion_commander",
	"npc_dota_hero_shredder",
	"npc_dota_hero_slardar",
	"npc_dota_hero_clinkz",
	"npc_dota_hero_queenofpain",
	"npc_dota_hero_sven",
	"npc_dota_hero_visage",
	"npc_dota_hero_morphling",
	"npc_dota_hero_puck",
	"npc_dota_hero_invoker",
	"npc_dota_hero_arc_warden",
	"npc_dota_hero_furion",
	"npc_dota_hero_antimage",
	"npc_dota_hero_phantom_assassin",
	"npc_dota_hero_zuus",
	"npc_dota_hero_huskar",
	"npc_dota_hero_necrolyte",
	"npc_dota_hero_obsidian_destroyer",
	"npc_dota_hero_silencer",
	"npc_dota_hero_nevermore",
	"npc_dota_hero_dazzle",
	"npc_dota_hero_dark_willow",
	"npc_dota_hero_centaur",
	"npc_dota_hero_magnataur",
	"npc_dota_hero_ogre_magi",
	"npc_dota_hero_ancient_apparition",
	"npc_dota_hero_nyx_assassin",
	"npc_dota_hero_night_stalker",
	"npc_dota_hero_chaos_knight",
	"npc_dota_hero_witch_doctor",
	"npc_dota_hero_shadow_shaman",
	"npc_dota_hero_death_prophet",
	"npc_dota_hero_crystal_maiden",
	"npc_dota_hero_lion",
	"npc_dota_hero_pugna",
	"npc_dota_hero_undying",
	"npc_dota_hero_viper",
	"npc_dota_hero_pudge",
	"npc_dota_hero_vengefulspirit"
		}

FAIO.dodgeItItems = { 
	{"item_manta", 1, "no target", 0.1}, 
	{"item_blink", 0, "position", 0.1}, 
	{"item_cyclone", 0, "target", 0.1},
	{"item_lotus_orb", 1, "target", 0.1},
	{"item_black_king_bar", 2, "no target", 0.1},
	{"item_blade_mail", 0, "no target", 0.1},
	{"item_glimmer_cape", 0, "target", 0.1}
		}

FAIO.dodgeItSkills = {
	{"storm_spirit_ball_lightning", 0, "position", 0.4},
	{"puck_phase_shift", 0, "no target", 0.1},
	{"phantom_lancer_doppelwalk", 0, "position", 0.2},
	{"juggernaut_blade_fury", 2, "no target", 0.1},
	{"omniknight_repel", 2, "no target", 0.45},
	{"nyx_assassin_spiked_carapace", 0, "no target", 0.1},
	{"slark_dark_pact", 0, "no target", 0.1},
	{"morphling_waveform", 0, "position", 0.4},
	{"shadow_demon_disruption", 0, "target", 0.4},
	{"obsidian_destroyer_astral_imprisonment", 0, "target", 0.35},
	{"abaddon_aphotic_shield", 1, "target", 0.5},
	{"life_stealer_rage", 2, "no target", 0.1},
	{"sandking_sand_storm", 1, "no target", 0.1},
	{"faceless_void_time_walk", 0, "position", 0.4},
	{"ember_spirit_sleight_of_fist", 1, "position", 0.1},
	{"templar_assassin_refraction", 1, "no target", 0.1},
	{"templar_assassin_meld", 1, "no target", 0.1},
	{"riki_tricks_of_the_trade", 0, "no target", 0.35}
		}

FAIO.preemptiveBKBtable = {
	"alchemist_unstable_concoction_throw",
	"beastmaster_primal_roar",
	"centaur_hoof_stomp",
	"chaos_knight_chaos_bolt",
	"crystal_maiden_frostbite",
	"death_prophet_silence",
	"dragon_knight_dragon_tail",
	"drow_ranger_wave_of_silence",
	"earth_spirit_boulder_smash",
	"earthshaker_fissure",
	"ember_spirit_searing_chains",
	"invoker_tornado",
	"jakiro_ice_path",
	"lion_impale",
	"lion_voodoo",
	"naga_siren_ensnare",
	"nyx_assassin_impale",
	"puck_dream_coil",
	"rubick_telekinesis",
	"sandking_burrowstrike",
	"shadow_shaman_shackles",
	"shadow_shaman_voodoo",
	"skeleton_king_hellfire_blast",
	"slardar_slithereen_crush",
	"storm_spirit_electric_vortex",
	"sven_storm_bolt",
	"tidehunter_ravage",
	"tiny_avalanche",
	"vengefulspirit_magic_missile",
	"warlock_rain_of_chaos",
	"windrunner_shackleshot",
	"slark_pounce",
	"ogre_magi_fireblast",
	"meepo_poof" }

FAIO.dodgeEnemySkillsTable = {
	"antimage_mana_void",
	"alchemist_unstable_concoction_throw",
	"axe_berserkers_call",
	"bane_fiends_grip",
	"batrider_flaming_lasso",
	"bloodseeker_rupture",
	"centaur_hoof_stomp",
	"chaos_knight_chaos_bolt",
	"crystal_maiden_frostbite",
	"death_prophet_silence",
	"doom_bringer_doom",
	"drow_ranger_wave_of_silence",
	"earthshaker_fissure",
	"earthshaker_enchant_totem",
	"enigma_black_hole",
	"faceless_void_chronosphere",
	"juggernaut_omni_slash",
	"legion_commander_duel",
	"lich_chain_frost",
	"lina_laguna_blade",
	"lion_impale",
	"lion_finger_of_death",
	"luna_lucent_beam",
	"magnataur_reverse_polarity",
	"necrolyte_reapers_scythe",
	"night_stalker_crippling_fear",
	"nyx_assassin_impale",
	"ogre_magi_fireblast",
	"obsidian_destroyer_astral_imprisonment",
	"obsidian_destroyer_sanity_eclipse",
	"puck_waning_rift",
	"pudge_dismember",
	"queenofpain_sonic_wave",
	"rubick_telekinesis",
	"sandking_burrowstrike",
	"shadow_demon_disruption",
	"shadow_shaman_shackles",
	"silencer_global_silence",
	"skywrath_mage_ancient_seal",
	"slardar_slithereen_crush",
	"sniper_assassinate",
	"storm_spirit_electric_vortex",
	"sven_storm_bolt",
	"terrorblade_sunder",
	"tidehunter_ravage",
	"tinker_laser",
	"vengefulspirit_magic_missile",
	"warlock_rain_of_chaos",
	"windrunner_shackleshot",
	"skeleton_king_hellfire_blast",
	"zuus_lightning_bolt",
	"zuus_thundergods_wrath"
		}

FAIO.JunglePositionTable = {
	{ Vector(-1845, -4214, 0), "radiant", "bot", "hard" },
	{ Vector(4591, -4354, 0), "radiant", "bot", "hard" },
	{ Vector(-416, -3345, 0), "radiant", "bot", "medium" },
	{ Vector(381, -4680, 0), "radiant", "bot", "medium" },
	{ Vector(2889, -4558, 0), "radiant", "bot", "small" },
	{ Vector(-4862, -477, 0), "radiant", "top", "hard" },
	{ Vector(-3707, 878, 0), "radiant", "top", "medium" },
	{ Vector(1349, 3317, 0), "dire", "top", "hard" },
	{ Vector(-4283, 3474, 0), "dire", "top", "hard" },
	{ Vector(-227, 3396, 0), "dire", "top", "medium" },
	{ Vector(-2000, 4275, 0), "dire", "top", "medium" },
	{ Vector(-2677, 4593, 0), "dire", "top", "small" },
	{ Vector(4411, 847, 0), "dire", "bot", "hard" },
	{ Vector(2554, 81, 0), "dire", "bot", "medium" } 
		}

FAIO.invokerInvokeOrder = {
	invoker_sun_strike = { 2, 2, 2 },
	invoker_emp = { 1, 1, 1 },
	invoker_tornado = { 0, 1, 1 },
	invoker_alacrity = { 1, 1, 2 },
	invoker_ghost_walk = { 0, 0, 1 },
	invoker_deafening_blast = { 0, 1, 2 },
	invoker_chaos_meteor = { 1, 2, 2 },
	invoker_cold_snap = { 0, 0, 0 },
	invoker_ice_wall = { 0, 0, 2 },
	invoker_forge_spirit = { 0, 2, 2 } }

FAIO.invokerTornadoLiftDuration = { 0.8, 1.1, 1.4, 1.7, 2.0, 2.3, 2.6, 2.9 }

FAIO.orbAttackTable = {
	npc_dota_hero_clinkz = "clinkz_searing_arrows",
	npc_dota_hero_drow_ranger = "drow_ranger_frost_arrows",
	npc_dota_hero_enchantress = "enchantress_impetus",
	npc_dota_hero_huskar = "huskar_burning_spear",
	npc_dota_hero_obsidian_destroyer = "obsidian_destroyer_arcane_orb",
	npc_dota_hero_silencer = "silencer_glaives_of_wisdom",
	npc_dota_hero_viper = "viper_poison_attack"
			}

FAIO.attackPointTable = {
	npc_dota_hero_abaddon = { 0.56, 0.41, 0 },
	npc_dota_hero_alchemist = { 0.35, 0.65, 0 },
	npc_dota_hero_ancient_apparition = { 0.45, 0.3, 1250 },
	npc_dota_hero_antimage = { 0.3, 0.6, 0 },
	npc_dota_hero_arc_warden = { 0.3, 0.7, 800 },
	npc_dota_hero_axe = { 0.5, 0.5, 0 },
	npc_dota_hero_bane = { 0.3, 0.7, 900 },
	npc_dota_hero_batrider = { 0.3, 0.54, 900 },
	npc_dota_hero_beastmaster = { 0.3, 0.7, 0 },
	npc_dota_hero_bloodseeker = { 0.43, 0.74, 0 },
	npc_dota_hero_bounty_hunter = { 0.59, 0.59, 0 },
	npc_dota_hero_brewmaster = { 0.35, 0.65, 0 },
	npc_dota_hero_bristleback = { 0.3, 0.3, 0 },
	npc_dota_hero_broodmother = { 0.4, 0.5, 0 },
	npc_dota_hero_centaur = { 0.3, 0.3, 0 },
	npc_dota_hero_chaos_knight = { 0.5, 0.5, 0 },
	npc_dota_hero_chen = { 0.5, 0.5, 1100 },
	npc_dota_hero_clinkz = { 0.7, 0.3, 900 },
	npc_dota_hero_rattletrap = { 0.33, 0.64, 0 },
	npc_dota_hero_crystal_maiden = { 0.55, 0, 900 },
	npc_dota_hero_dark_seer = { 0.59, 0.58, 0 },
	npc_dota_hero_dazzle = { 0.3, 0.3, 1200 },
	npc_dota_hero_death_prophet = { 0.56, 0.51, 1000 },
	npc_dota_hero_disruptor = { 0.4, 0.5, 1200 },
	npc_dota_hero_doom_bringer = { 0.5, 0.7, 0 },
	npc_dota_hero_dragon_knight = { 0.5, 0.5, 900 },
	npc_dota_hero_drow_ranger = { 0.7, 0.3, 1250 },
	npc_dota_hero_earth_spirit = { 0.35, 0.65, 0 },
	npc_dota_hero_earthshaker = { 0.467, 0.863, 0 },
	npc_dota_hero_elder_titan = { 0.35, 0.97, 0 },
	npc_dota_hero_ember_spirit = { 0.4, 0.3, 0 },
	npc_dota_hero_enchantress = { 0.3, 0.7, 900 },
	npc_dota_hero_enigma = { 0.4, 0.77, 900 },
	npc_dota_hero_faceless_void = { 0.5, 0.56, 0 },
	npc_dota_hero_gyrocopter = { 0.2, 0.97, 3000 },
	npc_dota_hero_huskar = { 0.4, 0.5, 1400 },
	npc_dota_hero_invoker = { 0.4, 0.7, 900 },
	npc_dota_hero_wisp = { 0.15, 0.4, 1200 },
	npc_dota_hero_jakiro = { 0.4, 0.5, 1100 },
	npc_dota_hero_juggernaut = { 0.33, 0.84, 0 },
	npc_dota_hero_keeper_of_the_light = { 0.3, 0.85, 900 },
	npc_dota_hero_kunkka = { 0.4, 0.3, 0 },
	npc_dota_hero_legion_commander = { 0.46, 0.64, 0 },
	npc_dota_hero_leshrac = { 0.4, 0.77, 900 },
	npc_dota_hero_lich = { 0.46, 0.54, 900 },
	npc_dota_hero_life_stealer = { 0.39, 0.44, 0 },
	npc_dota_hero_lina = { 0.75, 0.78, 1000 },
	npc_dota_hero_lion = { 0.43, 0.74, 1000 },
	npc_dota_hero_lone_druid = { 0.33, 0.53, 900 },
	npc_dota_hero_luna = { 0.46, 0.54, 900 },
	npc_dota_hero_lycan = { 0.55, 0.55, 0 },
	npc_dota_hero_magnataur = { 0.5, 0.84, 0 },
	npc_dota_hero_medusa = { 0.5, 0.6, 1200 },
	npc_dota_hero_meepo = { 0.38, 0.6, 0 },
	npc_dota_hero_mirana = { 0.3, 0.7, 900 },
	npc_dota_hero_morphling = { 0.45, 0.2, 0 },
	npc_dota_hero_monkey_king = { 0.5, 0.5, 1300 },
	npc_dota_hero_naga_siren = { 0.5, 0.5, 0 },
	npc_dota_hero_furion = { 0.4, 0.77, 1125 },
	npc_dota_hero_necrolyte = { 0.53, 0.47, 900 },
	npc_dota_hero_night_stalker = { 0.55, 0.55, 0 },
	npc_dota_hero_nyx_assassin = { 0.46, 0.54, 0 },
	npc_dota_hero_ogre_magi = { 0.3, 0.3, 0 },
	npc_dota_hero_omniknight = { 0.433, 0.567, 0 },
	npc_dota_hero_oracle = { 0.3, 0.7, 900 },
	npc_dota_hero_obsidian_destroyer = { 0.46, 0.54, 900 },
	npc_dota_hero_phantom_assassin = { 0.3, 0.7, 0 },
	npc_dota_hero_phantom_lancer = { 0.5, 0.5, 0 },
	npc_dota_hero_phoenix = { 0.35, 0.633, 1100 },
	npc_dota_hero_puck = { 0.5, 0.8, 900 },
	npc_dota_hero_pudge = { 0.5, 1.17, 0 },
	npc_dota_hero_pugna = { 0.5, 0.5, 900 },
	npc_dota_hero_queenofpain = { 0.56, 0.41, 1500 },
	npc_dota_hero_razor = { 0.3, 0.7, 2000 },
	npc_dota_hero_riki = { 0.3, 0.3, 0 },
	npc_dota_hero_rubick = { 0.4, 0.77, 1125 },
	npc_dota_hero_sand_king = { 0.53, 0.47, 0 },
	npc_dota_hero_shadow_demon = { 0.35, 0.5, 900 },
	npc_dota_hero_nevermore = { 0.5, 0.54, 1200 },
	npc_dota_hero_shadow_shaman = { 0.3, 0.5, 900 },
	npc_dota_hero_silencer = { 0.5, 0.5, 1000 },
	npc_dota_hero_skywrath_mage = { 0.4, 0.78, 1000 },
	npc_dota_hero_slardar = { 0.36, 0.64, 0 },
	npc_dota_hero_slark = { 0.5, 0.3, 0 },
	npc_dota_hero_sniper = { 0.17, 0.7, 3000 },
	npc_dota_hero_spectre = { 0.3, 0.7, 0 },
	npc_dota_hero_spirit_breaker = { 0.6, 0.3, 0 },
	npc_dota_hero_storm_spirit = { 0.5, 0.3, 1100 },
	npc_dota_hero_sven = { 0.4, 0.3, 0 },
	npc_dota_hero_techies = { 0.5, 0.5, 900 },
	npc_dota_hero_templar_assassin = { 0.3, 0.5, 900 },
	npc_dota_hero_terrorblade = { 0.3, 0.6, 0 },
	npc_dota_hero_tidehunter = { 0.6, 0.56, 0 },
	npc_dota_hero_shredder = { 0.36, 0.64, 0 },
	npc_dota_hero_tinker = { 0.35, 0.65, 900 },
	npc_dota_hero_tiny = { 0.49, 1, 0 },
	npc_dota_hero_treant = { 0.6, 0.4, 0 },
	npc_dota_hero_troll_warlord = { 0.3, 0.3, 1200 },
	npc_dota_hero_tusk = { 0.36, 0.64, 0 },
	npc_dota_hero_abyssal_underlord = { 0.45, 0.7, 0 },
	npc_dota_hero_undying = { 0.3, 0.3, 0 },
	npc_dota_hero_ursa = { 0.3, 0.3, 0 },
	npc_dota_hero_vengefulspirit = { 0.33, 0.64, 1500 },
	npc_dota_hero_venomancer = { 0.3, 0.7, 900 },
	npc_dota_hero_viper = { 0.33, 1, 1200 },
	npc_dota_hero_visage = { 0.46, 0.54, 900 },
	npc_dota_hero_warlock = { 0.3, 0.3, 1200 },
	npc_dota_hero_weaver = { 0.64, 0.36, 900 },
	npc_dota_hero_windrunner = { 0.4, 0.3, 1250 },
	npc_dota_hero_winter_wyvern = { 0.25, 0.8, 700 },
	npc_dota_hero_witch_doctor = { 0.4, 0.5, 1200 },
	npc_dota_hero_skeleton_king = { 0.56, 0.44, 0 },
	npc_dota_hero_zuus = { 0.633, 0.366, 1100 },
	npc_dota_hero_dark_willow = { 0.3, 0.7, 1200 },
	npc_dota_hero_pangolier = { 0.33, 0.67, 0 } }

FAIO.AbilityList = {
	{ "npc_dota_hero_abaddon", "abaddon_death_coil", "nuke", "target" , "target_damage" },
	{ "npc_dota_hero_abaddon", "abaddon_frostmourne", "utility", "0" , "0" },
	{ "npc_dota_hero_abaddon", "abaddon_aphotic_shield", "utility", "0" , "0" },
	{ "npc_dota_hero_abaddon", "abaddon_borrowed_time", "utility", "0" , "0" },
	{ "npc_dota_hero_abyssal_underlord", "abyssal_underlord_pit_of_malice", "disable", "position" , "0" },
	{ "npc_dota_hero_abyssal_underlord", "abyssal_underlord_firestorm", "nuke", "position" , "0" },
	{ "npc_dota_hero_abyssal_underlord", "abyssal_underlord_atrophy_aura", "utility", "0" , "0" },
	{ "npc_dota_hero_abyssal_underlord", "abyssal_underlord_dark_rift", "utility", "0" , "0" },
	{ "npc_dota_hero_alchemist", "alchemist_unstable_concoction", "disable", "target" , "0" },
	{ "npc_dota_hero_alchemist", "alchemist_unstable_concoction_throw", "disable", "target" , "0" },
	{ "npc_dota_hero_alchemist", "alchemist_acid_spray", "utility", "0" , "0" },
	{ "npc_dota_hero_alchemist", "alchemist_chemical_rage", "utility", "0" , "0" },
	{ "npc_dota_hero_alchemist", "alchemist_goblins_greed", "utility", "0" , "0" },
	{ "npc_dota_hero_ancient_apparition", "ancient_apparition_ice_blast", "nuke", "position" , "0" },
	{ "npc_dota_hero_ancient_apparition", "ancient_apparition_ice_blast_release", "nuke", "position" , "0" },
	{ "npc_dota_hero_ancient_apparition", "ancient_apparition_chilling_touch", "utility", "0" , "0" },
	{ "npc_dota_hero_ancient_apparition", "ancient_apparition_cold_feet", "utility", "0" , "0" },
	{ "npc_dota_hero_ancient_apparition", "ancient_apparition_ice_vortex", "utility", "0" , "0" },
	{ "npc_dota_hero_antimage", "antimage_mana_void"    , "nuke", "target" , "0" },
	{ "npc_dota_hero_antimage", "antimage_blink", "utility", "0" , "0" },
	{ "npc_dota_hero_antimage", "antimage_mana_break", "utility", "0" , "0" },
	{ "npc_dota_hero_antimage", "antimage_spell_shield", "utility", "0" , "0" },
	{ "npc_dota_hero_arcwarden", "arc_warden_flux", "utility", "0" , "0" },
	{ "npc_dota_hero_arcwarden", "arc_warden_magnetic_field", "utility", "0" , "0" },
	{ "npc_dota_hero_arcwarden", "arc_warden_spark_wraith", "utility", "0" , "0" },
	{ "npc_dota_hero_arcwarden", "arc_warden_tempest_double", "utility", "0" , "0" },
	{ "npc_dota_hero_axe", "axe_berserkers_call", "disable", "no target" , "0" },
	{ "npc_dota_hero_axe", "axe_culling_blade", "nuke", "target" , "damage" },
	{ "npc_dota_hero_axe", "axe_battle_hunger", "utility", "0" , "0" },
	{ "npc_dota_hero_axe", "axe_counter_helix", "utility", "0" , "0" },
	{ "npc_dota_hero_bane", "bane_brain_sap", "pure", "target" , "brain_sap_damage" },
	{ "npc_dota_hero_bane", "bane_fiends_grip", "nuke", "target" , "0" },
	{ "npc_dota_hero_bane", "bane_enfeeble", "utility", "0" , "0" },
	{ "npc_dota_hero_bane", "bane_nightmare", "utility", "0" , "0" },
	{ "npc_dota_hero_bane", "bane_nightmare_end", "utility", "0" , "0" },
	{ "npc_dota_hero_batrider", "batrider_firefly", "utility", "0" , "0" },
	{ "npc_dota_hero_batrider", "batrider_flamebreak", "utility", "0" , "0" },
	{ "npc_dota_hero_batrider", "batrider_flaming_lasso", "utility", "0" , "0" },
	{ "npc_dota_hero_batrider", "batrider_sticky_napalm", "utility", "0" , "0" },
	{ "npc_dota_hero_beastmaster", "beastmaster_wild_axes", "nuke", "position" , "axe_damage" },
	{ "npc_dota_hero_beastmaster", "beastmaster_primal_roar", "disable", "no target" , "0" },
	{ "npc_dota_hero_beastmaster", "beastmaster_boar_poison", "utility", "0" , "0" },
	{ "npc_dota_hero_beastmaster", "beastmaster_call_of_the_wild", "utility", "0" , "0" },
	{ "npc_dota_hero_beastmaster", "beastmaster_call_of_the_wild_boar", "utility", "0" , "0" },
	{ "npc_dota_hero_beastmaster", "beastmaster_greater_boar_poison", "utility", "0" , "0" },
	{ "npc_dota_hero_beastmaster", "beastmaster_hawk_invisibility", "utility", "0" , "0" },
	{ "npc_dota_hero_beastmaster", "beastmaster_inner_beast", "utility", "0" , "0" },
	{ "npc_dota_hero_bloodseeker", "bloodseeker_blood_bath", "nuke", "position" , "damage" },
	{ "npc_dota_hero_bloodseeker", "bloodseeker_rupture", "utility", "0" , "0" },
	{ "npc_dota_hero_bloodseeker", "bloodseeker_thirst", "utility", "0" , "0" },
	{ "npc_dota_hero_bounty_hunter", "bounty_hunter_shuriken_toss", "nuke", "target" , "bonus_damage" },
	{ "npc_dota_hero_bounty_hunter", "bounty_hunter_jinada", "utility", "0" , "0" },
	{ "npc_dota_hero_bounty_hunter", "bounty_hunter_track", "utility", "0" , "0" },
	{ "npc_dota_hero_brewmaster", "brewmaster_thunder_clap", "nuke", "no target" , "damage" },
	{ "npc_dota_hero_brewmaster", "brewmaster_earth_hurl_boulder", "disable", "target" , "0" },
	{ "npc_dota_hero_brewmaster", "brewmaster_drunken_brawler", "utility", "0" , "0" },
	{ "npc_dota_hero_brewmaster", "brewmaster_drunken_haze", "utility", "0" , "0" },
	{ "npc_dota_hero_brewmaster", "brewmaster_earth_pulverize", "utility", "0" , "0" },
	{ "npc_dota_hero_brewmaster", "brewmaster_earth_spell_immunity", "utility", "0" , "0" },
	{ "npc_dota_hero_brewmaster", "brewmaster_fire_permanent_immolation", "utility", "0" , "0" },
	{ "npc_dota_hero_brewmaster", "brewmaster_primal_split", "utility", "0" , "0" },
	{ "npc_dota_hero_brewmaster", "brewmaster_storm_cyclone", "utility", "0" , "0" },
	{ "npc_dota_hero_brewmaster", "brewmaster_storm_dispel_magic", "utility", "0" , "0" },
	{ "npc_dota_hero_brewmaster", "brewmaster_storm_wind_walk", "utility", "0" , "0" },
	{ "npc_dota_hero_bristleback", "bristleback_quill_spray", "nuke", "no target" , "quill_base_damage" },
	{ "npc_dota_hero_bristleback", "bristleback_bristleback", "utility", "0" , "0" },
	{ "npc_dota_hero_bristleback", "bristleback_viscous_nasal_goo", "utility", "0" , "0" },
	{ "npc_dota_hero_bristleback", "bristleback_warpath", "utility", "0" , "0" },
	{ "npc_dota_hero_broodmother", "broodmother_spawn_spiderlings", "nuke", "target" , "damage" },
	{ "npc_dota_hero_broodmother", "broodmother_incapacitating_bite", "utility", "0" , "0" },
	{ "npc_dota_hero_broodmother", "broodmother_insatiable_hunger", "utility", "0" , "0" },
	{ "npc_dota_hero_broodmother", "broodmother_poison_sting", "utility", "0" , "0" },
	{ "npc_dota_hero_broodmother", "broodmother_spawn_spiderite", "utility", "0" , "0" },
	{ "npc_dota_hero_broodmother", "broodmother_spin_web", "utility", "0" , "0" },
	{ "npc_dota_hero_broodmother", "broodmother_spin_web_destroy"  , "utility", "0" , "0" },
	{ "npc_dota_hero_centaur", "centaur_double_edge", "nuke", "no target" , "edge_damage" },
	{ "npc_dota_hero_centaur", "centaur_hoof_stomp", "disable", "no target" , "0" },
	{ "npc_dota_hero_centaur", "centaur_return", "utility", "0" , "0" },
	{ "npc_dota_hero_centaur", "centaur_stampede", "utility", "0" , "0" },
	{ "npc_dota_hero_chaos_knight", "chaos_knight_chaos_bolt", "disable", "target" , "0" },
	{ "npc_dota_hero_chaos_knight", "chaos_knight_chaos_strike", "utility", "0" , "0" },
	{ "npc_dota_hero_chaos_knight", "chaos_knight_phantasm", "utility", "0" , "0" },
	{ "npc_dota_hero_chaos_knight", "chaos_knight_reality_rift", "utility", "0" , "0" },
	{ "npc_dota_hero_chen", "chen_test_of_faith", "pure", "target" , "damage_min" },
	{ "npc_dota_hero_chen", "chen_hand_of_god", "utility", "0" , "0" },
	{ "npc_dota_hero_chen", "chen_holy_persuasion", "utility", "0" , "0" },
	{ "npc_dota_hero_chen", "chen_penitence", "utility", "0" , "0" },
	{ "npc_dota_hero_chen", "chen_test_of_faith_teleport", "utility", "0" , "0" },
	{ "npc_dota_hero_clinkz", "clinkz_death_pact", "utility", "0" , "0" },
	{ "npc_dota_hero_clinkz", "clinkz_searing_arrows", "utility", "0" , "0" },
	{ "npc_dota_hero_clinkz", "clinkz_strafe", "utility", "0" , "0" },
	{ "npc_dota_hero_clinkz", "clinkz_wind_walk", "utility", "0" , "0" },
	{ "npc_dota_hero_crystal_maiden", "crystal_maiden_crystal_nova", "nuke", "position" , "nova_damage" },
	{ "npc_dota_hero_crystal_maiden", "crystal_maiden_frostbite", "disable", "target" , "0" },
	{ "npc_dota_hero_crystal_maiden", "crystal_maiden_freezing_field", "nuke", "no target" , "0" },
	{ "npc_dota_hero_crystal_maiden", "crystal_maiden_brilliance_aura", "utility", "0" , "0" },
	{ "npc_dota_hero_dark_seer", "dark_seer_ion_shell", "utility", "0" , "0" },
	{ "npc_dota_hero_dark_seer", "dark_seer_surge", "utility", "0" , "0" },
	{ "npc_dota_hero_dark_seer", "dark_seer_vacuum", "utility", "0" , "0" },
	{ "npc_dota_hero_dark_seer", "dark_seer_wall_of_replica", "utility", "0" , "0" },
	{ "npc_dota_hero_dazzle", "dazzle_poison_touch", "nuke", "target" , "0" },
	{ "npc_dota_hero_dazzle", "dazzle_shadow_wave", "utility", "0" , "0" },
	{ "npc_dota_hero_dazzle", "dazzle_shallow_grave", "utility", "0" , "0" },
	{ "npc_dota_hero_dazzle", "dazzle_weave", "utility", "0" , "0" },
	{ "npc_dota_hero_death_prophet", "death_prophet_silence", "disable", "position" , "0" },
	{ "npc_dota_hero_death_prophet", "death_prophet_carrion_swarm", "nuke", "skillshot" , "0" },
	{ "npc_dota_hero_death_prophet", "death_prophet_exorcism", "utility", "0" , "0" },
	{ "npc_dota_hero_death_prophet", "death_prophet_spirit_siphon", "utility", "0" , "0" },
	{ "npc_dota_hero_death_prophet", "death_prophet_witchcraft", "utility", "0" , "0" },
	{ "npc_dota_hero_disruptor", "disruptor_thunder_strike", "nuke", "target" , "0" },
	{ "npc_dota_hero_disruptor", "disruptor_glimpse", "utility", "0" , "0" },
	{ "npc_dota_hero_disruptor", "disruptor_kinetic_field", "utility", "0" , "0" },
	{ "npc_dota_hero_disruptor", "disruptor_static_storm", "utility", "0" , "0" },
	{ "npc_dota_hero_doom_bringer", "doom_bringer_devour", "utility", "0" , "0" },
	{ "npc_dota_hero_doom_bringer", "doom_bringer_doom", "utility", "0" , "0" },
	{ "npc_dota_hero_doom_bringer", "doom_bringer_empty1", "utility", "0" , "0" },
	{ "npc_dota_hero_doom_bringer", "doom_bringer_empty2", "utility", "0" , "0" },
	{ "npc_dota_hero_doom_bringer", "doom_bringer_infernal_blade", "utility", "0" , "0" },
	{ "npc_dota_hero_doom_bringer", "doom_bringer_scorched_earth", "utility", "0" , "0" },
	{ "npc_dota_hero_dragon_knight", "dragon_knight_dragon_tail", "disable", "target" , "0" },
	{ "npc_dota_hero_dragon_knight", "dragon_knight_breathe_fire", "nuke", "position" , "0" },
	{ "npc_dota_hero_dragon_knight", "dragon_knight_dragon_blood", "utility", "0" , "0" },
	{ "npc_dota_hero_dragon_knight", "dragon_knight_elder_dragon_form", "utility", "0" , "0" },
	{ "npc_dota_hero_dragon_knight", "dragon_knight_frost_breath", "utility", "0" , "0" },
	{ "npc_dota_hero_drow_ranger", "drow_ranger_silence", "disable", "position" , "0" },
	{ "npc_dota_hero_drow_ranger", "drow_ranger_wave_of_silence", "disable", "position" , "0" },
	{ "npc_dota_hero_drow_ranger", "drow_ranger_frost_arrows", "utility", "0" , "0" },
	{ "npc_dota_hero_drow_ranger", "drow_ranger_marksmanship", "utility", "0" , "0" },
	{ "npc_dota_hero_drow_ranger", "drow_ranger_trueshot", "utility", "0" , "0" },
	{ "npc_dota_hero_earth_spirit", "earth_spirit_boulder_smash", "disable", "position" , "0" },
	{ "npc_dota_hero_earth_spirit", "earth_spirit_geomagnetic_grip", "disable", "position" , "0" },
	{ "npc_dota_hero_earth_spirit", "earth_spirit_magnetize", "utility", "0" , "0" },
	{ "npc_dota_hero_earth_spirit", "earth_spirit_petrify", "utility", "0" , "0" },
	{ "npc_dota_hero_earth_spirit", "earth_spirit_rolling_boulder", "utility", "0" , "0" },
	{ "npc_dota_hero_earth_spirit", "earth_spirit_stone_caller", "utility", "0" , "0" },
	{ "npc_dota_hero_earthshaker", "earthshaker_aftershock", "disable", "no target" , "0" },
	{ "npc_dota_hero_earthshaker", "earthshaker_fissure", "disable", "position" , "0" },
	{ "npc_dota_hero_earthshaker", "earthshaker_echo_slam", "nuke", "no target" , "0" },
	{ "npc_dota_hero_earthshaker", "earthshaker_enchant_totem", "utility", "0" , "0" },
	{ "npc_dota_hero_elder_titan", "elder_titan_ancestral_spirit", "nuke", "position" , "pass_damage" },
	{ "npc_dota_hero_elder_titan", "elder_titan_echo_stomp_spirit", "disable", "no target" , "0" },
	{ "npc_dota_hero_elder_titan", "elder_titan_earth_splitter", "nuke", "position" , "0" },
	{ "npc_dota_hero_elder_titan", "elder_titan_natural_order", "utility", "0" , "0" },
	{ "npc_dota_hero_elder_titan", "elder_titan_echo_stomp", "utility", "0" , "0" },
	{ "npc_dota_hero_elder_titan", "elder_titan_natural_order_spirit", "utility", "0" , "0" },
	{ "npc_dota_hero_elder_titan", "elder_titan_return_spirit", "utility", "0" , "0" },
	{ "npc_dota_hero_ember_spirit", "ember_spirit_searing_chains", "disable", "no target" , "0" },
	{ "npc_dota_hero_ember_spirit", "ember_spirit_activate_fire_remnant", "utility", "0" , "0" },
	{ "npc_dota_hero_ember_spirit", "ember_spirit_fire_remnant", "utility", "0" , "0" },
	{ "npc_dota_hero_ember_spirit", "ember_spirit_flame_guard", "utility", "0" , "0" },
	{ "npc_dota_hero_ember_spirit", "ember_spirit_sleight_of_fist", "utility", "0" , "0" },
	{ "npc_dota_hero_enchantress", "enchantress_impetus", "nuke", "target" , "0" },
	{ "npc_dota_hero_enchantress", "enchantress_enchant", "utility", "0" , "0" },
	{ "npc_dota_hero_enchantress", "enchantress_natures_attendants", "utility", "0" , "0" },
	{ "npc_dota_hero_enchantress", "enchantress_untouchable", "utility", "0" , "0" },
	{ "npc_dota_hero_enigma", "enigma_black_hole", "disable", "position" , "0" },
	{ "npc_dota_hero_enigma", "enigma_demonic_conversion", "utility", "0" , "0" },
	{ "npc_dota_hero_enigma", "enigma_malefice", "utility", "0" , "0" },
	{ "npc_dota_hero_enigma", "enigma_midnight_pulse", "utility", "0" , "0" },
	{ "npc_dota_hero_faceless_void", "faceless_void_chronosphere", "disable", "position" , "0" },
	{ "npc_dota_hero_faceless_void", "faceless_void_backtrack", "utility", "0" , "0" },
	{ "npc_dota_hero_faceless_void", "faceless_void_time_dilation", "utility", "0" , "0" },
	{ "npc_dota_hero_faceless_void", "faceless_void_time_lock", "utility", "0" , "0" },
	{ "npc_dota_hero_faceless_void", "faceless_void_time_walk", "utility", "0" , "0" },
	{ "npc_dota_hero_furion", "furion_force_of_nature", "utility", "0" , "0" },
	{ "npc_dota_hero_furion", "furion_sprout", "utility", "0" , "0" },
	{ "npc_dota_hero_furion", "furion_teleportation", "utility", "0" , "0" },
	{ "npc_dota_hero_furion", "furion_wrath_of_nature", "utility", "0" , "0" },
	{ "npc_dota_hero_gyrocopter", "gyrocopter_call_down", "nuke", "position" , "damage_first" },
	{ "npc_dota_hero_gyrocopter", "gyrocopter_homing_missile", "disable", "target" , "0" },
	{ "npc_dota_hero_gyrocopter", "gyrocopter_rocket_barrage", "nuke", "no target" , "0" },
	{ "npc_dota_hero_gyrocopter", "gyrocopter_flak_cannon", "utility", "0" , "0" },
	{ "npc_dota_hero_huskar", "huskar_berserkers_blood", "utility", "0" , "0" },
	{ "npc_dota_hero_huskar", "huskar_burning_spear", "utility", "0" , "0" },
	{ "npc_dota_hero_huskar", "huskar_inner_vitality", "utility", "0" , "0" },
	{ "npc_dota_hero_huskar", "huskar_life_break", "utility", "0" , "0" },
	{ "npc_dota_hero_invoker", "invoker_cold_snap", "disable", "no target" , "0" },
	{ "npc_dota_hero_invoker", "invoker_tornado", "disable", "position" , "0" },
	{ "npc_dota_hero_invoker", "invoker_alacrity", "utility", "0" , "0" },
	{ "npc_dota_hero_invoker", "invoker_attribute_bonus", "utility", "0" , "0" },
	{ "npc_dota_hero_invoker", "invoker_chaos_meteor", "utility", "0" , "0" },
	{ "npc_dota_hero_invoker", "invoker_deafening_blast", "utility", "0" , "0" },
	{ "npc_dota_hero_invoker", "invoker_emp", "utility", "0" , "0" },
	{ "npc_dota_hero_invoker", "invoker_empty1", "utility", "0" , "0" },
	{ "npc_dota_hero_invoker", "invoker_empty2", "utility", "0" , "0" },
	{ "npc_dota_hero_invoker", "invoker_exort", "utility", "0" , "0" },
	{ "npc_dota_hero_invoker", "invoker_forge_spirit", "utility", "0" , "0" },
	{ "npc_dota_hero_invoker", "invoker_ghost_walk", "utility", "0" , "0" },
	{ "npc_dota_hero_invoker", "invoker_ice_wall", "utility", "0" , "0" },
	{ "npc_dota_hero_invoker", "invoker_invoke", "utility", "0" , "0" },
	{ "npc_dota_hero_invoker", "invoker_quas", "utility", "0" , "0" },
	{ "npc_dota_hero_invoker", "invoker_sun_strike", "utility", "0" , "0" },
	{ "npc_dota_hero_invoker", "invoker_wex", "utility", "0" , "0" },
	{ "npc_dota_hero_jakiro", "jakiro_ice_path", "disable", "position" , "0" },
	{ "npc_dota_hero_jakiro", "jakiro_macropyre", "nuke", "position" , "0" },
	{ "npc_dota_hero_jakiro", "jakiro_dual_breath", "utility", "0" , "0" },
	{ "npc_dota_hero_jakiro", "jakiro_liquid_fire", "utility", "0" , "0" },
	{ "npc_dota_hero_juggernaut", "juggernaut_omni_slash", "nuke", "target" , "0" },
	{ "npc_dota_hero_juggernaut", "juggernaut_blade_dance", "utility", "0" , "0" },
	{ "npc_dota_hero_juggernaut", "juggernaut_blade_fury", "utility", "0" , "0" },
	{ "npc_dota_hero_juggernaut", "juggernaut_healing_ward", "utility", "0" , "0" },
	{ "npc_dota_hero_keeper_of_the_light", "keeper_of_the_light_blinding_light", "utility", "0" , "0" },
	{ "npc_dota_hero_keeper_of_the_light", "keeper_of_the_light_chakra_magic", "utility", "0" , "0" },
	{ "npc_dota_hero_keeper_of_the_light", "keeper_of_the_light_empty1", "utility", "0" , "0" },
	{ "npc_dota_hero_keeper_of_the_light", "keeper_of_the_light_illuminate", "utility", "0" , "0" },
	{ "npc_dota_hero_keeper_of_the_light", "keeper_of_the_light_illuminate_end", "utility", "0" , "0" },
	{ "npc_dota_hero_keeper_of_the_light", "keeper_of_the_light_mana_leak", "utility", "0" , "0" },
	{ "npc_dota_hero_keeper_of_the_light", "keeper_of_the_light_recall", "utility", "0" , "0" },
	{ "npc_dota_hero_keeper_of_the_light", "keeper_of_the_light_spirit_form", "utility", "0" , "0" },
	{ "npc_dota_hero_keeper_of_the_light", "keeper_of_the_light_spirit_form_illuminate", "utility", "0" , "0" },
	{ "npc_dota_hero_keeper_of_the_light", "keeper_of_the_light_spirit_form_illuminate_end", "utility", "0" , "0" },
	{ "npc_dota_hero_kunkka", "kunkka_ghostship", "nuke", "position" , "0" },
	{ "npc_dota_hero_kunkka", "kunkka_torrent", "nuke", "skillshot" , "0" },
	{ "npc_dota_hero_kunkka", "kunkka_return", "utility", "0" , "0" },
	{ "npc_dota_hero_kunkka", "kunkka_tidebringer", "utility", "0" , "0" },
	{ "npc_dota_hero_kunkka", "kunkka_x_marks_the_spot", "utility", "0" , "0" },
	{ "npc_dota_hero_legion_commander", "legion_commander_overwhelming_odds", "nuke", "position" , "damage" },
	{ "npc_dota_hero_legion_commander", "legion_commander_duel", "disable", "target" , "0" },
	{ "npc_dota_hero_legion_commander", "legion_commander_moment_of_courage", "utility", "0" , "0" },
	{ "npc_dota_hero_legion_commander", "legion_commander_press_the_attack", "utility", "0" , "0" },
	{ "npc_dota_hero_leshrac", "leshrac_split_earth", "disable", "position" , "0" },
	{ "npc_dota_hero_leshrac", "leshrac_lightning_storm", "nuke", "target" , "0" },
	{ "npc_dota_hero_leshrac", "leshrac_pulse_nova", "utility", "0" , "0" },
	{ "npc_dota_hero_leshrac", "leshrac_diabolic_edict", "utility", "0" , "0" },
	{ "npc_dota_hero_lich", "lich_chain_frost", "nuke", "target" , "damage" },
	{ "npc_dota_hero_lich", "lich_frost_nova", "nuke", "position" , "aoe_damage" },
	{ "npc_dota_hero_lich", "lich_dark_ritual", "utility", "0" , "0" },
	{ "npc_dota_hero_lich", "lich_frost_armor", "utility", "0" , "0" },
	{ "npc_dota_hero_life_stealer", "life_stealer_assimilate", "utility", "0" , "0" },
	{ "npc_dota_hero_life_stealer", "life_stealer_assimilate_eject", "utility", "0" , "0" },
	{ "npc_dota_hero_life_stealer", "life_stealer_consume", "utility", "0" , "0" },
	{ "npc_dota_hero_life_stealer", "life_stealer_control", "utility", "0" , "0" },
	{ "npc_dota_hero_life_stealer", "life_stealer_empty_1", "utility", "0" , "0" },
	{ "npc_dota_hero_life_stealer", "life_stealer_empty_2", "utility", "0" , "0" },
	{ "npc_dota_hero_life_stealer", "life_stealer_empty_3", "utility", "0" , "0" },
	{ "npc_dota_hero_life_stealer", "life_stealer_empty_4", "utility", "0" , "0" },
	{ "npc_dota_hero_life_stealer", "life_stealer_feast", "utility", "0" , "0" },
	{ "npc_dota_hero_life_stealer", "life_stealer_infest", "utility", "0" , "0" },
	{ "npc_dota_hero_life_stealer", "life_stealer_open_wounds", "utility", "0" , "0" },
	{ "npc_dota_hero_life_stealer", "life_stealer_rage", "utility", "0" , "0" },
	{ "npc_dota_hero_lina", "lina_laguna_blade", "nuke", "target" , "damage" },
	{ "npc_dota_hero_lina", "lina_light_strike_array", "disable", "position" , "0" },
	{ "npc_dota_hero_lina", "lina_dragon_slave", "nuke", "skillshot" , "0" },
	{ "npc_dota_hero_lina", "lina_fiery_soul", "utility", "0" , "0" },
	{ "npc_dota_hero_lion", "lion_finger_of_death", "nuke", "target" , "damage" },
	{ "npc_dota_hero_lion", "lion_impale", "disable", "position" , "0" },
	{ "npc_dota_hero_lion", "lion_voodoo", "disable", "target" , "0" },
	{ "npc_dota_hero_lion", "lion_mana_drain", "utility", "0" , "0" },
	{ "npc_dota_hero_lone_druid", "lone_druid_rabid", "utility", "0" , "0" },
	{ "npc_dota_hero_lone_druid", "lone_druid_savage_roar", "utility", "0" , "0" },
	{ "npc_dota_hero_lone_druid", "lone_druid_savage_roar_bear", "utility", "0" , "0" },
	{ "npc_dota_hero_lone_druid", "lone_druid_spirit_bear", "utility", "0" , "0" },
	{ "npc_dota_hero_lone_druid", "lone_druid_spirit_bear_demolish", "utility", "0" , "0" },
	{ "npc_dota_hero_lone_druid", "lone_druid_spirit_bear_entangle", "utility", "0" , "0" },
	{ "npc_dota_hero_lone_druid", "lone_druid_spirit_bear_return", "utility", "0" , "0" },
	{ "npc_dota_hero_lone_druid", "lone_druid_true_form", "utility", "0" , "0" },
	{ "npc_dota_hero_lone_druid", "lone_druid_true_form_battle_cry", "utility", "0" , "0" },
	{ "npc_dota_hero_lone_druid", "lone_druid_true_form_druid", "utility", "0" , "0" },
	{ "npc_dota_hero_luna", "luna_lucent_beam", "nuke", "target" , "beam_damage" },
	{ "npc_dota_hero_luna", "luna_eclipse", "nuke", "no target" , "0" },
	{ "npc_dota_hero_luna", "luna_lunar_blessing", "utility", "0" , "0" },
	{ "npc_dota_hero_luna", "luna_moon_glaive", "utility", "0" , "0" },
	{ "npc_dota_hero_lycan", "lycan_feral_impulse", "utility", "0" , "0" },
	{ "npc_dota_hero_lycan", "lycan_howl", "utility", "0" , "0" },
	{ "npc_dota_hero_lycan", "lycan_shapeshift", "utility", "0" , "0" },
	{ "npc_dota_hero_lycan", "lycan_summon_wolves", "utility", "0" , "0" },
	{ "npc_dota_hero_lycan", "lycan_summon_wolves_critical_strike", "utility", "0" , "0" },
	{ "npc_dota_hero_lycan", "lycan_summon_wolves_invisibility", "utility", "0" , "0" },
	{ "npc_dota_hero_magnataur", "magnataur_shockwave", "nuke", "skillshot" , "shock_damage" },
	{ "npc_dota_hero_magnataur", "magnataur_reverse_polarity", "disable", "no target" , "0" },
	{ "npc_dota_hero_magnataur", "magnataur_empower", "utility", "0" , "0" },
	{ "npc_dota_hero_magnataur", "magnataur_skewer", "utility", "0" , "0" },
	{ "npc_dota_hero_medusa", "medusa_mystic_snake", "pure", "target" , "snake_damage" },
	{ "npc_dota_hero_medusa", "medusa_mana_shield", "utility", "0" , "0" },
	{ "npc_dota_hero_medusa", "medusa_split_shot", "utility", "0" , "0" },
	{ "npc_dota_hero_medusa", "medusa_stone_gaze", "utility", "0" , "0" },
	{ "npc_dota_hero_meepo", "meepo_earthbind", "disable", "position" , "0" },
	{ "npc_dota_hero_meepo", "meepo_poof", "utility", "0" , "0" },
	{ "npc_dota_hero_meepo", "meepo_divided_we_stand", "utility", "0" , "0" },
	{ "npc_dota_hero_meepo", "meepo_geostrike", "utility", "0" , "0" },
	{ "npc_dota_hero_mirana", "mirana_arrow", "disable", "position" , "0" },
	{ "npc_dota_hero_mirana", "mirana_starfall", "nuke", "no target" , "0" },
	{ "npc_dota_hero_mirana", "mirana_invis", "utility", "0" , "0" },
	{ "npc_dota_hero_mirana", "mirana_leap", "utility", "0" , "0" },
	{ "npc_dota_hero_monkey_king", "monkey_king_primal_spring", "disable", "position" , "0" },
	{ "npc_dota_hero_monkey_king", "monkey_king_primal_spring_early", "disable", "position" , "0" },
	{ "npc_dota_hero_monkey_king", "monkey_king_boundless_strike", "nuke", "position" , "0" },
	{ "npc_dota_hero_monkey_king", "monkey_king_jingu_mastery", "utility", "0" , "0" },
	{ "npc_dota_hero_monkey_king", "monkey_king_mischief", "utility", "0" , "0" },
	{ "npc_dota_hero_monkey_king", "monkey_king_tree_dance", "utility", "0" , "0" },
	{ "npc_dota_hero_monkey_king", "monkey_king_untransform", "utility", "0" , "0" },
	{ "npc_dota_hero_monkey_king", "monkey_king_wukongs_command", "utility", "0" , "0" },
	{ "npc_dota_hero_morphling", "morphling_adaptive_strike_agi", "nuke", "target" , "damage_base" },
	{ "npc_dota_hero_morphling", "morphling_waveform", "utility", "0" , "0" },
	{ "npc_dota_hero_morphling", "morphling_hybrid", "utility", "0" , "0" },
	{ "npc_dota_hero_morphling", "morphling_morph", "utility", "0" , "0" },
	{ "npc_dota_hero_morphling", "morphling_morph_agi", "utility", "0" , "0" },
	{ "npc_dota_hero_morphling", "morphling_morph_replicate", "utility", "0" , "0" },
	{ "npc_dota_hero_morphling", "morphling_morph_str", "utility", "0" , "0" },
	{ "npc_dota_hero_morphling", "morphling_replicate", "utility", "0" , "0" },
	{ "npc_dota_hero_naga_siren", "naga_siren_ensnare", "disable", "target" , "0" },
	{ "npc_dota_hero_naga_siren", "naga_siren_rip_tide", "nuke", "no target" , "0" },
	{ "npc_dota_hero_naga_siren", "naga_siren_mirror_image", "utility", "0" , "0" },
	{ "npc_dota_hero_naga_siren", "naga_siren_song_of_the_siren", "utility", "0" , "0" },
	{ "npc_dota_hero_naga_siren", "naga_siren_song_of_the_siren_cancel", "utility", "0" , "0" },
	{ "npc_dota_hero_necrolyte", "necrolyte_reapers_scythe", "disable", "target" , "0" },
	{ "npc_dota_hero_necrolyte", "necrolyte_death_pulse", "nuke", "no target" , "0" },
	{ "npc_dota_hero_necrolyte", "necrolyte_heartstopper_aura", "utility", "0" , "0" },
	{ "npc_dota_hero_necrolyte", "necrolyte_sadist", "utility", "0" , "0" },
	{ "npc_dota_hero_necrolyte", "necrolyte_sadist_stop", "utility", "0" , "0" },
	{ "npc_dota_hero_nevermore", "nevermore_dark_lord", "utility", "0" , "0" },
	{ "npc_dota_hero_nevermore", "nevermore_necromastery", "utility", "0" , "0" },
	{ "npc_dota_hero_nevermore", "nevermore_requiem", "utility", "0" , "0" },
	{ "npc_dota_hero_nevermore", "nevermore_shadowraze1", "nuke", "special" , "shadowraze_damage" },
	{ "npc_dota_hero_nevermore", "nevermore_shadowraze2", "nuke", "special" , "shadowraze_damage" },
	{ "npc_dota_hero_nevermore", "nevermore_shadowraze3", "nuke", "special" , "shadowraze_damage" },
	{ "npc_dota_hero_night_stalker", "night_stalker_void", "nuke", "target" , "0" },
	{ "npc_dota_hero_night_stalker", "night_stalker_crippling_fear", "utility", "0" , "0" },
	{ "npc_dota_hero_night_stalker", "night_stalker_darkness", "utility", "0" , "0" },
	{ "npc_dota_hero_night_stalker", "night_stalker_hunter_in_the_night", "utility", "0" , "0" },
	{ "npc_dota_hero_nyx_assassin", "nyx_assassin_impale", "disable", "position" , "0" },
	{ "npc_dota_hero_nyx_assassin", "nyx_assassin_mana_burn", "nuke", "special" , "0" },
	{ "npc_dota_hero_nyx_assassin", "nyx_assassin_burrow", "utility", "0" , "0" },
	{ "npc_dota_hero_nyx_assassin", "nyx_assassin_spiked_carapace", "utility", "0" , "0" },
	{ "npc_dota_hero_nyx_assassin", "nyx_assassin_unburrow", "utility", "0" , "0" },
	{ "npc_dota_hero_nyx_assassin", "nyx_assassin_vendetta", "utility", "0" , "0" },
	{ "npc_dota_hero_obsidian_destroyer", "obsidian_destroyer_astral_imprisonment", "utility", "0" , "0" },
	{ "npc_dota_hero_obsidian_destroyer", "obsidian_destroyer_sanity_eclipse", "nuke", "position" , "0" },
	{ "npc_dota_hero_obsidian_destroyer", "obsidian_destroyer_arcane_orb", "utility", "0" , "0" },
	{ "npc_dota_hero_obsidian_destroyer", "obsidian_destroyer_essence_aura", "utility", "0" , "0" },
	{ "npc_dota_hero_obsidian_destroyer", "obsidian_destroyer_mind_over_matter", "utility", "0" , "0" },
	{ "npc_dota_hero_ogre_magi", "ogre_magi_fireblast", "nuke", "target" , "0" },
	{ "npc_dota_hero_ogre_magi", "ogre_magi_unrefined_fireblast", "nuke", "target" , "0" },
	{ "npc_dota_hero_ogre_magi", "ogre_magi_bloodlust", "utility", "0" , "0" },
	{ "npc_dota_hero_ogre_magi", "ogre_magi_ignite", "utility", "0" , "0" },
	{ "npc_dota_hero_ogre_magi", "ogre_magi_multicast", "utility", "0" , "0" },
	{ "npc_dota_hero_omniknight", "omniknight_degen_aura", "utility", "0" , "0" },
	{ "npc_dota_hero_omniknight", "omniknight_guardian_angel", "utility", "0" , "0" },
	{ "npc_dota_hero_omniknight", "omniknight_purification", "utility", "0" , "0" },
	{ "npc_dota_hero_omniknight", "omniknight_repel", "utility", "0" , "0" },
	{ "npc_dota_hero_oracle", "oracle_fortunes_end", "disable", "target" , "0" },
	{ "npc_dota_hero_oracle", "oracle_false_promise", "utility", "0" , "0" },
	{ "npc_dota_hero_oracle", "oracle_fates_edict", "utility", "0" , "0" },
	{ "npc_dota_hero_oracle", "oracle_purifying_flames", "nuke", "target" , "damage" },
	{ "npc_dota_hero_phantom_assassin", "phantom_assassin_stifling_dagger", "nuke", "target" , "base_damage" },
	{ "npc_dota_hero_phantom_assassin", "phantom_assassin_blur", "utility", "0" , "0" },
	{ "npc_dota_hero_phantom_assassin", "phantom_assassin_coup_de_grace", "utility", "0" , "0" },
	{ "npc_dota_hero_phantom_assassin", "phantom_assassin_phantom_strike", "utility", "0" , "0" },
	{ "npc_dota_hero_phantom_lancer", "phantom_lancer_spirit_lance", "nuke", "target" , "lance_damage" },
	{ "npc_dota_hero_phantom_lancer", "phantom_lancer_doppelwalk", "utility", "0" , "0" },
	{ "npc_dota_hero_phantom_lancer", "phantom_lancer_juxtapose", "utility", "0" , "0" },
	{ "npc_dota_hero_phantom_lancer", "phantom_lancer_phantom_edge", "utility", "0" , "0" },
	{ "npc_dota_hero_phoenix", "phoenix_fire_spirits", "utility", "0" , "0" },
	{ "npc_dota_hero_phoenix", "phoenix_icarus_dive", "utility", "0" , "0" },
	{ "npc_dota_hero_phoenix", "phoenix_icarus_dive_stop", "utility", "0" , "0" },
	{ "npc_dota_hero_phoenix", "phoenix_launch_fire_spirit", "utility", "0" , "0" },
	{ "npc_dota_hero_phoenix", "phoenix_sun_ray", "utility", "0" , "0" },
	{ "npc_dota_hero_phoenix", "phoenix_sun_ray_stop", "utility", "0" , "0" },
	{ "npc_dota_hero_phoenix", "phoenix_sun_ray_toggle_move", "utility", "0" , "0" },
	{ "npc_dota_hero_phoenix", "phoenix_sun_ray_toggle_move_empty", "utility", "0" , "0" },
	{ "npc_dota_hero_phoenix", "phoenix_supernova", "utility", "0" , "0" },
	{ "npc_dota_hero_puck", "puck_dream_coil", "disable", "position" , "0" },
	{ "npc_dota_hero_puck", "puck_waning_rift", "disable", "no target" , "damage" },
	{ "npc_dota_hero_puck", "puck_ethereal_jaunt", "utility", "0" , "0" },
	{ "npc_dota_hero_puck", "puck_illusory_orb", "utility", "0" , "0" },
	{ "npc_dota_hero_puck", "puck_phase_shift", "utility", "0" , "0" },
	{ "npc_dota_hero_pudge", "pudge_dismember", "disable", "target" , "0" },
	{ "npc_dota_hero_pudge", "pudge_flesh_heap", "utility", "0" , "0" },
	{ "npc_dota_hero_pudge", "pudge_meat_hook", "utility", "0" , "0" },
	{ "npc_dota_hero_pudge", "pudge_rot", "utility", "0" , "0" },
	{ "npc_dota_hero_pugna", "pugna_nether_blast", "nuke", "skillshot" , "blast_damage" },
	{ "npc_dota_hero_pugna", "pugna_life_drain", "nuke", "target" , "0" },
	{ "npc_dota_hero_pugna", "pugna_decrepify", "utility", "0" , "0" },
	{ "npc_dota_hero_pugna", "pugna_nether_ward", "utility", "0" , "0" },
	{ "npc_dota_hero_queenofpain", "queenofpain_sonic_wave", "nuke", "position" , "damage" },
	{ "npc_dota_hero_queenofpain", "queenofpain_shadow_strike", "nuke", "target" , "strike_damage" },
	{ "npc_dota_hero_queenofpain", "queenofpain_scream_of_pain", "nuke", "special" , "0" },
	{ "npc_dota_hero_queenofpain", "queenofpain_blink", "utility", "0" , "0" },
	{ "npc_dota_hero_rattletrap", "rattletrap_battery_assault", "disable", "no target" , "0" },
	{ "npc_dota_hero_rattletrap", "rattletrap_hookshot", "disable", "position" , "0" },
	{ "npc_dota_hero_rattletrap", "rattletrap_rocket_flare", "nuke", "skillshot" , "0" },
	{ "npc_dota_hero_rattletrap", "rattletrap_power_cogs", "utility", "0" , "0" },
	{ "npc_dota_hero_razor", "razor_plasma_field", "nuke", "no target" , "damage_max" },
	{ "npc_dota_hero_razor", "razor_eye_of_the_storm", "nuke", "no target" , "0" },
	{ "npc_dota_hero_razor", "razor_static_link", "utility", "0" , "0" },
	{ "npc_dota_hero_razor", "razor_unstable_current", "utility", "0" , "0" },
	{ "npc_dota_hero_riki", "riki_smoke_screen", "disable", "position" , "0" },
	{ "npc_dota_hero_riki", "riki_blink_strike", "utility", "0" , "0" },
	{ "npc_dota_hero_riki", "riki_permanent_invisibility", "utility", "0" , "0" },
	{ "npc_dota_hero_riki", "riki_tricks_of_the_trade", "utility", "0" , "0" },
	{ "npc_dota_hero_rubick", "rubick_fade_bolt", "nuke", "target" , "damage" },
	{ "npc_dota_hero_rubick", "rubick_telekinesis", "disable", "target" , "0" },
	{ "npc_dota_hero_rubick", "rubick_telekinesis_land", "disable", "target" , "0" },
	{ "npc_dota_hero_rubick", "rubick_empty1", "utility", "0" , "0" },
	{ "npc_dota_hero_rubick", "rubick_empty2", "utility", "0" , "0" },
	{ "npc_dota_hero_rubick", "rubick_hidden1", "utility", "0" , "0" },
	{ "npc_dota_hero_rubick", "rubick_hidden2", "utility", "0" , "0" },
	{ "npc_dota_hero_rubick", "rubick_hidden3", "utility", "0" , "0" },
	{ "npc_dota_hero_rubick", "rubick_null_field", "utility", "0" , "0" },
	{ "npc_dota_hero_rubick", "rubick_spell_steal", "utility", "0" , "0" },
	{ "npc_dota_hero_sand_king", "sandking_burrowstrike", "disable", "position" , "0" },
	{ "npc_dota_hero_sand_king", "sandking_epicenter", "nuke", "no target" , "0" },
	{ "npc_dota_hero_sand_king", "sandking_caustic_finale", "utility", "0" , "0" },
	{ "npc_dota_hero_sand_king", "sandking_sand_storm", "utility", "0" , "0" },
	{ "npc_dota_hero_shadow_demon", "shadow_demon_demonic_purge", "utility", "0" , "0" },
	{ "npc_dota_hero_shadow_demon", "shadow_demon_disruption", "utility", "0" , "0" },
	{ "npc_dota_hero_shadow_demon", "shadow_demon_shadow_poison", "utility", "0" , "0" },
	{ "npc_dota_hero_shadow_demon", "shadow_demon_shadow_poison_release", "utility", "0" , "0" },
	{ "npc_dota_hero_shadow_demon", "shadow_demon_soul_catcher", "utility", "0" , "0" },
	{ "npc_dota_hero_shadow_shaman", "shadow_shaman_ether_shock", "nuke", "target" , "damage" },
	{ "npc_dota_hero_shadow_shaman", "shadow_shaman_shackles", "disable", "target" , "0" },
	{ "npc_dota_hero_shadow_shaman", "shadow_shaman_voodoo", "disable", "target" , "0" },
	{ "npc_dota_hero_shadow_shaman", "shadow_shaman_mass_serpent_ward", "utility", "0" , "0" },
	{ "npc_dota_hero_shredder", "shredder_whirling_death", "pure", "no target" , "whirling_damage" },
	{ "npc_dota_hero_shredder", "shredder_chakram", "nuke", "position" , "0" },
	{ "npc_dota_hero_shredder", "shredder_chakram_2", "nuke", "position" , "0" },
	{ "npc_dota_hero_shredder", "shredder_reactive_armor", "utility", "0" , "0" },
	{ "npc_dota_hero_shredder", "shredder_return_chakram", "utility", "0" , "0" },
	{ "npc_dota_hero_shredder", "shredder_return_chakram_2", "utility", "0" , "0" },
	{ "npc_dota_hero_shredder", "shredder_timber_chain", "utility", "0" , "0" },
	{ "npc_dota_hero_silencer", "silencer_last_word", "nuke", "target" , "damage" },
	{ "npc_dota_hero_silencer", "silencer_global_silence", "disable", "no target" , "0" },
	{ "npc_dota_hero_silencer", "silencer_curse_of_the_silent", "utility", "0" , "0" },
	{ "npc_dota_hero_silencer", "silencer_glaives_of_wisdom", "utility", "0" , "0" },
	{ "npc_dota_hero_skeleton_king", "skeleton_king_hellfire_blast", "disable", "target" , "0" },
	{ "npc_dota_hero_skeleton_king", "skeleton_king_reincarnation", "utility", "0" , "0" },
	{ "npc_dota_hero_skeleton_king", "skeleton_king_vampiric_aura", "utility", "0" , "0" },
	{ "npc_dota_hero_skywrath_mage", "skywrath_mage_arcane_bolt", "nuke", "target" , "bolt_damage" },
	{ "npc_dota_hero_skywrath_mage", "skywrath_mage_ancient_seal", "disable", "target" , "0" },
	{ "npc_dota_hero_skywrath_mage", "skywrath_mage_mystic_flare", "nuke", "position" , "0" },
	{ "npc_dota_hero_skywrath_mage", "skywrath_mage_concussive_shot", "nuke", "special" , "damage" },
	{ "npc_dota_hero_slardar", "slardar_slithereen_crush", "disable", "no target" , "0" },
	{ "npc_dota_hero_slardar", "slardar_amplify_damage", "utility", "0" , "0" },
	{ "npc_dota_hero_slardar", "slardar_bash", "utility", "0" , "0" },
	{ "npc_dota_hero_slardar", "slardar_sprint", "utility", "0" , "0" },
	{ "npc_dota_hero_slark", "slark_dark_pact", "nuke", "no target" , "total_damage" },
	{ "npc_dota_hero_slark", "slark_essence_shift", "utility", "0" , "0" },
	{ "npc_dota_hero_slark", "slark_pounce", "utility", "0" , "0" },
	{ "npc_dota_hero_slark", "slark_shadow_dance", "utility", "0" , "0" },
	{ "npc_dota_hero_sniper", "sniper_assassinate", "nuke", "target" , "0" },
	{ "npc_dota_hero_sniper", "sniper_headshot", "utility", "0" , "0" },
	{ "npc_dota_hero_sniper", "sniper_shrapnel", "utility", "0" , "0" },
	{ "npc_dota_hero_sniper", "sniper_take_aim", "utility", "0" , "0" },
	{ "npc_dota_hero_spectre", "spectre_spectral_dagger", "nuke", "target" , "damage" },
	{ "npc_dota_hero_spectre", "spectre_desolate", "utility", "0" , "0" },
	{ "npc_dota_hero_spectre", "spectre_dispersion", "utility", "0" , "0" },
	{ "npc_dota_hero_spectre", "spectre_haunt", "utility", "0" , "0" },
	{ "npc_dota_hero_spectre", "spectre_reality", "utility", "0" , "0" },
	{ "npc_dota_hero_spirit_breaker", "spirit_breaker_nether_strike", "nuke", "target" , "0" },
	{ "npc_dota_hero_spirit_breaker", "spirit_breaker_charge_of_darkness", "utility", "0" , "0" },
	{ "npc_dota_hero_spirit_breaker", "spirit_breaker_empowering_haste", "utility", "0" , "0" },
	{ "npc_dota_hero_spirit_breaker", "spirit_breaker_greater_bash", "utility", "0" , "0" },
	{ "npc_dota_hero_storm_spirit", "storm_spirit_electric_vortex", "disable", "target" , "0" },
	{ "npc_dota_hero_storm_spirit", "storm_spirit_ball_lightning", "utility", "0" , "0" },
	{ "npc_dota_hero_storm_spirit", "storm_spirit_overload", "utility", "0" , "0" },
	{ "npc_dota_hero_storm_spirit", "storm_spirit_static_remnant", "utility", "0" , "0" },
	{ "npc_dota_hero_sven", "sven_storm_bolt", "disable", "target" , "0" },
	{ "npc_dota_hero_sven", "sven_gods_strength", "utility", "0" , "0" },
	{ "npc_dota_hero_sven", "sven_great_cleave", "utility", "0" , "0" },
	{ "npc_dota_hero_sven", "sven_warcry", "utility", "0" , "0" },
	{ "npc_dota_hero_techies", "techies_land_mines", "utility", "0" , "0" },
	{ "npc_dota_hero_techies", "techies_stasis_trap", "utility", "0" , "0" },
	{ "npc_dota_hero_techies", "techies_suicide", "utility", "0" , "0" },
	{ "npc_dota_hero_techies", "techies_remote_mines", "utility", "0" , "0" },
	{ "npc_dota_hero_techies", "techies_focused_detonate", "utility", "0" , "0" },
	{ "npc_dota_hero_techies", "techies_remote_mines_self_detonate", "utility", "0" , "0" },
	{ "npc_dota_hero_techies", "techies_minefield_sign", "utility", "0" , "0" },
	{ "npc_dota_hero_templar_assassin", "templar_assassin_meld", "utility", "0" , "0" },
	{ "npc_dota_hero_templar_assassin", "templar_assassin_psi_blades", "utility", "0" , "0" },
	{ "npc_dota_hero_templar_assassin", "templar_assassin_psionic_trap", "utility", "0" , "0" },
	{ "npc_dota_hero_templar_assassin", "templar_assassin_refraction", "utility", "0" , "0" },
	{ "npc_dota_hero_templar_assassin", "templar_assassin_self_trap", "utility", "0" , "0" },
	{ "npc_dota_hero_templar_assassin", "templar_assassin_trap", "utility", "0" , "0" },
	{ "npc_dota_hero_terrorblade", "terrorblade_conjure_image", "utility", "0" , "0" },
	{ "npc_dota_hero_terrorblade", "terrorblade_metamorphosis", "utility", "0" , "0" },
	{ "npc_dota_hero_terrorblade", "terrorblade_reflection", "utility", "0" , "0" },
	{ "npc_dota_hero_terrorblade", "terrorblade_sunder", "utility", "0" , "0" },
	{ "npc_dota_hero_tidehunter", "tidehunter_ravage", "disable", "no target" , "0" },
	{ "npc_dota_hero_tidehunter", "tidehunter_anchor_smash", "nuke", "no target" , "0" },
	{ "npc_dota_hero_tidehunter", "tidehunter_gush", "nuke", "target" , "gush_damage" },
	{ "npc_dota_hero_tidehunter", "tidehunter_kraken_shell", "utility", "0" , "0" },
	{ "npc_dota_hero_tinker", "tinker_laser", "pure", "target" , "laser_damage" },
	{ "npc_dota_hero_tinker", "tinker_heat_seeking_missile", "nuke", "no target" , "damage" },
	{ "npc_dota_hero_tinker", "tinker_march_of_the_machines", "utility", "0" , "0" },
	{ "npc_dota_hero_tinker", "tinker_rearm", "utility", "0" , "0" },
	{ "npc_dota_hero_tiny", "tiny_toss", "nuke", "position" , "toss_damage" },
	{ "npc_dota_hero_tiny", "tiny_avalanche", "disable", "position" , "avalanche_damage" },
	{ "npc_dota_hero_tiny", "tiny_craggy_exterior", "utility", "0" , "0" },
	{ "npc_dota_hero_tiny", "tiny_grow", "utility", "0" , "0" },
	{ "npc_dota_hero_treant", "treant_overgrowth", "disable", "no target" , "0" },
	{ "npc_dota_hero_treant", "treant_eyes_in_the_forest", "utility", "0" , "0" },
	{ "npc_dota_hero_treant", "treant_leech_seed", "utility", "0" , "0" },
	{ "npc_dota_hero_treant", "treant_living_armor", "utility", "0" , "0" },
	{ "npc_dota_hero_treant", "treant_natures_guise", "utility", "0" , "0" },
	{ "npc_dota_hero_troll_warlord", "troll_warlord_battle_trance", "utility", "0" , "0" },
	{ "npc_dota_hero_troll_warlord", "troll_warlord_berserkers_rage", "utility", "0" , "0" },
	{ "npc_dota_hero_troll_warlord", "troll_warlord_fervor", "utility", "0" , "0" },
	{ "npc_dota_hero_troll_warlord", "troll_warlord_whirling_axes_melee", "utility", "0" , "0" },
	{ "npc_dota_hero_troll_warlord", "troll_warlord_whirling_axes_ranged", "utility", "0" , "0" },
	{ "npc_dota_hero_tusk", "tusk_ice_shards", "nuke", "skillshot" , "shard_damage" },
	{ "npc_dota_hero_tusk", "tusk_walrus_kick", "nuke", "target" , "0" },
	{ "npc_dota_hero_tusk", "tusk_walrus_punch", "nuke", "target" , "0" },
	{ "npc_dota_hero_tusk", "tusk_frozen_sigil", "utility", "0" , "0" },
	{ "npc_dota_hero_tusk", "tusk_launch_snowball", "utility", "0" , "0" },
	{ "npc_dota_hero_tusk", "tusk_snowball", "utility", "0" , "0" },
	{ "npc_dota_hero_undying", "undying_decay", "nuke", "position" , "decay_damage" },
	{ "npc_dota_hero_undying", "undying_flesh_golem", "utility", "0" , "0" },
	{ "npc_dota_hero_undying", "undying_soul_rip", "utility", "0" , "0" },
	{ "npc_dota_hero_undying", "undying_tombstone", "utility", "0" , "0" },
	{ "npc_dota_hero_undying", "undying_tombstone_zombie_aura", "utility", "0" , "0" },
	{ "npc_dota_hero_undying", "undying_tombstone_zombie_deathstrike", "utility", "0" , "0" },
	{ "npc_dota_hero_ursa", "ursa_earthshock", "nuke", "no target" , "0" },
	{ "npc_dota_hero_ursa", "ursa_enrage", "utility", "0" , "0" },
	{ "npc_dota_hero_ursa", "ursa_fury_swipes", "utility", "0" , "0" },
	{ "npc_dota_hero_ursa", "ursa_overpower", "utility", "0" , "0" },
	{ "npc_dota_hero_vengefulspirit", "vengefulspirit_magic_missile", "disable", "target" , "magic_missile_damage" },
	{ "npc_dota_hero_vengefulspirit", "vengefulspirit_wave_of_terror", "nuke", "skillshot" , "0" },
	{ "npc_dota_hero_vengefulspirit", "vengefulspirit_command_aura", "utility", "0" , "0" },
	{ "npc_dota_hero_vengefulspirit", "vengefulspirit_nether_swap", "utility", "0" , "0" },
	{ "npc_dota_hero_venomancer", "venomancer_plague_ward", "utility", "0" , "0" },
	{ "npc_dota_hero_venomancer", "venomancer_poison_nova", "utility", "0" , "0" },
	{ "npc_dota_hero_venomancer", "venomancer_poison_sting", "utility", "0" , "0" },
	{ "npc_dota_hero_venomancer", "venomancer_venomous_gale", "utility", "0" , "0" },
	{ "npc_dota_hero_viper", "viper_viper_strike", "nuke", "target" , "0" },
	{ "npc_dota_hero_viper", "viper_corrosive_skin", "utility", "0" , "0" },
	{ "npc_dota_hero_viper", "viper_nethertoxin", "utility", "0" , "0" },
	{ "npc_dota_hero_viper", "viper_poison_attack", "utility", "0" , "0" },
	{ "npc_dota_hero_visage", "visage_soul_assumption", "utilit<", "0" , "0" },
	{ "npc_dota_hero_visage", "visage_grave_chill", "utility", "0" , "0" },
	{ "npc_dota_hero_visage", "visage_gravekeepers_cloak", "utility", "0" , "0" },
	{ "npc_dota_hero_visage", "visage_summon_familiars", "utility", "0" , "0" },
	{ "npc_dota_hero_visage", "visage_summon_familiars_stone_form", "utility", "0" , "0" },
	{ "npc_dota_hero_warlock", "warlock_rain_of_chaos", "disable", "position" , "0" },
	{ "npc_dota_hero_warlock", "warlock_shadow_word", "nuke", "target" , "0" },
	{ "npc_dota_hero_warlock", "warlock_fatal_bonds", "utility", "0" , "0" },
	{ "npc_dota_hero_warlock", "warlock_golem_flaming_fists", "utility", "0" , "0" },
	{ "npc_dota_hero_warlock", "warlock_golem_permanent_immolation", "utility", "0" , "0" },
	{ "npc_dota_hero_warlock", "warlock_upheaval", "utility", "0" , "0" },
	{ "npc_dota_hero_weaver", "weaver_geminate_attack", "utility", "0" , "0" },
	{ "npc_dota_hero_weaver", "weaver_shukuchi", "utility", "0" , "0" },
	{ "npc_dota_hero_weaver", "weaver_the_swarm", "utility", "0" , "0" },
	{ "npc_dota_hero_weaver", "weaver_time_lapse", "utility", "0" , "0" },
	{ "npc_dota_hero_windrunner", "windrunner_shackleshot", "disable", "target" , "0" },
	{ "npc_dota_hero_windrunner", "windrunner_powershot", "nuke", "skillshot" , "powershot_damage" },
	{ "npc_dota_hero_windrunner", "windrunner_focusfire", "utility", "0" , "0" },
	{ "npc_dota_hero_windrunner", "windrunner_windrun", "utility", "0" , "0" },
	{ "npc_dota_hero_winter_wyvern", "winter_wyvern_winters_curse", "disable", "target" , "0" },
	{ "npc_dota_hero_winter_wyvern", "winter_wyvern_splinter_blast", "nuke", "special" , "0" },
	{ "npc_dota_hero_winter_wyvern", "winter_wyvern_arctic_burn", "utility", "0" , "0" },
	{ "npc_dota_hero_winter_wyvern", "winter_wyvern_cold_embrace", "utility", "0" , "0" },
	{ "npc_dota_hero_wisp", "wisp_empty1", "utility", "0" , "0" },
	{ "npc_dota_hero_wisp", "wisp_empty2", "utility", "0" , "0" },
	{ "npc_dota_hero_wisp", "wisp_overcharge", "utility", "0" , "0" },
	{ "npc_dota_hero_wisp", "wisp_relocate", "utility", "0" , "0" },
	{ "npc_dota_hero_wisp", "wisp_spirits", "utility", "0" , "0" },
	{ "npc_dota_hero_wisp", "wisp_spirits_in", "utility", "0" , "0" },
	{ "npc_dota_hero_wisp", "wisp_spirits_out", "utility", "0" , "0" },
	{ "npc_dota_hero_wisp", "wisp_tether", "utility", "0" , "0" },
	{ "npc_dota_hero_wisp", "wisp_tether_break", "utility", "0" , "0" },
	{ "npc_dota_hero_witch_doctor", "witch_doctor_paralyzing_cask", "disable", "target" , "0" },
	{ "npc_dota_hero_witch_doctor", "witch_doctor_death_ward", "utility", "0" , "0" },
	{ "npc_dota_hero_witch_doctor", "witch_doctor_maledict", "utility", "0" , "0" },
	{ "npc_dota_hero_witch_doctor", "witch_doctor_voodoo_restoration", "utility", "0" , "0" },
	{ "npc_dota_hero_zuus", "zuus_arc_lightning", "nuke", "target" , "arc_damage" },
	{ "npc_dota_hero_zuus", "zuus_lightning_bolt", "nuke", "skillshot" , "0" },
	{ "npc_dota_hero_zuus", "zuus_thundergods_wrath", "nuke", "no target" , "damage" },
	{ "npc_dota_hero_zuus", "zuus_cloud", "utility", "0" , "0" },
	{ "npc_dota_hero_zuus", "zuus_static_field", "utility", "0" , "0" },
	{ "npc_dota_hero_dark_willow", "dark_willow_bramble_maze", "utility", "0" , "0" },
	{ "npc_dota_hero_dark_willow", "dark_willow_shadow_realm", "utility", "0" , "0" },
	{ "npc_dota_hero_dark_willow", "dark_willow_cursed_crown", "utility", "0" , "0" },
	{ "npc_dota_hero_dark_willow", "dark_willow_bedlam", "utility", "0" , "0" },
	{ "npc_dota_hero_dark_willow", "dark_willow_terrorize", "utility", "0" , "0" },
	{ "npc_dota_hero_pangolier", "pangolier_swashbuckle", "nuke", "special", "damage" },
	{ "npc_dota_hero_pangolier", "pangolier_shield_crash", "utility", "0" , "0" },
	{ "npc_dota_hero_pangolier", "pangolier_heartpiercer", "utility", "0" , "0" },
	{ "npc_dota_hero_pangolier", "pangolier_gyroshell", "utility", "0" , "0" } }

FAIO.armletDotTickTable = {
	modifier_queenofpain_shadow_strike = 3,
	modifier_crystal_maiden_frostbite = 0.5,
	modifier_alchemist_acid_spray = 1,
	modifier_cold_feet =  1,
	modifier_arc_warden_flux = 0.5,
	modifier_axe_battle_hunger = 1,
	modifier_flamebreak_damage = 1,
	modifier_dazzle_poison_touch = 1,
	modifier_disruptor_thunder_strike = 2,
	modifier_doom_bringer_infernal_blade_burn = 1,
	modifier_dragon_knight_corrosive_breath_dot = 1,
	modifier_earth_spirit_magnetize = 0.5,
	modifier_ember_spirit_searing_chains = 1,
	modifier_enigma_malefice = 2,
	modifier_invoker_ice_wall_slow_debuff = 1,
	modifier_invoker_chaos_meteor_burn = 0.5,
	modifier_huskar_burning_spear_debuff = 1,
	modifier_jakiro_dual_breath_burn = 0.5,
	modifier_jakiro_liquid_fire_burn = 0.5,
	modifier_meepo_geostrike_debuff = 1,
	modifier_ogre_magi_ignite = 1,
	modifier_phoenix_icarus_dive_burn = 1,
	modifier_phoenix_fire_spirit_burn = 1,
	modifier_phoenix_sun_debuff = 1,
	modifier_silencer_curse_of_the_silent = 1,
	modifier_silencer_last_word = 4,
	modifier_sniper_shrapnel_slow = 1,
	modifier_shredder_chakram_debuff = 0.5,
	modifier_treant_leech_seed = 0.75,
	modifier_abyssal_underlord_firestorm_burn = 1,
	modifier_venomancer_venomous_gale = 3,
	modifier_venomancer_poison_sting = 1,
	modifier_venomancer_poison_nova = 1,
	modifier_venomancer_poison_sting_ward = 1,
	modifier_viper_poison_attack_slow = 1,
	modifier_viper_viper_strike_slow = 1,
	modifier_warlock_shadow_word = 1,
	modifier_weaver_swarm_debuff = 0.8,
	modifier_winter_wyvern_arctic_burn_slow = 1,
	modifier_maledict = 1,
	modifier_skeleton_king_hellfire_blast = 1,
	modifier_item_orb_of_venom_slow = 1,
	modifier_item_radiance_debuff = 1,
	modifier_item_urn_damage = 1,
	modifier_item_spirit_vessel_damage = 1,
	modifier_spawnlord_master_freeze_root = 0.5,
	modifier_broodmother_poison_sting_debuff = 1,
	modifier_gnoll_assassin_envenomed_weapon_poison = 1,
	modifier_warlock_golem_permanent_immolation_debuff =  1,
	modifier_necrolyte_heartstopper_aura_effect = 0.2,
	modifier_death_prophet_spirit_siphon_slow = 0.25,
	modifier_disruptor_static_storm = 0.25,
	modifier_pugna_life_drain = 0.25,
	modifier_skywrath_mystic_flare_aura_effect = 0.1,
	modifier_tornado_tempest_debuff = 0.25,
	modifier_pudge_rot = 0.2
		}

FAIO.armletDotTickTableAOE = {
	modifier_doom_bringer_scorched_earth_effect = { 625, 1 },
	modifier_rattletrap_battery_assault = { 300, 0.7 },
	modifier_leshrac_pulse_nova = { 475, 1 },
	modifier_sandking_sand_storm = { 550, 0.5 },
	modifier_dark_seer_ion_shell = { 275, 0.1 },
	modifier_ember_spirit_flame_guard = { 425, 0.2 },
	modifier_juggernaut_blade_fury = { 275, 0.2 },
	modifier_leshrac_diabolic_edict = { 525, 0.25 },
	modifier_phoenix_sun_ray = { 1325, 0.2 },
	modifier_slark_dark_pact = { 350, 1.5 },
	modifier_slark_dark_pact_pulses = { 350, 0.1 },
	modifier_gyrocopter_rocket_barrage = { 425, 0.1 }
		}

FAIO.RawDamageAbilityEstimation = {
	zuus_thundergods_wrath = { "no target", 0, 99999, 150, 0, 0 },
	puck_waning_rift = { "no target", 0, 400, 75, 0, 0 },
	ogre_magi_fireblast = { "target", 0, 0, 75, 0, 0 },
	obsidian_destroyer_astral_imprisonment = { "target", 0, 0, 75, 0, 0 },
	obsidian_destroyer_sanity_eclipse = { "position", 700, 575, 250, 0, 0 },
	necrolyte_reapers_scythe = { "target", 0, 0, 250, 0, 0 },
	magnataur_reverse_polarity = { "no target", 0, 410, 200, 0, 0 },
	lion_finger_of_death = { "target", 0, 0, 250, 0, 0 },
	lina_laguna_blade = { "target", 0, 0, 300, 0, 0 },
	legion_commander_duel = { "target", 0, 0, 250, 0, 0 },
	earthshaker_fissure = { "position", 0, 225, 75, 0, 0 },
	doom_bringer_doom = { "target", 0, 0, 150, 0, 0 },
	centaur_hoof_stomp = { "no target", 0, 315, 75, 0, 0 },
	bloodseeker_rupture = { "target", 0, 0, 150, 0, 0 },
	antimage_mana_void = { "position", 600, 500, 250, 0, 0 },
	queenofpain_sonic_wave = { "position", 0, 450, 170, 900, 0 },
	pudge_dismember = { "target", 0, 0, 75, 0, 0 },
	slardar_slithereen_crush = { "no target", 0, 350, 75, 0, 0 },
	bane_brain_sap = { "target", 0, 0, 75, 0, 0 },
	bane_fiends_grip = { "target", 0, 0, 500, 0, 0 },
	beastmaster_wild_axes = { "position", 0, 250, 75, 1200, 0 },
	bloodseeker_blood_bath = { "position", 0, 600, 60, 0, 2.6 },
	brewmaster_thunder_clap = { "no target", 0, 400, 75, 0, 0 },
	centaur_double_edge = { "target", 190, 0, 100, 0, 0 },
	chen_test_of_faith = { "target", 0, 0, 75, 0, 0 },
	crystal_maiden_crystal_nova = { "position", 0, 425, 75, 0, 0 },
	dragon_knight_breathe_fire = { "position", 0, 250, 75, 1050, 0 },
	gyrocopter_call_down = { "position", 0, 600, 150, 0, 2 },
	kunkka_torrent = { "position", 0, 225, 75, 0, 1.6 },
	zuus_lightning_bolt = { "position", 0, 325, 75, 0, 0 },
	legion_commander_overwhelming_odds = { "position", 0, 330, 75, 0, 0 },
	beastmaster_primal_roar = { "no target", 950, 300, 100, 0, 0 },
	bristleback_quill_spray = { "no target", 0, 700, 30, 2400, 0 },
	crystal_maiden_freezing_field = { "no target", 0, 835, 150, 0, 0 },
	dazzle_poison_touch = { "target", 0, 0, 50, 0, 0 },
	death_prophet_carrion_swarm = { "position", 0, 300, 75, 1100, 0 },
	earth_spirit_boulder_smash = { "target", 0, 0, 50, 0, 0 },	
	invoker_tornado = { "position", 0, 200, 300, 1000, 0 },
	invoker_chaos_meteor = { "position", 0, 275, 400, 0, 1.3 },
	invoker_deafening_blast = { "position", 0, 225, 300, 1100, 0 },
	invoker_emp = { "position", 0, 675, 300, 0, 2.9 },	
	jakiro_macropyre = { "position", 0, 260, 125, 0, 0 },
	juggernaut_omni_slash = { "target", 0, 0, 200, 0, 0 },
	kunkka_ghostship = { "position", 0, 425, 125, 650, 2.7 },	
	leshrac_split_earth = { "position", 0, 225, 75, 0, 0.35 },
	leshrac_lightning_storm = { "target", 0, 0, 50, 0, 0 },
	lich_frost_nova = { "position", 0, 200, 50, 0, 0 },
	lina_light_strike_array = { "position", 0, 225, 60, 0, 0.5 },
	lina_dragon_slave = { "position", 0, 275, 75, 1200, 0 },
	luna_lucent_beam = { "target", 0, 0, 75, 0, 0 },
	luna_eclipse = { "no target", 0, 675, 150, 0, 0 },	
	magnataur_shockwave = { "position", 0, 150, 75, 1050, 0 },
	meepo_poof = { "no target", 0, 375, 75, 0, 0 },
	monkey_king_boundless_strike = { "position", 0, 150, 100, 0, 0 },
	morphling_waveform = { "position", 0, 200, 75, 1250, 0 },	
	naga_siren_rip_tide = { "no target", 0, 320, 75, 0, 0 },
	nevermore_shadowraze1 = { "position", 200, 250, 75, 0, 0 },
	nevermore_shadowraze2 = { "position", 450, 250, 75, 0, 0 },
	nevermore_shadowraze3 = { "position", 700, 250, 75, 0, 0 },
	night_stalker_void = { "target", 0, 0, 75, 0, 0 },
	nyx_assassin_mana_burn = { "target", 0, 0, 75, 0, 0 },
	ogre_magi_unrefined_fireblast = { "target", 0, 0, 75, 0, 0 },
	omniknight_purification = { "position", 575, 260, 100, 0, 0 },
	oracle_purifying_flames = { "target", 0, 0, 75, 0, 0 },
	puck_dream_coil = { "position", 0, 375, 150, 0, 0 },
	pudge_meat_hook = { "position", 0, 100, 100, 1450, 0 },
	pugna_nether_blast = { "position", 0, 400, 75, 0, 0.9 },
	razor_plasma_field = { "no target", 0, 700, 80, 636, 0 },
	razor_eye_of_the_storm = { "no target", 0, 500, 100, 0, 0 },
	rubick_fade_bolt = { "target", 0, 0, 75, 0, 0 },
	rubick_telekinesis = { "target", 0, 0, 75, 0, 0 },
	sandking_burrowstrike = { "position", 0, 150, 75, 2000, 0 },
	sandking_epicenter = { "no target", 0, 525, 200, 0, 0 },
	shadow_demon_demonic_purge = { "target", 0, 0, 125, 0, 0 },
	shadow_shaman_ether_shock = { "target", 0, 0, 75, 0, 0 },
	shredder_whirling_death = { "no target", 0, 300, 75, 0, 0 },
	shredder_chakram = { "position", 0, 200, 100, 900, 0 },
	shredder_chakram_2 = { "position", 0, 200, 100, 900, 0 },
	slark_pounce = { "position", 700, 95, 60, 933.33, 0 },
	spirit_breaker_nether_strike = { "target", 0, 0, 125, 0, 1 },
	storm_spirit_static_remnant = { "no target", 0, 235, 75, 0, 0 },
	techies_suicide = { "target", 0, 0, 300 },	
	tidehunter_anchor_smash = { "no target", 0, 375, 75, 0, 0 },
	tinker_laser = { "target", 0, 0, 75, 0, 0 },
	tiny_avalanche = { "position", 0, 275, 75, 0, 0 },
	troll_warlord_whirling_axes_melee = { "no target", 0, 450, 75, 0, 0 },
	troll_warlord_whirling_axes_ranged = { "position", 0, 100, 45, 1500, 0 },
	tusk_ice_shards = { "position", 0, 200, 75, 1200, 0 },
	tusk_walrus_punch = { "target", 0, 0, 200, 0, 0 },
	undying_decay = { "position", 0, 325, 75, 0, 0 },
	ursa_earthshock = { "no target", 0, 385, 75, 0, 0 },
	vengefulspirit_wave_of_terror = { "position", 0, 300, 40, 2000, 0 },
	windrunner_powershot = { "position", 0, 125, 175, 3000, 0 },
	witch_doctor_death_ward = { "target", 0, 0, 200, 0, 0 },	
	zuus_arc_lightning = { "target", 0, 0, 35, 0, 0 },
	dark_willow_bedlam = { "no target", 0, 300, 175, 0, 0 },
	pangolier_shield_crash = { "no target", 0, 500, 75, 0, 0 },
	axe_berserkers_call = { "no target", 0, 400, 100, 0, 0 },
	batrider_flaming_lasso = { "target", 0, 0, 150, 0, 0 },
	crystal_maiden_frostbite = { "target", 0, 0, 100, 0, 0 },
	earthshaker_enchant_totem = { "no target", 0, 300, 100, 0, 0 },
	enigma_black_hole = { "position", 275, 420, 175, 0, 0 },
	faceless_void_chronosphere = { "position", 600, 600, 175, 0, 0 },
	sandking_burrowstrike = { "position", 0, 150, 100, 2000, 0 },
	shadow_shaman_shackles = { "target", 0, 0, 150, 0, 0 },
	storm_spirit_electric_vortex = { "target", 0, 0, 100, 0, 0 },
	warlock_rain_of_chaos = { "position", 0, 600, 150, 0, 0 },
	tidehunter_ravage = { "no target", 0, 1250, 150, 725, 0 },
	tidehunter_gush = { "target", 0, 0, 75, 2500, 0 }
		}

FAIO.NeutralListComplete = {
	"npc_dota_neutral_alpha_wolf",
	"npc_dota_neutral_centaur_khan",
	"npc_dota_neutral_centaur_outrunner",
	"npc_dota_neutral_dark_troll_warlord",
	"npc_dota_neutral_fel_beast",
	"npc_dota_neutral_ghost",
	"npc_dota_neutral_giant_wolf",
	"npc_dota_neutral_harpy_scout",
	"npc_dota_neutral_harpy_storm",
	"npc_dota_neutral_polar_furbolg_champion",
	"npc_dota_neutral_polar_furbolg_ursa_warrior",
	"npc_dota_neutral_dark_troll",
	"npc_dota_neutral_forest_troll_berserker",
	"npc_dota_neutral_forest_troll_high_priest",
	"npc_dota_neutral_kobold",
	"npc_dota_neutral_kobold_tunneler",
	"npc_dota_neutral_kobold_taskmaster",
	"npc_dota_neutral_mud_golem",
	"npc_dota_neutral_ogre_mauler",
	"npc_dota_neutral_ogre_magi",
	"npc_dota_neutral_satyr_trickster",
	"npc_dota_neutral_satyr_soulstealer",
	"npc_dota_neutral_satyr_hellcaller",
	"npc_dota_neutral_gnoll_assassin",
	"npc_dota_neutral_wildkin",
	"npc_dota_neutral_enraged_wildkin"
		}

FAIO.NeutralMainNPCsmall = {
	"npc_dota_neutral_kobold_taskmaster",
	"npc_dota_neutral_forest_troll_berserker",
	"npc_dota_neutral_gnoll_assassin",
	"npc_dota_neutral_ghost",
	"npc_dota_neutral_harpy_storm"
		}

FAIO.NeutralMainNPCmedium = {
	"npc_dota_neutral_centaur_khan",
	"npc_dota_neutral_alpha_wolf",
	"npc_dota_neutral_satyr_soulstealer",
	"npc_dota_neutral_ogre_mauler",
	"npc_dota_neutral_mud_golem"
		}

FAIO.NeutralMainNPChard = {
	"npc_dota_neutral_centaur_khan",
	"npc_dota_neutral_satyr_hellcaller",
	"npc_dota_neutral_polar_furbolg_ursa_warrior",
	"npc_dota_neutral_enraged_wildkin",
	"npc_dota_neutral_dark_troll_warlord"
		}

FAIO.preemptiveBKB = {}
for i = 1, #FAIO.preemptiveBKBtable do
	FAIO.preemptiveBKB[i] = Menu.AddOptionBool(OverallPath[115], FAIO.preemptiveBKBtable[i], false)
end

FAIO.dodgeItOptionTable = {}
for i = 1, #FAIO.dodgeItItems do
	FAIO.dodgeItOptionTable[i] = Menu.AddOptionSlider(OverallPath[116], i .. ". " .. FAIO.dodgeItItems[i][1].." ".."{{dodger}}", 0, #FAIO.dodgeItItems, 1)
end


FAIO.dodgeEnemySkillsOptionsTable = {}
for i = 1, 20 do
	FAIO.dodgeEnemySkillsOptionsTable[FAIO.dodgeEnemySkillsTable[i]] = Menu.AddOptionBool(OverallPath[117], FAIO.dodgeEnemySkillsTable[i].." ".."{{dodger}}", false)
end
for i = 21, 40 do
	FAIO.dodgeEnemySkillsOptionsTable[FAIO.dodgeEnemySkillsTable[i]] = Menu.AddOptionBool(OverallPath[118], FAIO.dodgeEnemySkillsTable[i].." ".."{{dodger}}", false)
end
for i = 41, #FAIO.dodgeEnemySkillsTable do
	FAIO.dodgeEnemySkillsOptionsTable[FAIO.dodgeEnemySkillsTable[i]] = Menu.AddOptionBool(OverallPath[119], FAIO.dodgeEnemySkillsTable[i].." ".."{{dodger}}", false)
end

FAIO.dodgeEnemyHeroskillsOptionsTable = {}
for i = 1, #FAIO.dodgeItSkills do
	FAIO.dodgeEnemyHeroskillsOptionsTable[FAIO.dodgeItSkills[i][1]] = Menu.AddOptionBool(OverallPath[120], FAIO.dodgeItSkills[i][1].." ".."{{dodger}}", false)
end

FAIO.dodgeEnemyHeroSpecialEmber = Menu.AddOptionBool(OverallPath[120], "ember_spirit_remnant {{dodger}}", false)

function FAIO.ResetGlobalVariables()
	CurentHero = nil
	FAIO.LockedTarget = nil
	FAIO.myUnitName = nil
	FAIO.lastCastTime = 0
	FAIO.lastCastTime2 = 0
	FAIO.lastCastTime3 = 0
	FAIO.lastTick = 0
	FAIO.delay = 0
	FAIO.itemDelay = 0
	FAIO.lastItemCast = 0
	FAIO.lastDefItemPop = 0
	FAIO.lastItemTick = 0
	FAIO.ItemCastStop = false
	FAIO.isArmletManuallyToggled = false
	FAIO.isArmletManuallyToggledTime = 0
	FAIO.armletDelayer = 0
	FAIO.ControlledUnitCastTime = 0
	FAIO.ControlledUnitPauseTime = 0
	FAIO.lastAttackTime = 0
	FAIO.lastAttackTime2 = 0
	FAIO.LastTarget = nil
	FAIO.LastTickManta1 = 0
	FAIO.LastTickManta2 = 0
	FAIO.ArcWardenEntity = nil
	FAIO.ArcWardenEntityAnimationStart = 0
	FAIO.ArcWardenEntityAnimationEnd = 0
	FAIO.arcWardenPanelX = 0
	FAIO.arcWardenPanelY = 0
	FAIO.ArcTempestLockedTarget = nil
	FAIO.ArcTempestLockedTargetParticle = 0
	FAIO.ArcTempestLockedTargetParticleHero = nil
	FAIO.arcWardenMagneticCastTime = 0
	FAIO.arcWardenPushMode = false
	FAIO.arcWardenPusher = false
	FAIO.arcWardenPushModeLine = false
	FAIO.arcWardenStatus = 0
	FAIO.ArcTempestLockedTargetPos = Vector()
	FAIO.ArcTempestLockedTargetPosTimer = 0
	FAIO.TempestInAttackBackswing = false
	FAIO.TempestOrbwalkerDelay = 0
	FAIO.ArcWardenEntityProjectileCreate = 0
	FAIO.GenericUpValue = false
	FAIO.lastPosition = Vector(0, 0, 0)
	FAIO.PuckOrbCastTime = 0
	FAIO.Toggler = false
	FAIO.TogglerTime = 0
	FAIO.PreInvoke = false
	FAIO.InvokerComboSelector = 0
	FAIO.InvokerLastCastedSkill = nil
	FAIO.InvokerLastCastedSkillTime = 0
	FAIO.InvokerLastChangedInstance = 0
	FAIO.InvokerCaptureManualInstances = 0
	FAIO.invokerChannellingKillstealTimer = 0
	FAIO.invokerCaptureGhostwalkActivation = 0
	FAIO.getInvokerGhostWalkKey = nil
	FAIO.invokerDisplayNeedsInit = true
	FAIO.getInvokerSettings = nil
	FAIO.InvokerCanComboStart = false
	FAIO.AttackProjectileCreate = 0
	FAIO.AttackAnimationCreate = 0
	FAIO.AttackParticleCreate = 0
	FAIO.InAttackBackswing = false
	FAIO.OrbwalkerDelay = 0
	FAIO.TPParticleIndex = nil
	FAIO.TPParticleTime = 0
	FAIO.TPParticleUnit = nil
	FAIO.TPParticlePosition = Vector()
	FAIO.GlimpseParticleIndex = nil
	FAIO.GlimpseParticleTime = 0
	FAIO.GlimpseParticleUnit = nil
	FAIO.GlimpseParticlePosition = Vector()
	FAIO.GlimpseParticleIndexStart = nil
	FAIO.GlimpseParticlePositionStart = Vector()
	FAIO.particleNextTime = 0
	FAIO.currentParticle = 0
	FAIO.currentParticleTarget = nil
	FAIO.skywrathDMGwithoutUlt = 0
	FAIO.skywrathDMGwithUlt = 0
	FAIO.skywrathComboSelect = false
	FAIO.clockwerkHookUpValue = false
	FAIO.enemyCanBeShackled = false
	FAIO.dodgeTiming = 0
	FAIO.dodgerProjectileAdjustmentTick = 0
	FAIO.saverTiming = 0
	FAIO.VisageInstStunLockTarget = nil
	FAIO.VisagePanicTarget = nil
	FAIO.morphlingComboSelect = false
	FAIO.morphlingTotalDMG = 0
	FAIO.morphlingTotalDMGwoWave = 0
	FAIO.MorphBalanceTimer = 0
	FAIO.MorphBalanceSelectedHP = 0
	FAIO.MorphBalanceSelected = 0
	FAIO.MorphBalanceToggler = true
	FAIO.wardCaptureTiming = 0
	FAIO.sentryImageHandle = nil
	FAIO.obsImageHandle = nil
	FAIO.wardDrawingRemove = 0
	FAIO.necroDMGwithoutUlt = 0
	FAIO.necroDMGwithUlt = 0
	FAIO.necroComboSelect = false
	FAIO.magnusLastPos = Vector()
	FAIO.SFcurrentParticle1 = 0
	FAIO.SFcurrentParticle2 = 0
	FAIO.SFcurrentParticle3 = 0
	FAIO.SFParticleUpdateTime = 0
	FAIO.armletRightClickToggle = false
	FAIO.armletRightClickToggleTimer = 0
	FAIO.armletRightClickDoubleClick = 0
	FAIO.isArmletActive = false
	FAIO.armletCurrentHPGain = 0
	FAIO.armletToggleTime = 0
	FAIO.armletToggleTimePingAdjuster = 0
	FAIO.armletProjectileAdjustmentTick = 0
	FAIO.armletDamageInstanceTable = {}
	FAIO.lastHitterDelay = 0
	FAIO.lastHitterOrbSkill = nil
	FAIO.lastHitterOrbSkillEnemy = nil
	FAIO.lastHitterKillableImage = nil
	FAIO.kunkkaXMarkPosition = Vector()
	FAIO.kunkkaGhostshipTimer = 0
	FAIO.kunkkaXMarkCastTime = 0
	FAIO.TinkerStatus = 0
	FAIO.TinkerPusher = false
	FAIO.TinkerPorted = false
	FAIO.TinkerJungle = false
	FAIO.TinkerMarched = 0
	FAIO.TinkerGlimmerCastTime = 0
	FAIO.TinkerPanicRearmBlink = 0
	FAIO.TinkerPanelX = 0
	FAIO.TinkerPanelY = 0
	FAIO.TinkerPushMode = false
	FAIO.TinkerPushCreeps = 3
	FAIO.TinkerPushEnemies = 0
	FAIO.TinkerPushAllies = 0
	FAIO.TinkerPushJungle = true
	FAIO.TinkerPushSave = true
	FAIO.TinkerPushDefend = true
	FAIO.PudgeRotComboActivation = false
	FAIO.PudgeRotComboDeactivation = 0
	FAIO.PudgeHookStartTimer = 0
	FAIO.PudgeHookDelayer = 0
	FAIO.PudgeHookRotDelayer = 0
	FAIO.PudgeHookTarget = nil
	FAIO.PudgeHookTargetedPos = nil
	FAIO.PudgeHookHit = false
	FAIO.PudgecurrentParticle = 0
	FAIO.PudgecurrentParticleTarget = nil
	FAIO.PudgeRotFarmToggled = false
	FAIO.PudgeRotFarmToggledTime = 0
	FAIO.TinkerJungleFarmPos = {}
	FAIO.JungleTrackTable = {}
	FAIO.ShrinePositionTable = {}
	FAIO.wardDispenserCount = {}
	FAIO.wardProcessingTable = {}
	FAIO.lastHitCreepHPPrediction = {}
	FAIO.lastHitCreepHPPredictionTime = {}
	FAIO.creepAttackPointData = {}
	FAIO.dodgeItTable = {}
	FAIO.dodgeItSkillReady = {}
	FAIO.dodgeItReadyTable = {}
	FAIO.LinkensBreakerItemOrder = {}
	FAIO.ItemCastOrder = {}
	FAIO.rotationTable = {}
	FAIO.PuckOrbHitSim = {}
	FAIO.enemyHeroTable = {}
	FAIO.InvokerKSparticleProcess = {{nil, nil, 0, nil, Vector()}}
	FAIO.PreInvokeSkills = {}
	FAIO.invokerCachedIcons = {}
	FAIO.VisageFamiliarAttackCounter = {}
	FAIO.heroIconHandler = {}
	FAIO.itemIconHandler = {}
	FAIO.ControllableEntityTable = {}
	FAIO.ControllableAttackTiming = {}

end

function FAIO.OnGameStart()
	
	FAIO.ResetGlobalVariables()

end

function FAIO.OnGameEnd()
	
	FAIO.ResetGlobalVariables()

end

-- main callback
function FAIO.OnUpdate()
	
	if not Menu.IsEnabled(FAIO.optionEnable) then return end

	if not Engine.IsInGame() then
		FAIO.ResetGlobalVariables()
	end
	
	if GameRules.GetGameState() < 4 then return end
	if GameRules.GetGameState() > 5 then return end

	local myHero = Heroes.GetLocal()
		if not myHero then return end
		if not Wrap.EIsAlive(myHero) then return end
		if FAIO.myUnitName == nil then
			FAIO.myUnitName = NPC.GetUnitName(myHero)
		end

		
		--[[if FAIO.myUnitName == "npc_dota_hero_axe" then
			if CurentHero == nil then
				CurentHero = FAIO.myUnitName
				Menu.RemoveOption(FAIO.CurentHero)
				Menu.RemoveOption(FAIO.optionHeroAxe)
				FAIO.optionHeroAxe = Menu.AddOptionBool(OverallPath[122], "Axe Combo", false)
				Menu.RemoveOption(FAIO.optionHeroAxeCulling)
				FAIO.optionHeroAxeCulling = Menu.AddOptionBool(OverallPath[122], "Auto culling blade", false)
				Menu.RemoveOption(FAIO.optionHeroAxeJump)
				FAIO.optionHeroAxeJump = Menu.AddOptionCombo(OverallPath[122], "Axe Jump Style", {' blink target', ' blink best position'}, 1)
				Menu.RemoveOption(FAIO.optionHeroAxeForceBlink)
				FAIO.optionHeroAxeForceBlink = Menu.AddOptionBool(OverallPath[122], "Force blink", false)
				Menu.RemoveOption(FAIO.optionHeroAxeForceBlinkRange)
				FAIO.optionHeroAxeForceBlinkRange = Menu.AddOptionSlider(OverallPath[122], "Force Blink Check Range", 150, 750, 50)
			end
		end]]--
	if Menu.IsEnabled(FAIO.optionHeroMorphReplicate) then
		local replicateMod = NPC.GetModifier(myHero, "modifier_morphling_replicate")
		if replicateMod then
			local checkAbility = NPC.GetAbilityByIndex(myHero, 0)
				if checkAbility == nil then
					checkAbility = NPC.GetAbilityByIndex(myHero, 1)
				end
			if checkAbility then
				local abilityName = Ability.GetName(checkAbility)
				local abilityNameShort = string.sub(abilityName, 1, string.find(abilityName, "_") - 1)
				local heroName = "npc_dota_hero_" .. abilityNameShort
				if heroName == "npc_dota_hero_skywrath" then
					heroName = "npc_dota_hero_skywrath_mage"
				elseif heroName == "npc_dota_hero_ember" then
					heroName = "npc_dota_hero_ember_spirit"
				elseif heroName == "npc_dota_hero_templar" then
					heroName = "npc_dota_hero_templar_assassin"
				elseif heroName == "npc_dota_hero_phantom" then
					if abilityName == "phantom_assassin_stifling_dagger" or abilityName == "phantom_assassin_phantom_strike" then
						heroName = "npc_dota_hero_phantom_assassin"
					end
				elseif heroName == "npc_dota_hero_obsidian" then
					heroName = "npc_dota_hero_obsidian_destroyer"
				elseif heroName == "npc_dota_hero_dark" then
					if abilityName == "dark_willow_bramble_maze" or abilityName == "dark_willow_shadow_realm" then
						heroName = "npc_dota_hero_dark_willow"
					end
				elseif heroName == "npc_dota_hero_arc" then
					heroName = "npc_dota_hero_arc_warden"
				elseif heroName == "npc_dota_hero_invoker" then
					heroName = "npc_dota_hero_morphling"
				elseif heroName == "npc_dota_hero_legion" then
					heroName = "npc_dota_hero_legion_commander"
				end
				if FAIO.utilityIsInTable(FAIO.heroList, heroName) then
					FAIO.myUnitName = heroName
				end
			end
		else
			if NPC.GetUnitName(myHero) ~= FAIO.myUnitName then
				FAIO.myUnitName = NPC.GetUnitName(myHero)
			end
		end
	end

	if Menu.IsEnabled(FAIO.optionHeroMorphReplicateBack) then
		local replicateBack = NPC.GetAbility(myHero, "morphling_morph_replicate")
		if replicateBack and not Ability.IsHidden(replicateBack) and Ability.IsReady(replicateBack) then
			if FAIO.heroCanCastSpells(myHero) == true then
				if Entity.GetHealth(myHero) / Entity.GetMaxHealth(myHero) < Menu.GetValue(FAIO.optionHeroMorphReplicateBackHP) / 100 then
					Ability.CastNoTarget(replicateBack)
					return
				end
			end
		end
	end

	if next(FAIO.ItemCastOrder) == nil then
		FAIO.setOrderItem(false)
	end
 	if next(FAIO.LinkensBreakerItemOrder) == nil then
		FAIO.setOrderLinkens(false)
	end

	local isHeroSupported = FAIO.heroSupported(myHero)

	local enemy = FAIO.getComboTarget(myHero)

	if Menu.IsKeyDown(FAIO.optionComboKey) then
		if Menu.GetValue(FAIO.optionTargetStyle) < 1 then
			if FAIO.LockedTarget == nil then
				if enemy then
					FAIO.LockedTarget = enemy
				else
					FAIO.LockedTarget = nil
				end
			end
		else
			if enemy then
				FAIO.LockedTarget = enemy
			else
				FAIO.LockedTarget = nil
			end
		end
	else
		FAIO.LockedTarget = nil
	end

	if FAIO.LockedTarget ~= nil then
		if not Wrap.EIsAlive(FAIO.LockedTarget) then
			FAIO.LockedTarget = nil
		elseif Entity.IsDormant(FAIO.LockedTarget) then
			FAIO.LockedTarget = nil
		elseif not NPC.IsEntityInRange(myHero, FAIO.LockedTarget, 3000) then
			FAIO.LockedTarget = nil
		end
	end

	if Menu.IsEnabled(FAIO.optionLockTargetIndicator) then
		FAIO.TargetIndicator(myHero)
	end

	local comboTarget
		if FAIO.LockedTarget ~= nil then
			comboTarget = FAIO.LockedTarget
		else
			if not Menu.IsKeyDown(FAIO.optionComboKey) then
				comboTarget = enemy
			end
		end
			
	if comboTarget then
		if isHeroSupported then
			if FAIO.myUnitName == "npc_dota_hero_axe" then
				FAIO.axeCombo(myHero, comboTarget)
			elseif FAIO.myUnitName == "npc_dota_hero_rattletrap" then
				FAIO.clockwerkCombo(myHero, comboTarget)
			elseif FAIO.myUnitName == "npc_dota_hero_skywrath_mage" then
				FAIO.skywrathCombo(myHero, comboTarget)
			elseif FAIO.myUnitName == "npc_dota_hero_tiny" then
				FAIO.tinyCombo(myHero, comboTarget)
			elseif FAIO.myUnitName == "npc_dota_hero_windrunner" then
				FAIO.WindRunnerCombo(myHero, comboTarget)
			elseif FAIO.myUnitName == "npc_dota_hero_ember_spirit" then
				FAIO.EmberCombo(myHero, comboTarget)
			elseif FAIO.myUnitName == "npc_dota_hero_ursa" then
				FAIO.UrsaCombo(myHero, comboTarget)
			elseif FAIO.myUnitName == "npc_dota_hero_templar_assassin" then
				FAIO.TACombo(myHero, comboTarget)
			elseif FAIO.myUnitName == "npc_dota_hero_slardar" then
				FAIO.SlardarCombo(myHero, comboTarget)
			elseif FAIO.myUnitName == "npc_dota_hero_queenofpain" then
				FAIO.QoPCombo(myHero, comboTarget)
			elseif FAIO.myUnitName == "npc_dota_hero_sven" then
				FAIO.SvenCombo(myHero, comboTarget)
			elseif FAIO.myUnitName == "npc_dota_hero_visage" then
				FAIO.VisageCombo(myHero, comboTarget)
			elseif FAIO.myUnitName == "npc_dota_hero_puck" then
				FAIO.PuckCombo(myHero, comboTarget)
			elseif FAIO.myUnitName == "npc_dota_hero_antimage" then
				FAIO.AntiMageCombo(myHero, comboTarget)
			elseif FAIO.myUnitName == "npc_dota_hero_phantom_assassin" then
				FAIO.PACombo(myHero, comboTarget)
			elseif FAIO.myUnitName == "npc_dota_hero_obsidian_destroyer" then
				FAIO.ODCombo(myHero, comboTarget)
			elseif FAIO.myUnitName == "npc_dota_hero_silencer" then
				FAIO.SilencerCombo(myHero, comboTarget)
			elseif FAIO.myUnitName == "npc_dota_hero_dark_willow" then
				FAIO.WillowCombo(myHero, comboTarget)
			elseif FAIO.myUnitName == "npc_dota_hero_dazzle" then
				FAIO.DazzleHelper(myHero, comboTarget)
			elseif FAIO.myUnitName == "npc_dota_hero_centaur" then
				FAIO.centaurCombo(myHero, comboTarget)
			elseif FAIO.myUnitName == "npc_dota_hero_ogre_magi" then
				FAIO.OgreCombo(myHero, comboTarget)
			elseif FAIO.myUnitName == "npc_dota_hero_ancient_apparition" then
				FAIO.AACombo(myHero, comboTarget)
			elseif FAIO.myUnitName == "npc_dota_hero_nyx_assassin" then
				FAIO.NyxCombo(myHero, comboTarget)
			elseif FAIO.myUnitName == "npc_dota_hero_night_stalker" then
				FAIO.NSCombo(myHero, comboTarget)
			elseif FAIO.myUnitName == "npc_dota_hero_chaos_knight" then
				FAIO.CKCombo(myHero, comboTarget)
			elseif FAIO.myUnitName == "npc_dota_hero_witch_doctor" then
				FAIO.WDCombo(myHero, comboTarget)
			elseif FAIO.myUnitName == "npc_dota_hero_shadow_shaman" then
				FAIO.SSCombo(myHero, comboTarget)
			elseif FAIO.myUnitName == "npc_dota_hero_death_prophet" then
				FAIO.DPCombo(myHero, comboTarget)
			elseif FAIO.myUnitName == "npc_dota_hero_crystal_maiden" then
				FAIO.CMCombo(myHero, comboTarget)
			elseif FAIO.myUnitName == "npc_dota_hero_lion" then
				FAIO.LionCombo(myHero, comboTarget)
			elseif FAIO.myUnitName == "npc_dota_hero_pugna" then
				FAIO.PugnaCombo(myHero, comboTarget)
			elseif FAIO.myUnitName == "npc_dota_hero_undying" then
				FAIO.UndyingCombo(myHero, comboTarget)
			elseif FAIO.myUnitName == "npc_dota_hero_vengefulspirit" then
				FAIO.VSCombo(myHero, comboTarget)
			end
		else
			if Menu.IsKeyDown(FAIO.optionComboKey) and Wrap.EIsAlive(comboTarget) then	
				FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", comboTarget, nil)	
				FAIO.itemUsage(myHero, comboTarget)
			end
		end
	end

	if NPC.GetUnitName(myHero) == "npc_dota_hero_invoker" then
		FAIO.InvokerCombo(myHero, comboTarget)
	end

	if FAIO.myUnitName == "npc_dota_hero_arc_warden" then
		FAIO.ArcWardenCombo(myHero, comboTarget)
	end

	if NPC.GetUnitName(myHero) == "npc_dota_hero_furion" then
		FAIO.ProphetHelper(myHero, comboTarget)
	end
	
	if FAIO.myUnitName == "npc_dota_hero_clinkz" then
		FAIO.ClinkzCombo(myHero, comboTarget)
		if Menu.IsEnabled(FAIO.optionHeroClinkzUlt) then
			FAIO.ClinkzAutoUlt(myHero)
		end
	end

	if FAIO.myUnitName == "npc_dota_hero_legion_commander" then
		FAIO.LegionCombo(myHero, comboTarget)
	end

	if FAIO.myUnitName == "npc_dota_hero_morphling" then
		FAIO.MorphCombo(myHero, comboTarget)
	end

	if FAIO.myUnitName == "npc_dota_hero_necrolyte" then
		FAIO.NecroCombo(myHero, comboTarget)
	end
	
	if FAIO.myUnitName == "npc_dota_hero_magnataur" then
		FAIO.magnusCombo(myHero, comboTarget)
	end

	if FAIO.myUnitName == "npc_dota_hero_nevermore" then
		FAIO.SFCombo(myHero, comboTarget)
	end

	if FAIO.myUnitName == "npc_dota_hero_tinker" then
		FAIO.TinkerCombo(myHero, comboTarget)
	end

	if NPC.GetUnitName(myHero) == "npc_dota_hero_axe" then
		if Menu.IsEnabled(FAIO.optionHeroAxeForceBlink) then
			FAIO.ForceBlink(myHero, comboTarget, Menu.GetValue(FAIO.optionHeroAxeForceBlinkRange))
		end
	end

	if NPC.GetUnitName(myHero) == "npc_dota_hero_centaur" then
		if Menu.IsEnabled(FAIO.optionHeroCentaurForceBlink) then
			FAIO.ForceBlink(myHero, comboTarget, Menu.GetValue(FAIO.optionHeroCentaurForceBlinkRange))
		end
	end

	if FAIO.myUnitName == "npc_dota_hero_shredder" then
		FAIO.TimberCombo(myHero, comboTarget)
	end

	if FAIO.myUnitName == "npc_dota_hero_kunkka" then
		FAIO.KunkkaShipCombo(myHero, enemy)
	end
	
	if FAIO.myUnitName == "npc_dota_hero_zuus" then
		FAIO.ZuusCombo(myHero, comboTarget)
	end

	if FAIO.myUnitName == "npc_dota_hero_huskar" then
		FAIO.huskarCombo(myHero, comboTarget)
	end

	if FAIO.myUnitName == "npc_dota_hero_viper" then
		FAIO.ViperCombo(myHero, comboTarget)
	end

	if FAIO.myUnitName == "npc_dota_hero_pudge" then
		FAIO.PudgeCombo(myHero, comboTarget)
	end

	FAIO.lastHitter(myHero)
	FAIO.GetControllableEntities(myHero)
	FAIO.GenericJungleTracker(myHero)

	if Menu.IsEnabled(FAIO.optionDodgeItEnable) then	
		FAIO.dodgerSelectItemorSkill(myHero)
		FAIO.dodgerSkillAvailable(myHero)
		FAIO.dodger(myHero)
	end
	
	if Menu.IsEnabled(FAIO.optionUtilityEnable) then
		FAIO.utilityItemUsage(myHero)
	end

	if Menu.IsEnabled(FAIO.optionKillStealEnable) then
		if NPC.GetUnitName(myHero) == "npc_dota_hero_invoker" then
			if Menu.IsEnabled(FAIO.optionKillStealInvoker) then
				FAIO.AutoSunstrikeKillStealNew(myHero)
			end
		else
			FAIO.AutoNukeKillSteal(myHero)
		end
	end

	if Menu.IsEnabled(FAIO.optionDefensiveItems) then
		FAIO.useDefensiveItems(myHero, comboTarget)
	end
	
	if Menu.IsEnabled(FAIO.optionWardAwareness) then
		FAIO.wardProcessing(myHero)
	end

	if Menu.IsEnabled(FAIO.optionItemArmlet) then
		FAIO.armletHandler(myHero)
	end

	if Menu.IsEnabled(FAIO.optionItemHurricane) then
		FAIO.ItemAutoHurricaneUsage(myHero, comboTarget)
	end

	if Menu.IsEnabled(FAIO.optionItemBlademail) then
		FAIO.ItemAutoBMUsage(myHero)
	end

	if FAIO.LockedTarget == nil then
		if Menu.IsEnabled(FAIO.optionMoveToCursor) then
			if Menu.IsKeyDown(FAIO.optionComboKey) then
				FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Input.GetWorldCursorPos())
				return
			end
		end	
	end

--	for i = 1, NPCs.Count() do
--	local npc = NPCs.Get(i)
--	Log.Write(tostring(NPC.GetUnitName(npc)) .. " " .. tostring(Entity.GetOwner(npc)) .. " " .. tostring(Entity.OwnedBy(npc, myHero)))
--	end

--	local modifiers = NPC.GetModifiers(myHero)
--	for _, modifier in ipairs(modifiers) do
--	local modifierName = Modifier.GetName(modifier)
--	Log.Write(modifierName)
--	end

--	for i = 1, Abilities.Count() do
--	local abilities = Abilities.Get(i)
--	local abilityNames = Ability.GetName(abilities)
--	Log.Write(abilityNames)
--	end

end

function FAIO.getComboTarget(myHero)

	if not myHero then return end

	local targetingRange = Menu.GetValue(FAIO.optionTargetRange)
	local mousePos = Input.GetWorldCursorPos()

	local enemyTable = Wrap.HInRadius(mousePos, targetingRange, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY)
		if #enemyTable < 1 then return end

	local nearestTarget = nil
	local distance = 99999

	for i, v in ipairs(enemyTable) do
		if v and Entity.IsHero(v) then
			if FAIO.targetChecker(v) ~= nil then
				local enemyDist = (Entity.GetAbsOrigin(v) - mousePos):Length2D()
				if enemyDist < distance then
					nearestTarget = v
					distance = enemyDist
				end
			end
		end
	end

	return nearestTarget or nil

end

function FAIO.OnEntityDestroy(ent)

	if not ent then return end
	if FAIO.lastHitCreepHPPrediction[ent] ~= nil then
		FAIO.lastHitCreepHPPrediction[ent] = nil
	end

	if FAIO.lastHitCreepHPPredictionTime[ent] ~= nil then
		FAIO.lastHitCreepHPPredictionTime[ent] = nil
	end

	if Wrap.EIsNPC(ent) and NPC.IsNeutral(ent) then
		local minute = math.floor((GameRules.GetGameTime() - GameRules.GetGameStartTime()) / 60)
		local entityPos = Entity.GetAbsOrigin(ent)
			entityPos:SetZ(0)

		for key, info in ipairs(FAIO.JungleTrackTable) do
			local pos = info[1]		
			if (pos - entityPos):Length2D() < 1000 then
				local class = info[4]
				local checkTable = {}
					if class == "small" then
						checkTable = FAIO.NeutralMainNPCsmall
					elseif class == "medium" then
						checkTable = FAIO.NeutralMainNPCmedium
					else
						checkTable = FAIO.NeutralMainNPChard
					end
				if next(checkTable) ~= nil then
					local checkValue = false
						for i, v in ipairs(checkTable) do
							if NPC.GetUnitName(ent) == v then
								checkValue = true
								break
							end
						end
					
					if checkValue then	
						if info[2] == true and (pos - entityPos):Length2D() < 1000 then
							FAIO.JungleTrackTable[key][2] = false
							FAIO.JungleTrackTable[key][3] = minute
							break
						end
					end
				end
			end
		end
	end

	if not Menu.IsEnabled(FAIO.optionWardAwareness) then return end
	if not Menu.IsEnabled(FAIO.optionWardAwarenessRemove) then return end

	if not Heroes.GetLocal() then return end

	if not Wrap.EIsNPC(ent) then return end
	if Entity.IsSameTeam(Heroes.GetLocal(), ent) then return end
	if NPC.GetUnitName(ent) ~= "npc_dota_sentry_wards" and NPC.GetUnitName(ent) ~= "npc_dota_observer_wards" then return end

	if next(FAIO.wardProcessingTable) ~= nil then
		for i, v in pairs(FAIO.wardProcessingTable) do
			if v then
				if (v.pos - Entity.GetAbsOrigin(ent)):Length2D() <= 500 then
					FAIO.wardProcessingTable[i] = nil
				end
			end
		end
	end

end

function FAIO.OnParticleCreate(particle)

	if not particle then return end
	if not Heroes.GetLocal() then return end

	local enemy = FAIO.targetChecker(Input.GetNearestHeroToCursor(Entity.GetTeamNum(Heroes.GetLocal()), Enum.TeamType.TEAM_ENEMY))

	if particle.name == "teleport_start" then
		if particle.entityForModifiers ~= nil and particle.entityForModifiers ~= Heroes.GetLocal() then
			if not Entity.IsSameTeam(Heroes.GetLocal(), particle.entityForModifiers) then
				FAIO.TPParticleIndex = particle.index
				FAIO.TPParticleTime = GameRules.GetGameTime()
				FAIO.TPParticleUnit = particle.entityForModifiers
			end
		end
	end

	if particle.name == "furion_sprout" then
		if particle.entityForModifiers ~= nil and Entity.IsSameTeam(Heroes.GetLocal(), particle.entityForModifiers) then
			FAIO.InvokerKSparticleProcess[1][1] = particle.index
			FAIO.InvokerKSparticleProcess[1][2] = particle.name
			FAIO.InvokerKSparticleProcess[1][3] = GameRules.GetGameTime()
			FAIO.InvokerKSparticleProcess[1][4] = particle.entityForModifiers
		end
	end

	if particle.name == "rattletrap_cog_deploy" then
		if particle.entity ~= nil and Entity.IsSameTeam(Heroes.GetLocal(), particle.entity) then
			FAIO.InvokerKSparticleProcess[1][1] = particle.index
			FAIO.InvokerKSparticleProcess[1][2] = particle.name
			FAIO.InvokerKSparticleProcess[1][3] = GameRules.GetGameTime()
			FAIO.InvokerKSparticleProcess[1][4] = particle.entity
			FAIO.InvokerKSparticleProcess[1][5] = Entity.GetAbsOrigin(particle.entity)
		end
	end

	if particle.name == "disruptor_glimpse_targetend" then
		FAIO.GlimpseParticleIndex = particle.index
		FAIO.GlimpseParticleTime = GameRules.GetGameTime()
	end

	if particle.name == "disruptor_glimpse_targetstart" then
		FAIO.GlimpseParticleIndexStart = particle.index
	end
	
end

function FAIO.OnParticleUpdate(particle)

	if not particle then return end
	if not Heroes.GetLocal() then return end

	if particle.position:__tostring() == Vector(1.0, 1.0, 1.0):__tostring() then return end
	if particle.position:__tostring() == Vector(0.0, 0.0, 0.0):__tostring() then return end
	if particle.position:Length() < 75 then return end

	if particle.index  == FAIO.TPParticleIndex then
		if particle.controlPoint == 0 then
			FAIO.TPParticlePosition = particle.position
		end
	end

	if particle.index  == FAIO.InvokerKSparticleProcess[1][1] then
		if particle.position:__tostring() ~= Vector(0.0, 150.0, 0.0):__tostring() then
			FAIO.InvokerKSparticleProcess[1][5] = particle.position
		end
	end

	if particle.index  == FAIO.GlimpseParticleIndex then
		if particle.position:Length2D() > 100 then
			FAIO.GlimpseParticlePosition = particle.position
		end
	end

end

function FAIO.OnParticleUpdateEntity(particle)

	if not particle then return end

	if not Heroes.GetLocal() then return end	
	if not particle.position then return end
	if particle.controlPoint > 0 then return end

	if particle.index  == FAIO.GlimpseParticleIndexStart then
		if particle.entity ~= nil and not Entity.IsSameTeam(Heroes.GetLocal(), particle.entity) then
			if particle.position:__tostring() ~= Vector(0.0, 0.0, 0.0):__tostring() then
				FAIO.GlimpseParticlePositionStart = particle.position
				FAIO.GlimpseParticleUnit = particle.entity
			end
		end
	end

end

function FAIO.OnUnitAnimation(animation)

	if not animation then return end
	if not Heroes.GetLocal() then return end

	if Menu.IsEnabled(FAIO.optionDodgeItEnable) then
		FAIO.dodgeProcessing(Heroes.GetLocal(), animation.unit, animation.activity, animation.castpoint)
	end

	if animation.unit then
		if Wrap.EIsNPC(animation.unit) and not Entity.IsSameTeam(Heroes.GetLocal(), animation.unit) and not Entity.IsHero(animation.unit) and not Entity.IsDormant(animation.unit) and NPC.IsEntityInRange(Heroes.GetLocal(), animation.unit, 1000) then
			local name = NPC.GetUnitName(animation.unit)
			if FAIO.creepAttackPointData[name] == nil then
				FAIO.creepAttackPointData[name] = animation.castpoint
			else
				if animation.castpoint < FAIO.creepAttackPointData[name] then
					FAIO.creepAttackPointData[name] = animation.castpoint
				end
			end
		end
	end

	if Wrap.EIsNPC(animation.unit) and not NPC.IsRanged(animation.unit) then
		if NPC.IsEntityInRange(Heroes.GetLocal(), animation.unit, 1000) then
			if NPC.IsLaneCreep(animation.unit) then
				if FAIO.lastHitterGetTarget(Heroes.GetLocal(), animation.unit) ~= nil then
					local targetCreep = FAIO.lastHitterGetTarget(Heroes.GetLocal(), animation.unit)
					local creepHP = math.floor(Entity.GetHealth(targetCreep) + NPC.GetHealthRegen(targetCreep))
					local creepDMG = math.ceil(NPC.GetDamageMultiplierVersus(animation.unit, targetCreep) * ((NPC.GetMinDamage(animation.unit) + NPC.GetBonusDamage(animation.unit)) * NPC.GetArmorDamageMultiplier(targetCreep)))
						if Menu.IsEnabled(FAIO.optionLastHitPredict) then
							creepDMG = math.ceil(NPC.GetDamageMultiplierVersus(animation.unit, targetCreep) * (((NPC.GetTrueMaximumDamage(animation.unit) + NPC.GetTrueDamage(animation.unit)) / 2) * NPC.GetArmorDamageMultiplier(targetCreep)))
						end
				--	local hitTime = FAIO.utilityRoundNumber((GameRules.GetGameTime() + animation.castpoint - 0.035 - NetChannel.GetAvgLatency(Enum.Flow.FLOW_INCOMING)), 3)
					local hitTime = FAIO.utilityRoundNumber((GameRules.GetGameTime() + animation.castpoint - 0.035), 3)
					local sourceIndex = Entity.GetIndex(animation.unit)
					if FAIO.lastHitCreepHPPrediction[targetCreep] == nil then
						FAIO.lastHitCreepHPPrediction[targetCreep] = {}
						table.insert(FAIO.lastHitCreepHPPrediction[targetCreep], { hitTime, math.ceil(creepDMG), sourceIndex })
						if FAIO.lastHitterTimingOffsetter(Heroes.GetLocal(), targetCreep) ~= nil and FAIO.lastHitterTimingOffsetter(Heroes.GetLocal(), targetCreep) > 0.45 then
							if creepHP > 2 * creepDMG then
								table.insert(FAIO.lastHitCreepHPPrediction[targetCreep], { hitTime + NPC.GetAttackTime(animation.unit), creepDMG, sourceIndex })
							end
						end
					else
						local inserted = false
						for _, info in ipairs(FAIO.lastHitCreepHPPrediction[targetCreep]) do
							if info and info[3] == sourceIndex and math.abs(hitTime - info[1]) < 0.25 then
								inserted = true
							end
						end
						if not inserted then
							table.insert(FAIO.lastHitCreepHPPrediction[targetCreep], { hitTime, math.ceil(creepDMG), sourceIndex })
							if FAIO.lastHitterTimingOffsetter(Heroes.GetLocal(), targetCreep) ~= nil and FAIO.lastHitterTimingOffsetter(Heroes.GetLocal(), targetCreep) > 0.45 then
								if creepHP > 2 * creepDMG then
									table.insert(FAIO.lastHitCreepHPPrediction[targetCreep], { hitTime + NPC.GetAttackTime(animation.unit), creepDMG, sourceIndex })
								end
							end
						else
							if FAIO.lastHitterTimingOffsetter(Heroes.GetLocal(), targetCreep) ~= nil and FAIO.lastHitterTimingOffsetter(Heroes.GetLocal(), targetCreep) > 0.45 then
								if creepHP > 2 * creepDMG then
									table.insert(FAIO.lastHitCreepHPPrediction[targetCreep], { hitTime + NPC.GetAttackTime(animation.unit), creepDMG, sourceIndex })
								end
							end
						end
					end
					local removeInstance = 0
					local removeTarget = nil
					for target, table in pairs(FAIO.lastHitCreepHPPrediction) do
						if table then
							if target ~= targetCreep then
								for i, info in ipairs(table) do
									if info and info[3] == sourceIndex and info[1] > GameRules.GetGameTime() and math.abs(hitTime - info[1]) > 0.1 then
										removeInstance = i
										removeTarget = target
									end
								end
							end
						end
					end
					if removeInstance > 0 and removeTarget ~= nil then
						table.remove(FAIO.lastHitCreepHPPrediction[removeTarget], removeInstance)
					end
				end
			else
				if Entity.IsHero(animation.unit) then
					if FAIO.lastHitterGetTarget(Heroes.GetLocal(), animation.unit) ~= nil then
						local targetCreep = FAIO.lastHitterGetTarget(Heroes.GetLocal(), animation.unit)
						local creepHP = math.floor(Entity.GetHealth(targetCreep) + NPC.GetHealthRegen(targetCreep))
						local creepDMG = math.ceil(NPC.GetDamageMultiplierVersus(animation.unit, targetCreep) * ((NPC.GetMinDamage(animation.unit) + NPC.GetBonusDamage(animation.unit)) * NPC.GetArmorDamageMultiplier(targetCreep)))
							if Menu.IsEnabled(FAIO.optionLastHitPredict) then
								creepDMG = math.ceil(NPC.GetDamageMultiplierVersus(animation.unit, targetCreep) * (((NPC.GetTrueMaximumDamage(animation.unit) + NPC.GetTrueDamage(animation.unit)) / 2) * NPC.GetArmorDamageMultiplier(targetCreep)))
							end
						local hitTime = FAIO.utilityRoundNumber((GameRules.GetGameTime() + animation.castpoint - 0.035), 3)
						local sourceIndex = Entity.GetIndex(animation.unit)
						if FAIO.lastHitCreepHPPrediction[targetCreep] == nil then
							FAIO.lastHitCreepHPPrediction[targetCreep] = {}
							table.insert(FAIO.lastHitCreepHPPrediction[targetCreep], { hitTime, math.ceil(creepDMG), sourceIndex })
						else
							table.insert(FAIO.lastHitCreepHPPrediction[targetCreep], { hitTime, math.ceil(creepDMG), sourceIndex })
						end
					end
				end
			end
		end
	end

	if animation.unit and Wrap.EIsNPC(animation.unit) and not Entity.IsSameTeam(Heroes.GetLocal(), animation.unit) and animation.type == 1 then
		if not NPC.IsRanged(animation.unit) then
			local attackRange = NPC.GetAttackRange(animation.unit) + 155
			if NPC.IsEntityInRange(Heroes.GetLocal(), animation.unit, attackRange) and NPC.FindFacingNPC(animation.unit) == Heroes.GetLocal() then
				local damage = FAIO.getAdjustedMaxTrueDamage(animation.unit, Heroes.GetLocal())
				table.insert(FAIO.armletDamageInstanceTable, { instanceindex = Entity.GetIndex(animation.unit), time = FAIO.utilityRoundNumber((GameRules.GetGameTime() + animation.castpoint - 0.035 - NetChannel.GetAvgLatency(Enum.Flow.FLOW_INCOMING)), 3), casttime = animation.castpoint, backswingstart = GameRules.GetGameTime() + animation.castpoint - 0.035, backswingend = GameRules.GetGameTime() + NPC.GetAttackTime(animation.unit) - 0.035, type = "attack", damage = damage, isProjectile = false })
			end
		else
			local attackRange = NPC.GetAttackRange(animation.unit) + 264
			if Entity.IsHero(animation.unit) and NPC.IsEntityInRange(Heroes.GetLocal(), animation.unit, attackRange) and NPC.FindFacingNPC(animation.unit) == Heroes.GetLocal() then
				local myProjectedPosition = Entity.GetAbsOrigin(Heroes.GetLocal())
				local projectileTiming = ((Entity.GetAbsOrigin(animation.unit) - myProjectedPosition):Length2D() - NPC.GetHullRadius(Heroes.GetLocal())) / FAIO.attackPointTable[NPC.GetUnitName(animation.unit)][3]
				local damage = FAIO.getAdjustedMaxTrueDamage(animation.unit, Heroes.GetLocal())
				table.insert(FAIO.armletDamageInstanceTable, { instanceindex = Entity.GetIndex(animation.unit), time = FAIO.utilityRoundNumber((GameRules.GetGameTime() + animation.castpoint + projectileTiming - 0.035 - NetChannel.GetAvgLatency(Enum.Flow.FLOW_INCOMING)), 3), casttime = animation.castpoint, backswingstart = GameRules.GetGameTime() + animation.castpoint - 0.035, backswingend = GameRules.GetGameTime() + NPC.GetAttackTime(animation.unit) - 0.035, type = "rangeattack", damage = damage, projectileorigin = Entity.GetAbsOrigin(animation.unit), projectilestarttime = GameRules.GetGameTime() + animation.castpoint - 0.035, projectilespeed = FAIO.attackPointTable[NPC.GetUnitName(animation.unit)][3], isProjectile = true })
			end
		end
	end

	if NPC.GetUnitName(Heroes.GetLocal()) ~= NPC.GetUnitName(animation.unit) then return end

	if FAIO.ArcWardenEntity ~= nil then
		if animation.unit == FAIO.ArcWardenEntity and animation.type == 1 then
			FAIO.ArcWardenEntityAnimationStart = GameRules.GetGameTime() - 0.035
			FAIO.ArcWardenEntityAnimationEnd = GameRules.GetGameTime() + animation.castpoint + 0.035
		end
	end

	if Heroes.GetLocal() ~= animation.unit then return end

	if animation.type == 1 then
		FAIO.AttackAnimationCreate = os.clock()
		FAIO.AttackParticleCreate = os.clock() + animation.castpoint
	end

end

function FAIO.OnProjectile(projectile)

	if not projectile then return end

	local myHero = Heroes.GetLocal()
		if not myHero then return end

	local armletProjectileList = {
		"npc_dota_hero_abaddon",
		"npc_dota_hero_broodmother",
		"npc_dota_hero_dragon_knight",
		"npc_dota_hero_enchantress",
		"npc_dota_hero_oracle",
		"npc_dota_hero_phantom_assassin",
		"npc_dota_hero_queenofpain",
		"npc_dota_hero_skywrath_mage",
		"npc_dota_hero_tidehunter",
		"npc_dota_hero_tiny",
		"npc_dota_hero_visage",
		"npc_dota_hero_winter_wyvern",
		"npc_dota_hero_bounty_hunter",
		"npc_dota_hero_earthshaker",
		"npc_dota_hero_morphling",
		"npc_dota_hero_phantom_lancer",
		"npc_dota_hero_tinker",
		"npc_dota_hero_gyrocopter",
		"npc_dota_hero_mirana",
		"npc_dota_hero_spectre",
		"npc_dota_hero_treant",
		"npc_dota_hero_medusa",
		"npc_dota_hero_arcwarden",
		"npc_dota_hero_necrolyte",
		"npc_dota_hero_witch_doctor",
		"npc_dota_hero_tusk",
		"npc_dota_hero_huskar",
		"npc_dota_hero_nyx_assassin",
		"npc_dota_hero_lion",
		"npc_dota_hero_lich",
		"npc_dota_hero_chaos_knight",
		"npc_dota_hero_alchemist",
		"npc_dota_hero_skeleton_king",
		"npc_dota_hero_sniper",
		"npc_dota_hero_sven",
		"npc_dota_hero_vengefulspirit",
			}

	if projectile.source and Wrap.EIsNPC(projectile.source) and projectile.isAttack then
		if NPC.IsEntityInRange(Heroes.GetLocal(), projectile.source, 1250) then
			if NPC.IsLaneCreep(projectile.source) or NPC.IsTower(projectile.source) then
				if projectile.target and Wrap.EIsNPC(projectile.target) and (NPC.IsLaneCreep(projectile.target) or NPC.IsTower(projectile.target)) then
					local projectileSpeed = projectile.moveSpeed
					local distance = math.max((Entity.GetAbsOrigin(projectile.source) - Entity.GetAbsOrigin(projectile.target)):Length2D() - NPC.GetHullRadius(projectile.target) - NPC.GetHullRadius(projectile.source), 1)
					local travelTime = distance / projectileSpeed - 0.035
					local targetCreep = projectile.target
					local creepHP = Entity.GetHealth(targetCreep) + NPC.GetHealthRegen(targetCreep)
					local creepDMG = math.ceil(NPC.GetDamageMultiplierVersus(projectile.source, targetCreep) * ((NPC.GetMinDamage(projectile.source) + NPC.GetBonusDamage(projectile.source)) * NPC.GetArmorDamageMultiplier(targetCreep)))
						if Menu.IsEnabled(FAIO.optionLastHitPredict) then
							creepDMG = math.ceil(NPC.GetDamageMultiplierVersus(projectile.source, targetCreep) * (((NPC.GetTrueMaximumDamage(projectile.source) + NPC.GetTrueDamage(projectile.source)) / 2) * NPC.GetArmorDamageMultiplier(targetCreep)))
						end
						if Entity.GetClassName(projectile.source) == "C_DOTA_BaseNPC_Creep_Siege" and Entity.GetClassName(projectile.target) == "C_DOTA_BaseNPC_Creep_Siege" then
							creepDMG = math.ceil((NPC.GetMinDamage(projectile.source) + NPC.GetBonusDamage(projectile.source)) * 2.5 * NPC.GetArmorDamageMultiplier(targetCreep))
							if Menu.IsEnabled(FAIO.optionLastHitPredict) then
								creepDMG = math.ceil(((NPC.GetTrueMaximumDamage(projectile.source) + NPC.GetTrueDamage(projectile.source)) / 2) * 2.5 * NPC.GetArmorDamageMultiplier(targetCreep))
							end
						elseif Entity.GetClassName(projectile.source) == "C_DOTA_BaseNPC_Tower" and Entity.GetClassName(projectile.target) == "C_DOTA_BaseNPC_Creep_Siege" then
							creepDMG = math.ceil((NPC.GetMinDamage(projectile.source) + NPC.GetBonusDamage(projectile.source)) * 2.5 * NPC.GetArmorDamageMultiplier(targetCreep))
							if Menu.IsEnabled(FAIO.optionLastHitPredict) then
								creepDMG = math.ceil(((NPC.GetTrueMaximumDamage(projectile.source) + NPC.GetTrueDamage(projectile.source)) / 2) * 2.5 * NPC.GetArmorDamageMultiplier(targetCreep))
							end
						elseif Entity.GetClassName(projectile.source) == "C_DOTA_BaseNPC_Creep_Siege" and Entity.GetClassName(projectile.target) == "C_DOTA_BaseNPC_Tower" then
							creepDMG = math.ceil((NPC.GetMinDamage(projectile.source) + NPC.GetBonusDamage(projectile.source)) * 2.5 * NPC.GetArmorDamageMultiplier(targetCreep))
							if Menu.IsEnabled(FAIO.optionLastHitPredict) then
								creepDMG = math.ceil(((NPC.GetTrueMaximumDamage(projectile.source) + NPC.GetTrueDamage(projectile.source)) / 2) * 2.5 * NPC.GetArmorDamageMultiplier(targetCreep))
							end
						end
				--	local hitTime = FAIO.utilityRoundNumber((GameRules.GetGameTime() + travelTime - 0.035 - NetChannel.GetAvgLatency(Enum.Flow.FLOW_INCOMING)), 3)
					local hitTime = FAIO.utilityRoundNumber((GameRules.GetGameTime() + travelTime - 0.035), 3)
					local sourceIndex = Entity.GetIndex(projectile.source)
					if FAIO.lastHitCreepHPPrediction[targetCreep] == nil then
						FAIO.lastHitCreepHPPrediction[targetCreep] = {}
						table.insert(FAIO.lastHitCreepHPPrediction[targetCreep], { hitTime, math.ceil(creepDMG), sourceIndex })
						if FAIO.lastHitterTimingOffsetter(Heroes.GetLocal(), targetCreep) ~= nil and travelTime < FAIO.lastHitterTimingOffsetter(Heroes.GetLocal(), targetCreep) * 1.2 then
							if creepHP > 2 * creepDMG then
								table.insert(FAIO.lastHitCreepHPPrediction[targetCreep], { hitTime + NPC.GetAttackTime(projectile.source), creepDMG, sourceIndex })
							end
						end
					else
						local inserted = false
						local insertedKey = 0
						for i, info in ipairs(FAIO.lastHitCreepHPPrediction[targetCreep]) do
							if info and info[3] == sourceIndex then
								if info[1] > GameRules.GetGameTime() then
									if math.abs(hitTime - info[1]) < 0.25 then
										inserted = true
										insertedKey = i
									end
								end
							end
						end
						if not inserted then
							table.insert(FAIO.lastHitCreepHPPrediction[targetCreep], { hitTime, math.ceil(creepDMG), sourceIndex })
							if FAIO.lastHitterTimingOffsetter(Heroes.GetLocal(), targetCreep) ~= nil and travelTime < FAIO.lastHitterTimingOffsetter(Heroes.GetLocal(), targetCreep) * 1.2 then
								if creepHP > 2 * creepDMG then
									table.insert(FAIO.lastHitCreepHPPrediction[targetCreep], { hitTime + NPC.GetAttackTime(projectile.source), creepDMG, sourceIndex })
								end
							end
						else
							table.remove(FAIO.lastHitCreepHPPrediction[targetCreep], insertedKey)
							table.insert(FAIO.lastHitCreepHPPrediction[targetCreep], { hitTime, math.ceil(creepDMG), sourceIndex })
							if FAIO.lastHitterTimingOffsetter(Heroes.GetLocal(), targetCreep) ~= nil and travelTime < FAIO.lastHitterTimingOffsetter(Heroes.GetLocal(), targetCreep) * 1.2 then
								if creepHP > 2 * creepDMG then
									table.insert(FAIO.lastHitCreepHPPrediction[targetCreep], { hitTime + NPC.GetAttackTime(projectile.source), creepDMG, sourceIndex })
								end
							end
						end
					end
					local removeInstance = 0
					local removeTarget = nil
					for target, table in pairs(FAIO.lastHitCreepHPPrediction) do
						if table then
							if target ~= targetCreep then
								for i, info in ipairs(table) do
									if info and info[3] == sourceIndex then
										if info[1] > GameRules.GetGameTime() and math.abs(hitTime - info[1]) > 0.1 then
											removeInstance = i
											removeTarget = target
										end
									end
								end
							end
						end
					end
					if removeInstance > 0 and removeTarget ~= nil then
						table.remove(FAIO.lastHitCreepHPPrediction[removeTarget], removeInstance)
					end
				end
			else
				if Entity.IsHero(projectile.source) then
					if projectile.target and Wrap.EIsNPC(projectile.target) and (NPC.IsLaneCreep(projectile.target) or NPC.IsTower(projectile.target)) then
						local projectileSpeed = projectile.moveSpeed
						local distance = math.max((Entity.GetAbsOrigin(projectile.source) - Entity.GetAbsOrigin(projectile.target)):Length2D() - NPC.GetHullRadius(projectile.target) - NPC.GetHullRadius(projectile.source), 1)
						local travelTime = distance / projectileSpeed - 0.035
						local targetCreep = projectile.target
						local creepDMG = math.ceil(NPC.GetDamageMultiplierVersus(projectile.source, targetCreep) * ((NPC.GetMinDamage(projectile.source) + NPC.GetBonusDamage(projectile.source)) * NPC.GetArmorDamageMultiplier(targetCreep)))
							if Menu.IsEnabled(FAIO.optionLastHitPredict) then
								creepDMG = math.ceil(NPC.GetDamageMultiplierVersus(projectile.source, targetCreep) * (((NPC.GetTrueMaximumDamage(projectile.source) + NPC.GetTrueDamage(projectile.source)) / 2) * NPC.GetArmorDamageMultiplier(targetCreep)))
							end
						local hitTime = FAIO.utilityRoundNumber((GameRules.GetGameTime() + travelTime - 0.035), 3)
						local sourceIndex = Entity.GetIndex(projectile.source)
						if FAIO.lastHitCreepHPPrediction[targetCreep] == nil then
							FAIO.lastHitCreepHPPrediction[targetCreep] = {}
							table.insert(FAIO.lastHitCreepHPPrediction[targetCreep], { hitTime, math.ceil(creepDMG), sourceIndex })
						else
							table.insert(FAIO.lastHitCreepHPPrediction[targetCreep], { hitTime, math.ceil(creepDMG), sourceIndex })
						end
					end
				end	
			end
		end
	end

	if projectile.source and Entity.GetClassName(projectile.source) == "C_DOTA_Unit_VisageFamiliar" then

		local familiarAttackTime = NPC.GetAttackTime(projectile.source)
		if FAIO.VisageFamiliarAttackCounter[Entity.GetIndex(projectile.source)] == nil then
			FAIO.VisageFamiliarAttackCounter[Entity.GetIndex(projectile.source)] = { GameRules.GetGameTime(), 1 }
		else
			if FAIO.VisageFamiliarAttackCounter[Entity.GetIndex(projectile.source)][1] + familiarAttackTime * 1.5 > GameRules.GetGameTime() then
				FAIO.VisageFamiliarAttackCounter[Entity.GetIndex(projectile.source)][1] = GameRules.GetGameTime()
				FAIO.VisageFamiliarAttackCounter[Entity.GetIndex(projectile.source)][2] = FAIO.VisageFamiliarAttackCounter[Entity.GetIndex(projectile.source)][2] + 1
			else
				FAIO.VisageFamiliarAttackCounter[Entity.GetIndex(projectile.source)] = { GameRules.GetGameTime(), 1 }
			end
		end
	end

	if projectile.source and Wrap.EIsNPC(projectile.source) and NPC.IsRanged(projectile.source) and not Entity.IsSameTeam(Heroes.GetLocal(), projectile.source) and projectile.isAttack then
		local attackRange = NPC.GetAttackRange(projectile.source)
		if not Entity.IsHero(projectile.source) then
			if projectile.target == Heroes.GetLocal() then
				local casttime = 0.5
					if FAIO.creepAttackPointData[NPC.GetUnitName(projectile.source)] ~= nil then
						casttime = FAIO.creepAttackPointData[NPC.GetUnitName(projectile.source)]
					end
				local myProjectedPosition = Entity.GetAbsOrigin(myHero)
				local projectileTiming = ((Entity.GetAbsOrigin(projectile.source) - myProjectedPosition):Length() - NPC.GetHullRadius(projectile.target)) / projectile.moveSpeed
				local damage = FAIO.getAdjustedMaxTrueDamage(projectile.source, Heroes.GetLocal())
				table.insert(FAIO.armletDamageInstanceTable, { instanceindex = Entity.GetIndex(projectile.source), time = FAIO.utilityRoundNumber((GameRules.GetGameTime() + projectileTiming - 0.035 - NetChannel.GetAvgLatency(Enum.Flow.FLOW_INCOMING)), 3), casttime = casttime, backswingstart = GameRules.GetGameTime() - 0.035, backswingend = GameRules.GetGameTime() + NPC.GetAttackTime(projectile.source) - casttime - 0.035, type = "rangeattack", damage = damage, projectileorigin = Entity.GetAbsOrigin(projectile.source), projectilestarttime = GameRules.GetGameTime() - 0.035, projectilespeed = projectile.moveSpeed, isProjectile = true })
			end
		else
			if projectile.target == Heroes.GetLocal() then
				local myProjectedPosition = Entity.GetAbsOrigin(myHero)
				local projectileTiming = ((Entity.GetAbsOrigin(projectile.source) - myProjectedPosition):Length2D() - NPC.GetHullRadius(projectile.target)) / projectile.moveSpeed
				local damage = FAIO.getAdjustedMaxTrueDamage(projectile.source, Heroes.GetLocal())
				local inserted = false
				for k, info in ipairs(FAIO.armletDamageInstanceTable) do
					if info and info.instanceindex == Entity.GetIndex(projectile.source) then
						if math.abs(info.time - FAIO.utilityRoundNumber((GameRules.GetGameTime() + projectileTiming - 0.035 - NetChannel.GetAvgLatency(Enum.Flow.FLOW_INCOMING)), 3)) < NPC.GetAttackTime(projectile.source) * 0.75 then
							inserted = true
						end
					end
				end
				if not inserted then
					local casttime = FAIO.attackPointTable[NPC.GetUnitName(projectile.source)][1] / (1 + NPC.GetIncreasedAttackSpeed(projectile.source))
					table.insert(FAIO.armletDamageInstanceTable, { instanceindex = Entity.GetIndex(projectile.source), time = FAIO.utilityRoundNumber((GameRules.GetGameTime() + projectileTiming - 0.035 - NetChannel.GetAvgLatency(Enum.Flow.FLOW_INCOMING)), 3), casttime = casttime, backswingstart = GameRules.GetGameTime() - 0.035, backswingend = GameRules.GetGameTime() + NPC.GetAttackTime(projectile.source) - casttime - 0.035, type = "rangeattack", damage = damage, projectileorigin = Entity.GetAbsOrigin(projectile.source), projectilestarttime = GameRules.GetGameTime() - 0.035, projectilespeed = projectile.moveSpeed, isProjectile = true })
				end	
			end
		end
	end

	if projectile.source and Wrap.EIsNPC(projectile.source) and not projectile.isAttack and projectile.name ~= "rod_of_atos_attack" then
		if projectile.target == Heroes.GetLocal() then
			local myProjectedPosition = Entity.GetAbsOrigin(myHero)
			local projectileTiming = ((Entity.GetAbsOrigin(projectile.source) - myProjectedPosition):Length2D() - NPC.GetHullRadius(projectile.target)) / projectile.moveSpeed
			if not Entity.IsSameTeam(Heroes.GetLocal(), projectile.source) then
				if projectile.name ~= "nullifier_proj" then
					local insert = false
					for i, v in ipairs(armletProjectileList) do
						if v and v == NPC.GetUnitName(projectile.source) then
							insert = true
						end
					end
					if insert then
						table.insert(FAIO.armletDamageInstanceTable, { instanceindex = projectile.name, time = FAIO.utilityRoundNumber((GameRules.GetGameTime() + projectileTiming - 0.035 - NetChannel.GetAvgLatency(Enum.Flow.FLOW_INCOMING)), 3), casttime = 0, type = "ability", damage = 250, projectileorigin = Entity.GetAbsOrigin(projectile.source), projectilestarttime = GameRules.GetGameTime() - 0.035, projectilespeed = projectile.moveSpeed, isProjectile = true })
					end
				else
					table.insert(FAIO.armletDamageInstanceTable, { instanceindex = projectile.name, time = FAIO.utilityRoundNumber((GameRules.GetGameTime() + projectileTiming - 0.035 - NetChannel.GetAvgLatency(Enum.Flow.FLOW_INCOMING)), 3), casttime = 0, type = "ability", damage = 1000, projectileorigin = Entity.GetAbsOrigin(projectile.source), projectilestarttime = GameRules.GetGameTime() - 0.035, projectilespeed = projectile.moveSpeed, isProjectile = true })
				end	
			else
				if projectile.name == "medusa_mystic_snake_projectile" or projectile.name == "earthshaker_echoslam" or projectile.name == "bounty_hunter_suriken_toss" or projectile.name == "wyvern_splinter_blast" then
					table.insert(FAIO.armletDamageInstanceTable, { instanceindex = projectile.name, time = FAIO.utilityRoundNumber((GameRules.GetGameTime() + projectileTiming - 0.035 - NetChannel.GetAvgLatency(Enum.Flow.FLOW_INCOMING)), 3), casttime = 0, type = "ability", damage = 250, projectileorigin = Entity.GetAbsOrigin(projectile.source), projectilestarttime = GameRules.GetGameTime(), projectilespeed = projectile.moveSpeed, isProjectile = true })
				end
			end
		end
	end

	if FAIO.ArcWardenEntity ~= nil then
		if projectile.source == FAIO.ArcWardenEntity and projectile.isAttack then
			FAIO.ArcWardenEntityProjectileCreate = GameRules.GetGameTime() - 0.035
		end
	end

	if projectile.source ~= Heroes.GetLocal() then return end
	if not projectile.isAttack then return end

	FAIO.AttackProjectileCreate = os.clock()

end

function FAIO.OnLinearProjectileCreate(projectile)
	
	if not projectile or not projectile.source then return end
	
	if projectile.name ~= "puck_illusory_orb" then return end
	
	FAIO.PuckOrbHitSim = {{projectile.origin, projectile.velocity}}

	
end

function FAIO.OnParticleDestroy(particle)

	if not particle then return end
	if not Heroes.GetLocal() then return end

	if particle.index  == FAIO.TPParticleIndex then
		FAIO.TPParticlePosition = Vector()
		FAIO.TPParticleTime = 0
		FAIO.TPParticleUnit = nil
	end

end


local SkipTick = os.clock()

function FAIO.OnDraw()
	if not Menu.IsEnabled(FAIO.optionEnable) then return end
	local myHero = Heroes.GetLocal()
        	if not myHero then return end
		if not Wrap.EIsAlive(myHero) then return end

	if NPC.GetUnitName(myHero) == "npc_dota_hero_morphling" then
		if Menu.IsEnabled(FAIO.optionHeroMorphlingKill) then
			FAIO.drawMorphlingKillIndicator(myHero)
		end
		if Menu.IsEnabled(FAIO.optionHeroMorphDrawBoard) then
			FAIO.MorphDrawBalanceBoard(myHero)
		end
	end

	if NPC.GetUnitName(myHero) == "npc_dota_hero_arc_warden" then
		FAIO.drawArcWardenPanel(myHero)
	end

	if NPC.GetUnitName(myHero) == "npc_dota_hero_furion" then
		if Menu.IsEnabled(FAIO.optionProphetDrawToggle) then
			FAIO.DrawProphetHelperSwitch()
		end
		if Menu.IsEnabled(FAIO.optionProphetDrawKS) or Menu.IsEnabled(FAIO.optionProphetDrawKSminimap) then
			FAIO.DrawProphetAwareness(myHero)
		end
	end

	if NPC.GetUnitName(myHero) == "npc_dota_hero_invoker" then
		if SkipTick <= os.clock() then
			FAIO.InvokerDraw(myHero)
			FAIO.InvokerDrawShort(myHero)
			SkipTick = os.clock() + 0.0028
		end
		FAIO.invokerDisplayDrawDisplay(myHero)
	end

	if NPC.GetUnitName(myHero) == "npc_dota_hero_phantom_assassin" then
		FAIO.DrawPADaggerSwitch()
	end

	if NPC.GetUnitName(myHero) == "npc_dota_hero_skywrath_mage" then
		FAIO.skywrathComboDrawDamage(myHero)
	end

	if NPC.GetUnitName(myHero) == "npc_dota_hero_necrolyte" then
		FAIO.necroComboDrawDamage(myHero)
	end

	if NPC.GetUnitName(myHero) == "npc_dota_hero_nevermore" then
		FAIO.SFComboDrawRequiemDamage(myHero)
	end

	if NPC.GetUnitName(myHero) == "npc_dota_hero_rattletrap" then
		FAIO.clockwerkDrawHookIndicator(myHero)
	end

	if NPC.GetUnitName(myHero) == "npc_dota_hero_windrunner" then
		FAIO.windrunnerDrawShackleIndicator(myHero)
	end

	if NPC.GetUnitName(myHero) == "npc_dota_hero_tinker" then
		FAIO.drawTinkerPanel(myHero)
	end

	if Menu.IsEnabled(FAIO.optionWardAwareness) then
		FAIO.drawWard(myHero)
	end

	FAIO.lastHitterDrawing(myHero)
end

function FAIO.OnPrepareUnitOrders(orders)

	if not orders then return true end
	if orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_TRAIN_ABILITY then return true end

	local myHero = Heroes.GetLocal()
    		if not myHero then return true end
    
	if Menu.IsEnabled(FAIO.optionHeroInvokerInstanceHelper) then
		if NPC.GetUnitName(myHero) == "npc_dota_hero_invoker" then
			FAIO.invokerProcessInstances(myHero, orders.order)
			return true
		end
	end
	
	if NPC.GetUnitName(myHero) == "npc_dota_hero_invoker" then
		local quas = NPC.GetAbility(myHero, "invoker_quas")
		local wex = NPC.GetAbility(myHero, "invoker_wex")
		local exort = NPC.GetAbility(myHero, "invoker_exort")
		if orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_NO_TARGET then
			if orders.ability == quas or orders.ability == wex or orders.ability == exort then
				FAIO.InvokerCaptureManualInstances = os.clock()
				return true
			end
		end
	end

	
	if Menu.IsEnabled(FAIO.optionLinkensManual) then
		if orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_TARGET then
			if orders.target ~= nil and Entity.IsHero(orders.target) and not Entity.IsSameTeam(myHero, orders.target) then
				if NPC.IsLinkensProtected(orders.target) then
					if FAIO.LinkensBreakerNew(myHero) ~= nil then
						Ability.CastTarget(NPC.GetItem(myHero, FAIO.LinkensBreakerNew(myHero), true), orders.target)
						return true
					end
				end
			end
		end
	end

	if Menu.IsEnabled(FAIO.optionItemVeilManual) then
		local veil = NPC.GetItem(myHero, "item_veil_of_discord", true)
		if veil and Ability.IsReady(veil) then
			if orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_TARGET then
				if orders.ability ~= nil and Ability.IsReady(orders.ability) and not Ability.IsChannelling(orders.ability) then
					if not Ability.IsPassive(orders.ability) and Ability.GetCastPoint(orders.ability) > 0.05 then
						if orders.target ~= nil and not Entity.IsDormant(orders.target) and Wrap.EIsAlive(orders.target) and not NPC.IsIllusion(orders.target) then
							Ability.CastPosition(veil, Entity.GetAbsOrigin(orders.target))
							if not NPC.HasItem(myHero, "item_soul_ring", true) then
								return true
							end
						end
					end
				end
			elseif orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_POSITION then
				if orders.ability ~= nil and Ability.IsReady(orders.ability) and not Ability.IsChannelling(orders.ability) then
					if not Ability.IsPassive(orders.ability) and Ability.GetCastPoint(orders.ability) > 0.05 then
						local mousePos = Input.GetWorldCursorPos()
						local checkTarget = nil
							for _, v in ipairs(Wrap.HInRadius(mousePos, 600, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY)) do
								if v and Entity.IsHero(v) and not Entity.IsDormant(v) and Wrap.EIsAlive(v) and not NPC.IsIllusion(v) then
									checkTarget = v
									break
								end
							end

						if checkTarget ~= nil then
							Ability.CastPosition(veil, Entity.GetAbsOrigin(checkTarget))
							if not NPC.HasItem(myHero, "item_soul_ring", true) then
								return true
							end
						end
					end
				end
			end						
		end
	end

	if Menu.IsEnabled(FAIO.optionItemSoulringManual) then
		local soulring = NPC.GetItem(myHero, "item_soul_ring", true)
		if soulring and Ability.IsReady(soulring) then
			if orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_POSITION or orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_TARGET or
			orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_NO_TARGET then
				if orders.ability ~= nil and Ability.IsReady(orders.ability) and not Ability.IsChannelling(orders.ability) then
					if not Ability.IsPassive(orders.ability) and Ability.GetManaCost(orders.ability) > 50 and Ability.GetCastPoint(orders.ability) > 0.05 then
						Ability.CastNoTarget(soulring)
						return true
					end
				end
			end
		end
	end
				
	if Menu.IsEnabled(FAIO.optionHeroMagnusAutoEmpower) then
		if NPC.GetUnitName(myHero) == "npc_dota_hero_magnataur" then
			if orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET then
				if orders.target and Wrap.EIsNPC(orders.target) and not Entity.IsSameTeam(myHero, orders.target) then
					FAIO.magnusAutoEmpower(myHero)
					return true
				end
			end
		end
	end

	if Menu.IsEnabled(FAIO.optionItemArmlet) then
		local armlet = NPC.GetItem(myHero, "item_armlet", true)
		if armlet and not NPC.HasModifier(myHero, "modifier_item_armlet_unholy_strength") then
			if orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_TOGGLE then
				if orders.ability == armlet and not FAIO.isArmletManuallyToggled then
					FAIO.isArmletManuallyToggled = true
					FAIO.isArmletManuallyToggledTime = GameRules.GetGameTime()
					return true
				end
			end
		end
	end

	if Menu.IsEnabled(FAIO.optionItemArmlet) and Menu.IsEnabled(FAIO.optionItemArmletRightClick) then
		local armlet = NPC.GetItem(myHero, "item_armlet", true)
		if armlet then
			if not FAIO.armletRightClickToggle then
				if orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET then
					if not Entity.IsSameTeam(myHero, orders.target) then
						if Menu.GetValue(FAIO.optionItemArmletRightClickStyle) > 0 then
							if os.clock() - FAIO.armletRightClickDoubleClick > 0.3 then
								FAIO.armletRightClickDoubleClick = os.clock()
								return true
							else
								if os.clock() - FAIO.armletRightClickDoubleClick > 0.05 then
									FAIO.armletRightClickToggle = true
									FAIO.armletRightClickToggleTimer = os.clock()
									return true
								end
							end
						else
							FAIO.armletRightClickToggle = true
							FAIO.armletRightClickToggleTimer = os.clock()
							return true
						end
					end
				end
			else
				if os.clock() - FAIO.armletRightClickToggleTimer > 0.6 then
					if orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION then
						FAIO.armletRightClickToggle = false
						return true
					end
				end
			end
		end
	end

	if Menu.IsEnabled(FAIO.optionItemArmlet) and Menu.IsEnabled(FAIO.optionItemArmletIllusion) then
		local armlet = NPC.GetItem(myHero, "item_armlet", true)
		if armlet and not Ability.GetToggleState(armlet) then
			local manta = NPC.GetItem(myHero, "item_manta", true)
			local ckUlt = NPC.GetAbility(myHero, "chaos_knight_phantasm")
			local terrorImg = NPC.GetAbility(myHero, "terrorblade_conjure_image")
			if manta or ckUlt or terrorImg then
				if orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_NO_TARGET then
					if orders.ability == manta or orders.ability == terrorImg then
						Ability.Toggle(armlet, false)
						FAIO.armletDelayer = os.clock() + 0.25
						return true
					elseif orders.ability == ckUlt then
						Ability.Toggle(armlet, false)
						FAIO.armletDelayer = os.clock() + 0.75
						return true
					end
				end
			end
			local lsUlt = NPC.GetAbility(myHero, "life_stealer_infest")
			if lsUlt then
				if orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_TARGET then
					if orders.ability == lsUlt then
						if orders.target and Entity.IsHero(orders.target) and Entity.IsSameTeam(myHero, orders.target) then
							Ability.Toggle(armlet, false)
							FAIO.armletDelayer = os.clock() + (math.max(((Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(orders.target)):Length2D() - 150), 0) / NPC.GetMoveSpeed(myHero)) + 0.25
							return true
						end
					end
				end
			end
		end
		if armlet and Ability.GetToggleState(armlet) then
			local lsConsume = NPC.GetAbility(myHero, "life_stealer_consume")
			if lsConsume and not Ability.IsHidden(lsConsume) then
				if orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_NO_TARGET then
					if orders.ability == lsConsume then
						FAIO.armletDelayer = os.clock() + 1.5
						return true
					end
				end
			end
		end
	end

	if FAIO.myUnitName == "npc_dota_hero_kunkka" and FAIO.kunkkaGhostshipTimer > os.clock() and FAIO.kunkkaXMarkCastTime > os.clock() then
		local Q = NPC.GetAbilityByIndex(myHero, 0)
		local Xreturn = NPC.GetAbility(myHero, "kunkka_return")
		local Ship = NPC.GetAbility(myHero, "kunkka_ghostship")
		if FAIO.kunkkaXMarkCastTime - os.clock() < 1 and FAIO.kunkkaXMarkCastTime - os.clock() > 0 and Ability.IsReady(Ship) then
			return false
		elseif FAIO.kunkkaGhostshipTimer - os.clock() < 2.25 and FAIO.kunkkaGhostshipTimer - os.clock() > 1.75 and Ability.IsReady(Q) then
			return false
		elseif FAIO.kunkkaGhostshipTimer - os.clock() < 0.80 and FAIO.kunkkaGhostshipTimer - os.clock() > 0.30 and not Ability.IsHidden(Xreturn) then
			return false
		elseif Q and Ability.IsInAbilityPhase(Q) then
			return false
		elseif Xreturn and Ability.IsInAbilityPhase(Xreturn) then
			return false
		elseif Ship and Ability.IsInAbilityPhase(Ship) then
			return false
		end
	end

	if FAIO.myUnitName == "npc_dota_hero_pudge" then
		if orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION or orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET then
			if FAIO.PudgeHookHit then
				FAIO.PudgeHookHit = false
			end
		end
	end

	if FAIO.myUnitName == "npc_dota_hero_tinker" then
		if Menu.IsEnabled(FAIO.optionHeroTinkerPushReset) then
			if FAIO.TinkerPusher then
				if orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION then
					FAIO.TinkerPusher = false
					if FAIO.TinkerPorted or FAIO.TinkerMarched > 0 then
						if orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION then
							FAIO.TinkerPorted = false
							FAIO.TinkerJungle = false
							FAIO.TinkerMarched = 0
							FAIO.TinkerJungleFarmPos = {}
							return true
						end
					else
						return true
					end
				end
			else
				if FAIO.TinkerPorted or FAIO.TinkerMarched > 0 then
					if orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION then
						FAIO.TinkerPorted = false
						FAIO.TinkerJungle = false
						FAIO.TinkerMarched = 0
						FAIO.TinkerJungleFarmPos = {}
						return true
					end
				end
			end
		end
		
		if Menu.IsEnabled(FAIO.optionHeroTinkerMiscFailUlt) then
			local ult = NPC.GetAbility(myHero, "tinker_rearm")
			if ult then
				if orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_NO_TARGET then
					if orders.ability and orders.ability == ult then
						if Ability.IsChannelling(ult) then
							return false
						end
						if Ability.SecondsSinceLastUse(ult) > -1 and Ability.SecondsSinceLastUse(ult) < 0.5 then
							return false
						end
					end
				end
			end
		end

		if Menu.IsEnabled(FAIO.optionHeroTinkerMiscFailRockets) then
			local rockets = NPC.GetAbilityByIndex(myHero, 1)
			if rockets then
				if orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_NO_TARGET then
					if orders.ability and orders.ability == rockets then
						if #Wrap.HeroesInRadius(myHero, 2499, Enum.TeamType.TEAM_ENEMY) < 1 then
							return false
						end
					end
				end
			end
		end

		if Menu.IsEnabled(FAIO.optionHeroTinkerMiscBlink) then
			local ult = NPC.GetAbility(myHero, "tinker_rearm")
			local blink = NPC.GetItem(myHero, "item_blink", true)
			if ult and blink then
				if orders.order == Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_NO_TARGET then
					if orders.ability and orders.ability == ult and Ability.IsCastable(ult, NPC.GetMana(myHero)) then
						local check = false
						for _, v in ipairs(Wrap.HeroesInRadius(myHero, 750, Enum.TeamType.TEAM_ENEMY)) do
							if v and Entity.IsHero(v) and not Entity.IsDormant(v) and not NPC.IsIllusion(v) then
								if NPC.IsEntityInRange(myHero, v, NPC.GetAttackRange(v) + 30) then
									if NPC.FindFacingNPC(v) == myHero then
										check = true
										break
									end
								end
								for ability, info in pairs(FAIO.RawDamageAbilityEstimation) do
									if NPC.HasAbility(v, ability) and Ability.IsInAbilityPhase(NPC.GetAbility(v, ability)) then
										local abilityRange = math.max(Ability.GetCastRange(NPC.GetAbility(v, ability)), info[2])
										local abilityRadius = info[3]
										if FAIO.dodgeIsTargetMe(myHero, v, abilityRadius, abilityRange) then
											check = true
											break
										end
									end
								end	
							end
						end
						if check then
							FAIO.TinkerPanicRearmBlink = os.clock()
							return true
						end
					end
				end
			end
		end					
	end
	
	return true

end

-- last Hitter
function FAIO.lastHitter(myHero)
	
	if not myHero then return end
	if not Menu.IsEnabled(FAIO.optionLastHitEnable) then return end

	local increasedAS = NPC.GetIncreasedAttackSpeed(myHero)

	local attackPoint = 0
	for i, v in pairs(FAIO.attackPointTable) do
		if i == NPC.GetUnitName(myHero) then
			attackPoint = v[1] / (1 + (increasedAS/100))
			break
		end
	end

	FAIO.lastHitterPredictDieTime(myHero)
	FAIO.lastHitterDieTimeCleaner(myHero, attackPoint)
	FAIO.lastHitterGetOrbSkill(myHero)
	FAIO.lastHitterGetOrbSkillHarass(myHero)
	FAIO.lastHitterExecuteLastHit(myHero, attackPoint)
			
end

function FAIO.lastHitterExecuteLastHit(myHero, attackPoint)

	if not myHero then return end

	local curTime = GameRules.GetGameTime()

	if Menu.IsEnabled(FAIO.optionLastHitDrawRange) and NPC.IsRanged(myHero) then
		if Menu.IsKeyDown(FAIO.optionLastHitKey) then
			Engine.ExecuteCommand("dota_range_display " .. NPC.GetAttackRange(myHero))
		else
			Engine.ExecuteCommand("dota_range_display 0")
		end
	end

	local lastHitTarget = nil
	local lastHitTime = 0
		for i, v in pairs(FAIO.lastHitCreepHPPredictionTime) do
			if i and Wrap.EIsNPC(i) and Wrap.EIsAlive(i) then
				if (not Entity.IsSameTeam(myHero, i) and (not NPC.IsTower(i) or (NPC.IsTower(i) and Entity.GetHealth(i) < 159))) or (Entity.IsSameTeam(myHero, i) and ((not NPC.IsTower(i) and Entity.GetHealth(i)/Entity.GetMaxHealth(i) < 0.5) or (NPC.IsTower(i) and Entity.GetHealth(i) < 159))) then
					if Menu.GetValue(FAIO.optionLastHitStyle) == 0 then
						if FAIO.utilityGetTableLength(FAIO.lastHitCreepHPPredictionTime) <= 1 then
							lastHitTarget = i
							lastHitTime = v
							break
						else
							local tempTable = {}

							for k, l in pairs(FAIO.lastHitCreepHPPredictionTime) do
								table.insert(tempTable, { l, k })
							end

							if #tempTable > 1 then
								if Wrap.EIsNPC(tempTable[1][2]) and Wrap.EIsNPC(tempTable[2][2]) then
									if math.abs(tempTable[2][1] - tempTable[1][1]) < NPC.GetAttackTime(myHero) + 0.1 then
										if not Entity.IsSameTeam(myHero, tempTable[1][2]) then
											lastHitTarget = tempTable[1][2]
											lastHitTime = tempTable[1][1]
										else
											if not Entity.IsSameTeam(myHero, tempTable[2][2]) then
												lastHitTarget = tempTable[2][2]
												lastHitTime = tempTable[2][1]
											else
												lastHitTarget = tempTable[1][2]
												lastHitTime = tempTable[1][1]
											end
										end
									else
										lastHitTarget = tempTable[1][2]
										lastHitTime = tempTable[1][1]
									end
								end
							end
						end
					elseif Menu.GetValue(FAIO.optionLastHitStyle) == 1 then
						if not Entity.IsSameTeam(myHero, i) then
							lastHitTarget = i
							lastHitTime = v
							break
						end
					elseif Menu.GetValue(FAIO.optionLastHitStyle) == 2 then
						if Entity.IsSameTeam(myHero, i) then
							lastHitTarget = i
							lastHitTime = v
							break
						end
					end
				end
			end
		end


	if Menu.IsKeyDown(FAIO.optionLastHitKey) then
		if FAIO.myUnitName == "npc_dota_hero_invoker" then
			FAIO.invokerProcessInstances(myHero, Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET)
		end

		if lastHitTarget == nil then 

			if Menu.IsEnabled(FAIO.optionLastHitAutoModeEnemy) then
				local searchRange = NPC.GetAttackRange(myHero)
					if FAIO.lastHitterOrbSkillEnemy ~= nil and Ability.GetName(FAIO.lastHitterOrbSkillEnemy) == "skywrath_mage_arcane_bolt" then
						searchRange = Ability.GetCastRange(FAIO.lastHitterOrbSkillEnemy)
					end
				if #Wrap.HeroesInRadius(myHero, searchRange, Enum.TeamType.TEAM_ENEMY) < 1 then
					if Menu.IsEnabled(FAIO.optionLastHitAutoModeMove) then
						if not NPC.IsPositionInRange(myHero, Input.GetWorldCursorPos(), Menu.GetValue(FAIO.optionLastHitAutoModeMoveRange), 0) then
							FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Input.GetWorldCursorPos())
							return
						else
							if FAIO.lastHitInAttackAnimation(myHero, attackPoint) == true then
								Player.HoldPosition(Players.GetLocal(), myHero, false)
								return
							end
						end
					else
						if FAIO.lastHitInAttackAnimation(myHero, attackPoint) == true then
							Player.HoldPosition(Players.GetLocal(), myHero, false)
							return
						end
					end
				else
					if not FAIO.lastHitBackswingChecker(myHero) then
						for _, v in ipairs(Wrap.HeroesInRadius(myHero, searchRange, Enum.TeamType.TEAM_ENEMY)) do
							if v then
								local target = FAIO.targetChecker(v)
								if target then
									if not FAIO.lastHitRoughCalcForHit(myHero) then
										if Menu.IsEnabled(FAIO.optionLastHitAutoModeEnemySave) then
											if FAIO.lastHitCheckCreepAggro(myHero) == false then
												if FAIO.lastHitterOrbSkillEnemy ~= nil and not NPC.HasState(target, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
													Ability.CastTarget(FAIO.lastHitterOrbSkillEnemy, target)
													return
												else
													FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", v, nil)
													return
												end
											else
												if Menu.IsEnabled(FAIO.optionLastHitAutoModeMove) then
													if not NPC.IsPositionInRange(myHero, Input.GetWorldCursorPos(), Menu.GetValue(FAIO.optionLastHitAutoModeMoveRange), 0) then
														FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Input.GetWorldCursorPos())
														return
													else
														if FAIO.lastHitInAttackAnimation(myHero, attackPoint) == true then
															Player.HoldPosition(Players.GetLocal(), myHero, false)
															return
														end
													end
												else
													if FAIO.lastHitInAttackAnimation(myHero, attackPoint) == true then
														Player.HoldPosition(Players.GetLocal(), myHero, false)
														return
													end
												end
											end	
										else
											if FAIO.lastHitterOrbSkillEnemy ~= nil and not NPC.HasState(target, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
												Ability.CastTarget(FAIO.lastHitterOrbSkillEnemy, target)
												return
											else
												FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", v, nil)
												return
											end
										end
									else
										if Menu.IsEnabled(FAIO.optionLastHitAutoModeMove) then
											if not NPC.IsPositionInRange(myHero, Input.GetWorldCursorPos(), Menu.GetValue(FAIO.optionLastHitAutoModeMoveRange), 0) then
												FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Input.GetWorldCursorPos())
												return
											else
												if FAIO.lastHitInAttackAnimation(myHero, attackPoint) == true then
													Player.HoldPosition(Players.GetLocal(), myHero, false)
													return
												end
											end
										else
											if FAIO.lastHitInAttackAnimation(myHero, attackPoint) == true then
												Player.HoldPosition(Players.GetLocal(), myHero, false)
												return
											end
										end
									end
								else
									if Menu.IsEnabled(FAIO.optionLastHitAutoModeMove) then
										if not NPC.IsPositionInRange(myHero, Input.GetWorldCursorPos(), Menu.GetValue(FAIO.optionLastHitAutoModeMoveRange), 0) then
											FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Input.GetWorldCursorPos())
											return
										else
											if FAIO.lastHitInAttackAnimation(myHero, attackPoint) == true then
												Player.HoldPosition(Players.GetLocal(), myHero, false)
												return
											end
										end
									else
										if FAIO.lastHitInAttackAnimation(myHero, attackPoint) == true then
											Player.HoldPosition(Players.GetLocal(), myHero, false)
											return
										end
									end
								end
							else
								if Menu.IsEnabled(FAIO.optionLastHitAutoModeMove) then
									if not NPC.IsPositionInRange(myHero, Input.GetWorldCursorPos(), Menu.GetValue(FAIO.optionLastHitAutoModeMoveRange), 0) then
										FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Input.GetWorldCursorPos())
										return
									else
										if FAIO.lastHitInAttackAnimation(myHero, attackPoint) == true then
											Player.HoldPosition(Players.GetLocal(), myHero, false)
											return
										end
									end
								else
									if FAIO.lastHitInAttackAnimation(myHero, attackPoint) == true then
										Player.HoldPosition(Players.GetLocal(), myHero, false)
										return
									end
								end
							end
						end
					else
						if Menu.IsEnabled(FAIO.optionLastHitAutoModeMove) then
							if not NPC.IsPositionInRange(myHero, Input.GetWorldCursorPos(), Menu.GetValue(FAIO.optionLastHitAutoModeMoveRange), 0) then
								FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Input.GetWorldCursorPos())
								return
							else
								if FAIO.lastHitInAttackAnimation(myHero, attackPoint) == true then
									Player.HoldPosition(Players.GetLocal(), myHero, false)
									return
								end
							end
						else
							if FAIO.lastHitInAttackAnimation(myHero, attackPoint) == true then
								Player.HoldPosition(Players.GetLocal(), myHero, false)
								return
							end
						end
					end
				end
			else
				if Menu.IsEnabled(FAIO.optionLastHitAutoModeMove) then
					if not NPC.IsPositionInRange(myHero, Input.GetWorldCursorPos(), Menu.GetValue(FAIO.optionLastHitAutoModeMoveRange), 0) then
						FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Input.GetWorldCursorPos())
						return
					else
						if FAIO.lastHitInAttackAnimation(myHero, attackPoint) == true then
							Player.HoldPosition(Players.GetLocal(), myHero, false)
							return
						end
					end
				else
					if FAIO.lastHitInAttackAnimation(myHero, attackPoint) == true then
						Player.HoldPosition(Players.GetLocal(), myHero, false)
						return
					end
				end
			end
		else
			local target = lastHitTarget
			local hitTime = FAIO.utilityRoundNumber((lastHitTime + (Menu.GetValue(FAIO.optionLastHitOffset) / 20) - NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)), 3)
			if Wrap.EIsNPC(target) and Wrap.EIsAlive(target) and not NPC.HasState(target, Enum.ModifierState.MODIFIER_STATE_INVULNERABLE) then
				if curTime > hitTime - FAIO.lastHitterTimingOffsetter(myHero, target) then
					if not FAIO.lastHitInAttackAnimation(myHero, attackPoint) then
						if FAIO.lastHitterOrbSkill ~= nil and not Entity.IsSameTeam(myHero, target) and not NPC.IsTower(target) then
							Ability.CastTarget(FAIO.lastHitterOrbSkill, target)
							return
						else
							Player.AttackTarget(Players.GetLocal(), myHero, target, false)
							return
						end
					end	
				else
					if FAIO.lastHitInAttackAnimation(myHero, attackPoint) == true then
						if (GameRules.GetGameTime() - (os.clock() - FAIO.AttackAnimationCreate)) + FAIO.lastHitterTimingOffsetter(myHero, target) < hitTime then
							Player.HoldPosition(Players.GetLocal(), myHero, false)
							return
						end
					else
						if Menu.IsEnabled(FAIO.optionLastHitAutoModeMove) then
							if hitTime - curTime - FAIO.lastHitterTimingOffsetter(myHero, target) > 0.15 then
								if not NPC.IsPositionInRange(myHero, Input.GetWorldCursorPos(), Menu.GetValue(FAIO.optionLastHitAutoModeMoveRange), 0) then
									FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Input.GetWorldCursorPos())
									return
								end
							end
						end
					end
				end	
			end
		end
	end
	
	return

end

function FAIO.lastHitterGetOrbSkill(myHero)

	if not myHero then return end

	local orbSkill = nil
	if Menu.IsEnabled(FAIO.optionLastHitOrb) then
		local orbSkillTable = {
			npc_dota_hero_clinkz = "clinkz_searing_arrows",
			npc_dota_hero_obsidian_destroyer = "obsidian_destroyer_arcane_orb",
			npc_dota_hero_silencer = "silencer_glaives_of_wisdom"
				}

		if orbSkillTable[FAIO.myUnitName] ~= nil then
			orbSkill = NPC.GetAbility(myHero, orbSkillTable[FAIO.myUnitName])
		end

		if orbSkill ~= nil then
			if Ability.GetLevel(orbSkill) < 1 then
				orbSkill = nil
			elseif (NPC.GetMana(myHero) / NPC.GetMaxMana(myHero)) * 100 < Menu.GetValue(FAIO.optionLastHitOrbMana) then
				orbSkill = nil
			elseif FAIO.heroCanCastSpells(myHero, target) == false then
				orbSkill = nil
			elseif not Ability.IsReady(orbSkill) then
				orbSkill = nil
			elseif not Ability.IsCastable(orbSkill, NPC.GetMana(myHero)) then
				orbSkill = nil
			end
		end
	end

	if orbSkill then
		FAIO.lastHitterOrbSkill = orbSkill
	else
		FAIO.lastHitterOrbSkill = nil
	end

	return	
end

function FAIO.lastHitterGetOrbSkillHarass(myHero)

	if not myHero then return end

	local orbSkill = nil
	if Menu.IsEnabled(FAIO.optionLastHitOrb) then
		local orbSkillTable = {
			npc_dota_hero_clinkz = "clinkz_searing_arrows",
			npc_dota_hero_drow_ranger = "drow_ranger_frost_arrows",
			npc_dota_hero_enchantress = "enchantress_impetus",
			npc_dota_hero_huskar = "huskar_burning_spear",
			npc_dota_hero_obsidian_destroyer = "obsidian_destroyer_arcane_orb",
			npc_dota_hero_silencer = "silencer_glaives_of_wisdom",
			npc_dota_hero_viper = "viper_poison_attack",
			npc_dota_hero_skywrath_mage = "skywrath_mage_arcane_bolt"
				}

		if orbSkillTable[FAIO.myUnitName] ~= nil then
			orbSkill = NPC.GetAbility(myHero, orbSkillTable[FAIO.myUnitName])
		end

		if orbSkill ~= nil then
			if Ability.GetLevel(orbSkill) < 1 then
				orbSkill = nil
			elseif (NPC.GetMana(myHero) / NPC.GetMaxMana(myHero)) * 100 < Menu.GetValue(FAIO.optionLastHitOrbMana) then
				orbSkill = nil
			elseif FAIO.heroCanCastSpells(myHero, target) == false then
				orbSkill = nil
			elseif not Ability.IsReady(orbSkill) then
				orbSkill = nil
			elseif not Ability.IsCastable(orbSkill, NPC.GetMana(myHero)) then
				orbSkill = nil
			end
		end
	end

	if orbSkill then
		FAIO.lastHitterOrbSkillEnemy = orbSkill
	else
		FAIO.lastHitterOrbSkillEnemy = nil
	end

	return	
end

function FAIO.lastHitCheckCreepAggro(myHero)

	if not myHero then return false end

	if FAIO.lastHitterOrbSkillEnemy ~= nil then return false end
	
	local creepsAround = Wrap.UnitsInRadius(myHero, 500, Enum.TeamType.TEAM_ENEMY)
		if #creepsAround < 1 then return false end

	for _, v in ipairs(creepsAround) do
		if v and Wrap.EIsNPC(v) and Wrap.EIsAlive(v) then
			if NPC.IsLaneCreep(v) and not NPC.IsWaitingToSpawn(v) and NPC.GetUnitName(v) ~= "npc_dota_neutral_caster" then
				if v ~= nil then
					return true
				end
			end
		end
	end

	return false

end

function FAIO.lastHitRoughCalcForHit(myHero)

	if not myHero then return false end

	local attackTime = NPC.GetAttackTime(myHero)

	if next(FAIO.lastHitCreepHPPrediction) == nil then return false end

	for i, v in pairs(FAIO.lastHitCreepHPPrediction) do
		if i and Wrap.EIsNPC(i) and Wrap.EIsAlive(i) then
			local creepHP = Entity.GetHealth(i)
			local attackerCount = FAIO.lastHitGetAttackerCount(myHero, i)
			if creepHP < math.ceil(2 * attackTime) * attackerCount * 18 then
				return true
			end
		end
	end

	return false

end

function FAIO.lastHitGetAttackerCount(myHero, target)

	if not myHero then return 0 end
	if not target then return 0 end

	local count = 0
	for i, v in pairs(FAIO.lastHitCreepHPPrediction) do
		if i and Wrap.EIsNPC(i) and Wrap.EIsAlive(i) then
			if i == target then
				local temp = {}
				for k, l in ipairs(v) do
					if not FAIO.utilityIsInTable(temp, l[3]) and GameRules.GetGameTime() > l[1] then
						table.insert(temp, l[3])
					end
				end
				count = #temp or 0
			end
		end
	end
				
	return count

end

function FAIO.lastHitBackswingChecker(myHero)

	if not myHero then return false end

	local increasedAS = NPC.GetIncreasedAttackSpeed(myHero)
	local attackTime = NPC.GetAttackTime(myHero)
	local attackPoint
	local attackBackSwing
	for i, v in pairs(FAIO.attackPointTable) do
		if i == NPC.GetUnitName(myHero) then
			attackPoint = v[1] / (1 + (increasedAS/100))
			attackBackSwing = v[2] / (1 + (increasedAS/100))
			break
		end
	end

	local idleTime = attackTime - attackPoint - attackBackSwing

	if NPC.IsRanged(myHero) then
		if FAIO.AttackProjectileCreate > 0 then
			if os.clock() > FAIO.AttackAnimationCreate and os.clock() < FAIO.AttackProjectileCreate + attackBackSwing + idleTime then
				return true
			else
				return false
			end
		end
	else
		if FAIO.AttackParticleCreate > 0 then
			if NPC.HasItem(myHero, "item_echo_sabre", true) then
				if Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_echo_sabre", true)) > -1 and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_echo_sabre", true)) < (attackPoint / 1.49) + 0.15 then
					return false
				else
					if os.clock() > FAIO.AttackAnimationCreate and os.clock() < FAIO.AttackParticleCreate + attackBackSwing + idleTime then
						return true
					else
						return false
					end
				end
			else
				if os.clock() > FAIO.AttackAnimationCreate and os.clock() < FAIO.AttackParticleCreate + attackBackSwing + idleTime then
					return true
				else
					return false
				end
			end
		end
	end

	return false

end

function FAIO.lastHitterTimingOffsetter(myHero, target)

	if not myHero then return 0 end
	if not target then return 0 end
	if target and not Wrap.EIsNPC(target) then return 0 end

	local increasedAS = NPC.GetIncreasedAttackSpeed(myHero)

	local attackPoint = 0
	local projectileSpeed = 0
	for i, v in pairs(FAIO.attackPointTable) do
		if i == NPC.GetUnitName(myHero) then
			if NPC.IsRanged(myHero) then
				attackPoint = v[1] / (1 + (increasedAS/100))
				projectileSpeed = v[3]
				break
			else
				attackPoint = v[1] / (1 + (increasedAS/100))
				projectileSpeed = 0
				break
			end
		end
	end

	local faceTime = math.max(NPC.GetTimeToFace(myHero, target) - ((0.033 * math.pi / NPC.GetTurnRate(myHero) / 180) * 11.5), 0)

	local myAttackRange = NPC.GetAttackRange(myHero)
	local myMovementSpeed = NPC.GetMoveSpeed(myHero)
	local distanceToTarget = (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(target)):Length2D()
	local projectileDistance = distanceToTarget - math.max(distanceToTarget - (myAttackRange + NPC.GetHullRadius(myHero) + NPC.GetHullRadius(target)), 0)
	local moveDistance = distanceToTarget - projectileDistance

	local projectileOffset = 0
		if projectileSpeed > 0 then
			projectileOffset = (projectileDistance - 24) / projectileSpeed
		end

	local moveTime = 0
		if moveDistance > 0 then
			moveTime = moveDistance / myMovementSpeed
		end

	local overallOffset = FAIO.utilityRoundNumber(attackPoint + projectileOffset + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) + faceTime + moveTime, 3)

	return overallOffset or 0

end

function FAIO.myCreepDamageAdjuster(myHero, target)

	if not myHero then return 0 end

	local quelling = NPC.GetItem(myHero, "item_quelling_blade", true)

	local minCreepDamage = NPC.GetMinDamage(myHero)
	local bonusCreepDamage = 0
		if quelling then
			if NPC.IsRanged(myHero) then
				bonusCreepDamage = 7
			else
				bonusCreepDamage = 24
			end
		end

	local orbSkill = FAIO.lastHitterOrbSkill
	if orbSkill ~= nil then
		if not Entity.IsSameTeam(myHero, target) and not NPC.IsTower(target) then
			local orbSkillName = Ability.GetName(orbSkill)
			if orbSkillName == "clinkz_searing_arrows" then
				minCreepDamage = minCreepDamage + (20 + 10 * Ability.GetLevel(orbSkill))
				if NPC.HasAbility(myHero, "special_bonus_unique_clinkz_1") then
					if Ability.GetLevel(NPC.GetAbility(myHero, "special_bonus_unique_clinkz_1")) > 0 then
						minCreepDamage = minCreepDamage + 30
					end
				end
			elseif orbSkillName == "obsidian_destroyer_arcane_orb" then
				local bonusDMG = (0.05 + (0.01 * Ability.GetLevel(orbSkill))) * NPC.GetMana(myHero)
				local bonusPureDMG = bonusDMG * (1 + (1 - NPC.GetDamageMultiplierVersus(myHero, target)) + (1 - NPC.GetArmorDamageMultiplier(target)))
				minCreepDamage = minCreepDamage + bonusPureDMG
			elseif orbSkillName == "silencer_glaives_of_wisdom" then
				local myInt = Hero.GetIntellectTotal(myHero)
				local bonusDMG = 0.15 * Ability.GetLevel(orbSkill) * myInt
					if NPC.HasAbility(myHero, "special_bonus_unique_silencer_3") then
						if Ability.GetLevel(NPC.GetAbility(myHero, "special_bonus_unique_silencer_3")) > 0 then
							bonusDMG = (0.2 + 0.15 * Ability.GetLevel(orbSkill)) * myInt
						end
					end
				local bonusPureDMG = bonusDMG * (1 + (1 - NPC.GetDamageMultiplierVersus(myHero, target)) + (1 - NPC.GetArmorDamageMultiplier(target)))
				minCreepDamage = minCreepDamage + bonusPureDMG
			end
		end
	end

	if NPC.HasModifier(myHero, "modifier_storm_spirit_overload") then
		local overload = NPC.GetAbility(myHero, "storm_spirit_overload")
		local bonus = 0
		if overload and Ability.GetLevel(overload) > 0 then
			bonus = Ability.GetDamage(overload)
		end
		local bonusTrue = (1 - NPC.GetMagicalArmorValue(target)) * bonus + bonus * (Hero.GetIntellectTotal(myHero) / 14 / 100)
		minCreepDamage = minCreepDamage + bonusTrue
	end

	local overallCreepDamage = minCreepDamage + bonusCreepDamage

	return math.floor(overallCreepDamage)

end

function FAIO.lastHitInAttackAnimation(myHero, attackPoint)

	if not myHero then return false end
	if not attackPoint then return false end
		if attackPoint == 0 then return false end

	if os.clock() >= FAIO.AttackAnimationCreate - 0.035 then
		if os.clock() <= (FAIO.AttackAnimationCreate + attackPoint + 0.075) then
			return true
		end
	end

	return false

end

function FAIO.lastHitterDrawing(myHero)

	if not myHero then return end
	if not Menu.IsEnabled(FAIO.optionLastHitDrawCreepEnable) then return end
	
	if next(FAIO.lastHitCreepHPPredictionTime) == nil then return end

	if Menu.IsEnabled(FAIO.optionLastHitDrawCreepTimer) then
		local imageHandle = FAIO.lastHitterKillableImage
			if imageHandle == nil then
				imageHandle = Renderer.LoadImage("resource/flash3/images/heroes/selection/fav_heart.png")
				FAIO.lastHitterKillableImage = imageHandle
			end
		for i, v in pairs(FAIO.lastHitCreepHPPredictionTime) do
			local target = i
			local dieTime = v
			if target and Wrap.EIsNPC(target) then
				local pos = Entity.GetAbsOrigin(target)
				local posY = NPC.GetHealthBarOffset(target)
					pos:SetZ(pos:GetZ() + posY)	
				local x, y, visible = Renderer.WorldToScreen(pos)
				if Menu.GetValue(FAIO.optionLastHitDrawStyle) < 1 then
					if visible then
						if dieTime - GameRules.GetGameTime() > FAIO.lastHitterTimingOffsetter(myHero, target) then
							Renderer.SetDrawColor(255,215,0,200)
							Renderer.DrawImage(imageHandle, x-20, y-49, 40, 40)
						else
							Renderer.SetDrawColor(50,205,50,200)
							Renderer.DrawImage(imageHandle, x-20, y-49, 40, 40)
						end
					end
				else
					if not Entity.IsSameTeam(myHero, i) then
						if visible then
							if dieTime - GameRules.GetGameTime() > FAIO.lastHitterTimingOffsetter(myHero, target) then
								Renderer.SetDrawColor(255,215,0,200)
								Renderer.DrawImage(imageHandle, x-20, y-49, 40, 40)
							else
								Renderer.SetDrawColor(50,205,50,200)
								Renderer.DrawImage(imageHandle, x-20, y-49, 40, 40)
							end
						end
					end
				end
			end
		end
	end

end

function FAIO.lastHitterPredictDieTime(myHero)

	if not myHero then return end

	if next(FAIO.lastHitCreepHPPredictionTime) ~= nil then
		table.sort(FAIO.lastHitCreepHPPredictionTime, function(a, b)
       			return a < b
    		end)
	end

	for target, attackTable in pairs(FAIO.lastHitCreepHPPrediction) do
		if attackTable then
			if target and Wrap.EIsNPC(target) and Wrap.EIsAlive(target) then
				local creepHP = math.ceil(Entity.GetHealth(target) + NPC.GetHealthRegen(target))
				local myAttackDMG = math.floor(math.floor(NPC.GetDamageMultiplierVersus(myHero, target) * ((FAIO.myCreepDamageAdjuster(myHero, target) + NPC.GetBonusDamage(myHero)) * NPC.GetArmorDamageMultiplier(target))) * 0.975)
					if Menu.IsEnabled(FAIO.optionLastHitPredict) then
						local avgDmgGap = math.floor((NPC.GetTrueMaximumDamage(myHero) - NPC.GetTrueDamage(myHero)) / 2)
						myAttackDMG = math.floor(math.floor(NPC.GetDamageMultiplierVersus(myHero, target) * ((FAIO.myCreepDamageAdjuster(myHero, target) + NPC.GetBonusDamage(myHero) + avgDmgGap) * NPC.GetArmorDamageMultiplier(target))) * 0.975)
					end
				table.sort(attackTable, function(a, b)
       					return a[1] < b[1]
    				end)

				for i, info in ipairs(attackTable) do
					if info then
						local hitTime = info[1]
						local hitDamage = info[2]
						if hitTime > GameRules.GetGameTime() and math.abs(hitTime - GameRules.GetGameTime()) > 0.15 then
							creepHP = creepHP - hitDamage
							if FAIO.lastHitCreepHPPredictionTime[target] == nil then
								local offSet = FAIO.lastHitGetAttackerCount(myHero, target)
									if Menu.IsEnabled(FAIO.optionLastHitPredict) then
										offSet = math.ceil(offSet / 2)
									end
								if creepHP > myAttackDMG and creepHP - myAttackDMG <= math.ceil(math.ceil(0.025 * myAttackDMG) + offSet) then
									if hitTime > GameRules.GetGameTime() and hitTime - GameRules.GetGameTime() < FAIO.lastHitterTimingOffsetter(myHero, target) * 1.25 then
										FAIO.lastHitCreepHPPredictionTime[target] = hitTime + 0.075
										break
										return
									end
								elseif creepHP <= myAttackDMG then
									if hitTime > GameRules.GetGameTime() and hitTime - GameRules.GetGameTime() < FAIO.lastHitterTimingOffsetter(myHero, target) * 1.25 then
										FAIO.lastHitCreepHPPredictionTime[target] = hitTime + 0.075
										break
										return
									end
								end
							else
								if creepHP <= myAttackDMG then
									if hitTime + 0.075 < FAIO.lastHitCreepHPPredictionTime[target] then
										FAIO.lastHitCreepHPPredictionTime[target] = hitTime + 0.075
										break
										return
									end
								end
							end	
						end
					end
				end
		
				


			end
		end
	end

	for i, v in ipairs(Wrap.UnitsInRadius(myHero, 1000, Enum.TeamType.TEAM_BOTH)) do
		if v and Wrap.EIsNPC(v) and not Entity.IsDormant(v) and not NPC.IsWaitingToSpawn(v) and NPC.GetUnitName(v) ~= "npc_dota_neutral_caster" and (NPC.IsCreep(v) or NPC.IsTower(v)) then
			local creepHP = Entity.GetHealth(v) + NPC.GetHealthRegen(v)
			local myAttackDMG = NPC.GetDamageMultiplierVersus(myHero, v) * ((FAIO.myCreepDamageAdjuster(myHero, v) + NPC.GetBonusDamage(myHero)) * NPC.GetArmorDamageMultiplier(v))
			if creepHP < myAttackDMG then
				FAIO.lastHitCreepHPPredictionTime[v] = GameRules.GetGameTime()
			end
		end
	end
	
end

function FAIO.lastHitterDieTimeCleaner(myHero, attackPoint)

	if next(FAIO.lastHitCreepHPPredictionTime) == nil then return end

	if not myHero then
		FAIO.lastHitCreepHPPredictionTime = {}
	end

	if not Wrap.EIsAlive(myHero) then
		FAIO.lastHitCreepHPPredictionTime = {}
	end

	if #Wrap.UnitsInRadius(myHero, 1000, Enum.TeamType.TEAM_BOTH) <= 1 then
		FAIO.lastHitCreepHPPredictionTime = {}
	end

	if next(FAIO.lastHitCreepHPPredictionTime) ~= nil then
		for i, v in pairs(FAIO.lastHitCreepHPPredictionTime) do
			local target = i
			local dieTime = v
			if not target then
				FAIO.lastHitCreepHPPredictionTime[i] = nil
				break
				return
			end
			if target and Wrap.EIsNPC(target) and not Wrap.EIsAlive(target) then
				FAIO.lastHitCreepHPPredictionTime[i] = nil
				break
				return
			end
			if GameRules.GetGameTime() > dieTime then
				FAIO.lastHitCreepHPPredictionTime[i] = nil
				break
				return
			end
		end
	end	

end

function FAIO.lastHitterGetTarget(myHero, creep)

	if not myHero then return end
	if not creep then return end

	if not Wrap.EIsNPC(creep) then return end
	if not NPC.IsLaneCreep(creep) then return end
	if NPC.IsRanged(creep) then return end
	if not Wrap.EIsAlive(creep) then return end
	
	local creepRotation = Entity.GetRotation(creep):GetForward():Normalized()
	
	local targets = Wrap.UnitsInRadius(creep, 148, Enum.TeamType.TEAM_ENEMY)
		if next(targets) == nil then return end
		if #targets < 1 then return end

	if #targets == 1 then
		if Wrap.EIsNPC(targets[1]) and NPC.IsLaneCreep(targets[1]) then
			return targets[1]
		end
	else
		local adjustedHullSize = 20
		for i, v in ipairs(targets) do
			if v and Wrap.EIsNPC(v) and NPC.IsLaneCreep(v) and Wrap.EIsAlive(v) then
				local vpos = Entity.GetAbsOrigin(v)
				local vposZ = vpos:GetZ()
				local pos = Entity.GetAbsOrigin(creep)
				for i = 1, 9 do
					local searchPos = pos + creepRotation:Scaled(25*(9-i))
						searchPos:SetZ(vposZ)
					if NPC.IsPositionInRange(v, searchPos, adjustedHullSize, 0) then
						return v
					end
				end
			end
		end
	end

	return

end

function FAIO.utilityRoundNumber(number, digits)

	if not number then return end

  	local mult = 10^(digits or 0)
  	return math.floor(number * mult + 0.5) / mult

end

function FAIO.utilityGetTableLength(table)

	if not table then return 0 end
	if next(table) == nil then return 0 end

	local count = 0
	for i, v in pairs(table) do
		count = count + 1
	end

	return count

end

function FAIO.utilityIsInTable(table, arg)

	if not table then return false end
	if not arg then return false end
	if next(table) == nil then return false end

	for i, v in pairs(table) do
		if i == arg then
			return true
		end
		if type(v) ~= 'table' and v == arg then
			return true
		end
	end

	return false

end

-- utility functions
function FAIO.heroSupported(myHero)

	if not myHero then return end
	local supportedHeroList = FAIO.heroList

	for _, heroName in pairs(supportedHeroList) do
		if heroName == NPC.GetUnitName(myHero) then
			return true
		end
	end
	return false
end

function FAIO.setOrderItem(printed)

	FAIO.ItemCastOrder = {
        	{Menu.GetValue(FAIO.optionItemVeil), "item_veil_of_discord", "position"},
        	{Menu.GetValue(FAIO.optionItemHex), "item_sheepstick", "target"},
        	{Menu.GetValue(FAIO.optionItemBlood), "item_bloodthorn", "target"},
        	{Menu.GetValue(FAIO.optionItemeBlade), "item_ethereal_blade", "target"},
        	{Menu.GetValue(FAIO.optionItemOrchid),"item_orchid", "target"},
        	{Menu.GetValue(FAIO.optionItemAtos),"item_rod_of_atos", "target"},
		{Menu.GetValue(FAIO.optionItemAbyssal),"item_abyssal_blade", "target"},
		{Menu.GetValue(FAIO.optionItemHalberd),"item_heavens_halberd", "target"},
		{Menu.GetValue(FAIO.optionItemShivas),"item_shivas_guard", "no target"},
		{Menu.GetValue(FAIO.optionItemDagon),"item_dagon", "target"},
		{Menu.GetValue(FAIO.optionItemDagon),"item_dagon_2", "target"},
		{Menu.GetValue(FAIO.optionItemDagon),"item_dagon_3", "target"},
		{Menu.GetValue(FAIO.optionItemDagon),"item_dagon_4", "target"},
		{Menu.GetValue(FAIO.optionItemDagon),"item_dagon_5", "target"},
		{Menu.GetValue(FAIO.optionItemUrn),"item_urn_of_shadows", "target"},
		{Menu.GetValue(FAIO.optionItemMedallion),"item_medallion_of_courage", "target"},
		{Menu.GetValue(FAIO.optionItemCrest),"item_solar_crest", "target"},
		{Menu.GetValue(FAIO.optionItemDiffusal),"item_diffusal_blade", "target"},
		{Menu.GetValue(FAIO.optionItemSpirit),"item_spirit_vessel", "target"},
		{Menu.GetValue(FAIO.optionItemNull),"item_nullifier", "target"},
    				}

    	table.sort(FAIO.ItemCastOrder, function(a, b)
        	return a[1] > b[1]
    	end)
	Log.Write(".....Item Cast Order....")
	local printed = false
		if not printed then
			for k,v in ipairs(FAIO.ItemCastOrder) do
			Log.Write(v[1]..':'..v[2])
			printed = true
			end
		end
end			

function FAIO.setOrderLinkens(printed)
	
	FAIO.LinkensBreakerItemOrder = {
        	{Menu.GetValue(FAIO.optionLinkensForce), "item_force_staff"},
        	{Menu.GetValue(FAIO.optionLinkensEul), "item_cyclone"},
        	{Menu.GetValue(FAIO.optionLinkensHalberd), "item_heavens_halberd"},
        	{Menu.GetValue(FAIO.optionLinkensHex), "item_sheepstick"},
        	{Menu.GetValue(FAIO.optionLinkensBlood),"item_bloodthorn"},
        	{Menu.GetValue(FAIO.optionLinkensOrchid),"item_orchid"},
		{Menu.GetValue(FAIO.optionLinkensDiffusal),"item_diffusal_blade", "target"},
		{Menu.GetValue(FAIO.optionLinkensPike),"item_hurricane_pike"}
    				}

    	table.sort(FAIO.LinkensBreakerItemOrder, function(a, b)
        	return a[1] > b[1]
    	end)
	Log.Write(".....Linkens Breaker Priorization Order....")
	local printed = false
		if not printed then
			for k,v in ipairs(FAIO.LinkensBreakerItemOrder) do
			Log.Write(v[1]..':'..v[2])
			printed = true
			end
		end			
	
end

function FAIO.OnMenuOptionChange(option, old, new)

    	if option == FAIO.optionItemVeil or
		option == FAIO.optionItemHex or
		option == FAIO.optionItemBlood or
		option == FAIO.optionItemeBlade or 
		option == FAIO.optionItemOrchid or 
		option == FAIO.optionItemAtos or 
		option == FAIO.optionItemAbyssal or 
		option == FAIO.optionItemHalberd or 
		option == FAIO.optionItemShivas or 
		option == FAIO.optionItemDagon or 
		option == FAIO.optionItemUrn or
		option == FAIO.optionItemManta or
		option == FAIO.optionItemMjollnir or
		option == FAIO.optionItemMedallion or
		option == FAIO.optionItemCrest or
		option == FAIO.optionItemDiffusal or
		option == FAIO.optionItemSpirit or
		option == FAIO.optionItemNull then
			FAIO.setOrderItem(false)
	end
	
	if option == FAIO.optionLinkensForce or
		option == FAIO.optionLinkensEul or
		option == FAIO.optionLinkensHalberd or
		option == FAIO.optionLinkensHex or
		option == FAIO.optionLinkensBlood or
		option == FAIO.optionLinkensOrchid or
		option == FAIO.optionLinkensDiffusal or
		option == FAIO.optionLinkensPike then
        		FAIO.setOrderLinkens(false)
    	end

	if option == FAIO.invokerDisplaySizeOption then
        	FAIO.invokerDisplayInit()
    	end

	if option == FAIO.invokerPanelSizeOption then
		FAIO.invokerPanelInit()
    	end

	if option == FAIO.dodgeItOptionTable[1] or 
		option == FAIO.dodgeItOptionTable[2] or
		option == FAIO.dodgeItOptionTable[3] or
		option == FAIO.dodgeItOptionTable[4] or
		option == FAIO.dodgeItOptionTable[5] or
		option == FAIO.dodgeItOptionTable[6] or
		option == FAIO.dodgeItOptionTable[7] then
		FAIO.dodgeItReadyTable = {}
	end

end

function FAIO.targetChecker(genericEnemyEntity)

	local myHero = Heroes.GetLocal()
		if not myHero then return end

	if genericEnemyEntity and not Entity.IsDormant(genericEnemyEntity) and not NPC.IsIllusion(genericEnemyEntity) and Entity.GetHealth(genericEnemyEntity) > 0 then

		if Menu.IsEnabled(FAIO.optionTargetCheckAM) then
			if NPC.GetUnitName(genericEnemyEntity) == "npc_dota_hero_antimage" and NPC.HasItem(genericEnemyEntity, "item_ultimate_scepter", true) and NPC.HasModifier(genericEnemyEntity, "modifier_antimage_spell_shield") and Ability.IsReady(NPC.GetAbility(genericEnemyEntity, "antimage_spell_shield")) then
				return
			end
		end
		if Menu.IsEnabled(FAIO.optionTargetCheckLotus) then
			if NPC.HasModifier(genericEnemyEntity, "modifier_item_lotus_orb_active") then
				return
			end
		end
		if Menu.IsEnabled(FAIO.optionTargetCheckBlademail) then
			if NPC.HasModifier(genericEnemyEntity, "modifier_item_blade_mail_reflect") and Entity.GetHealth(Heroes.GetLocal()) <= 0.25 * Entity.GetMaxHealth(Heroes.GetLocal()) then
				return
			end
		end
		if Menu.IsEnabled(FAIO.optionTargetCheckNyx) then
			if NPC.HasModifier(genericEnemyEntity, "modifier_nyx_assassin_spiked_carapace") then
				return
			end
		end
		if Menu.IsEnabled(FAIO.optionTargetCheckUrsa) then
			if NPC.HasModifier(genericEnemyEntity, "modifier_ursa_enrage") then
				return
			end
		end
		if Menu.IsEnabled(FAIO.optionTargetCheckAbbadon) then
			if NPC.HasModifier(genericEnemyEntity, "modifier_abaddon_borrowed_time") then
				return
			end
		end
		if Menu.IsEnabled(FAIO.optionTargetCheckDazzle) then
			if NPC.HasModifier(genericEnemyEntity, "modifier_dazzle_shallow_grave") and NPC.GetUnitName(myHero) ~= "npc_dota_hero_axe" then
				return
			end
		end
		if NPC.HasModifier(genericEnemyEntity, "modifier_skeleton_king_reincarnation_scepter_active") then
			return
		end
		if NPC.HasModifier(genericEnemyEntity, "modifier_winter_wyvern_winters_curse") then
			return
		end

	return genericEnemyEntity
	end	
end

function FAIO.makeDelay(sec)

	FAIO.delay = sec + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)
	FAIO.lastTick = os.clock()

end

function FAIO.noItemCastFor(sec)

	FAIO.itemDelay = sec
	FAIO.lastItemTick = os.clock()

end

function FAIO.SleepReady(sleep)

	if (os.clock() - FAIO.lastTick) >= sleep then
		return true
	end
	return false

end

function FAIO.ItemSleepReady(sleep)

	if (os.clock() - FAIO.lastItemCast) >= sleep then
		return true
	end
	return false

end

function FAIO.GetAvgLatency()

	local AVGlatency = NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2
	return AVGlatency

end

function FAIO.CastAnimationDelay(ability)

	if not ability then return end

	local abilityAnimation = Ability.GetCastPoint(ability) + FAIO.GetAvgLatency()

	return abilityAnimation

end
	
function FAIO.castLinearPrediction(myHero, enemy, adjustmentVariable)

	if not myHero then return end
	if not enemy then return end

	local enemyRotation = Entity.GetRotation(enemy):GetVectors()
		enemyRotation:SetZ(0)
    	local enemyOrigin = Entity.GetAbsOrigin(enemy)
		enemyOrigin:SetZ(0)


	local cosGamma = (Entity.GetAbsOrigin(myHero) - enemyOrigin):Dot2D(enemyRotation:Scaled(100)) / ((Entity.GetAbsOrigin(myHero) - enemyOrigin):Length2D() * enemyRotation:Scaled(100):Length2D())

		if enemyRotation and enemyOrigin then
			if not NPC.IsRunning(enemy) then
				return enemyOrigin
			else return enemyOrigin:__add(enemyRotation:Normalized():Scaled(FAIO.GetMoveSpeed(enemy) * adjustmentVariable * (1 - cosGamma)))
			end
		end
end

function FAIO.castPrediction(myHero, enemy, adjustmentVariable)

	if not myHero then return end
	if not enemy then return end

	local enemyRotation = Entity.GetRotation(enemy):GetVectors()
		enemyRotation:SetZ(0)
    	local enemyOrigin = Entity.GetAbsOrigin(enemy)
		enemyOrigin:SetZ(0)

	if enemyRotation and enemyOrigin then
			if not NPC.IsRunning(enemy) then
				return enemyOrigin
			else return enemyOrigin:__add(enemyRotation:Normalized():Scaled(FAIO.GetMoveSpeed(enemy) * adjustmentVariable))
			end
	end
end

function FAIO.isEnemyTurning(enemy)

	if enemy == nil then return true end
	if not NPC.IsRunning(enemy) then return true end

	local rotationSpeed = Entity.GetAngVelocity(enemy):Length2D()
	if NPC.IsRunning(enemy) then
		table.insert(FAIO.rotationTable, rotationSpeed)
			if #FAIO.rotationTable > (Menu.GetValue(FAIO.optionKillStealInvokerTurn) + 1) then
				table.remove(FAIO.rotationTable, 1)
			end
	end
	
	if #FAIO.rotationTable < Menu.GetValue(FAIO.optionKillStealInvokerTurn) then 
		return true
	else
		local rotationSpeedCounter = 0
		i = 1
		repeat
			rotationSpeedCounter = rotationSpeedCounter + FAIO.rotationTable[#FAIO.rotationTable + 1 - i]
			i = i + 1
		until i > Menu.GetValue(FAIO.optionKillStealInvokerTurn)

		if rotationSpeedCounter / Menu.GetValue(FAIO.optionKillStealInvokerTurn) <= 10 then
			return false
		else
			return true
		end
	end
 
end

function FAIO.GetMoveSpeed(enemy)

	if not enemy then return end

	local base_speed = NPC.GetBaseSpeed(enemy)
	local bonus_speed = NPC.GetMoveSpeed(enemy) - NPC.GetBaseSpeed(enemy)
	local modifierHex
    	local modSheep = NPC.GetModifier(enemy, "modifier_sheepstick_debuff")
    	local modLionVoodoo = NPC.GetModifier(enemy, "modifier_lion_voodoo")
    	local modShamanVoodoo = NPC.GetModifier(enemy, "modifier_shadow_shaman_voodoo")

	if modSheep then
		modifierHex = modSheep
	end
	if modLionVoodoo then
		modifierHex = modLionVoodoo
	end
	if modShamanVoodoo then
		modifierHex = modShamanVoodoo
	end

	if modifierHex then
		if math.max(Modifier.GetDieTime(modifierHex) - GameRules.GetGameTime(), 0) > 0 then
			return 140 + bonus_speed
		end
	end

    	if NPC.HasModifier(enemy, "modifier_invoker_ice_wall_slow_debuff") then 
		return 100 
	end

	if NPC.HasModifier(enemy, "modifier_invoker_cold_snap_freeze") or NPC.HasModifier(enemy, "modifier_invoker_cold_snap") then
		return (base_speed + bonus_speed) * 0.5
	end

	if NPC.HasModifier(enemy, "modifier_spirit_breaker_charge_of_darkness") then
		local chargeAbility = NPC.GetAbility(enemy, "spirit_breaker_charge_of_darkness")
		if chargeAbility then
			local specialAbility = NPC.GetAbility(enemy, "special_bonus_unique_spirit_breaker_2")
			if specialAbility then
				 if Ability.GetLevel(specialAbility) < 1 then
					return Ability.GetLevel(chargeAbility) * 50 + 550
				else
					return Ability.GetLevel(chargeAbility) * 50 + 1050
				end
			end
		end
	end
			
    	return base_speed + bonus_speed
end

function FAIO.getBestPosition(unitsAround, radius)

	if not unitsAround or #unitsAround < 1 then
		return 
	end

	local countEnemies = #unitsAround

	if countEnemies == 1 then 
		return Entity.GetAbsOrigin(unitsAround[1]) 
	end

	return FAIO.getMidPoint(unitsAround)

--	local maxCount = 1
--	local bestPosition = Entity.GetAbsOrigin(unitsAround[1])
--	for i = 1, (countEnemies - 1) do
--		for j = i + 1, countEnemies do
--			if unitsAround[i] and unitsAround[j] then
--				local pos1 = Entity.GetAbsOrigin(unitsAround[i])
--				local pos2 = Entity.GetAbsOrigin(unitsAround[j])
--				local mid = pos1:__add(pos2):Scaled(0.5)
--
--				local heroesCount = 0
--				for k = 1, countEnemies do
--				--	if NPC.IsPositionInRange(unitsAround[k], mid, radius, 0) then
--					if (Entity.GetAbsOrigin(unitsAround[k]) - mid):Length2D() <= radius then
--						heroesCount = heroesCount + 1
--					end
--				end
--
--				if heroesCount > maxCount then
--					maxCount = heroesCount
--					bestPosition = mid
--				end
--			end
--		end
--	end
--	return bestPosition

end

function FAIO.getMidPoint(entityList)

	if not entityList then return end
	if #entityList < 1 then return end

	local pts = {}
		for i, v in ipairs(entityList) do
			if v and not Entity.IsDormant(v) then
				local pos = Entity.GetAbsOrigin(v)
				local posX = pos:GetX()
				local posY = pos:GetY()
				table.insert(pts, { x=posX, y=posY })
			end
		end
	
	local x, y, c = 0, 0, #pts

		if (pts.numChildren and pts.numChildren > 0) then c = pts.numChildren end

	for i = 1, c do

		x = x + pts[i].x
		y = y + pts[i].y

	end

	return Vector(x/c, y/c, 0)

end

function FAIO.GetMyFaction(myHero)

	if not myHero then return end
	
	local radiantFountain = Vector(-7600, -7300, 640)
	local direFountain = Vector(7800, 7250, 640)
	
	local myFountain
	if myFountain == nil then
		for i = 1, NPCs.Count() do 
		local npc = NPCs.Get(i)
    			if Entity.IsSameTeam(myHero, npc) and NPC.IsStructure(npc) then
    				if NPC.GetUnitName(npc) ~= nil then
        				if NPC.GetUnitName(npc) == "dota_fountain" then
						myFountain = npc
					end
				end
			end
		end
	end

	local myFaction
	if myFaction == nil and myFountain ~= nil then
		if NPC.IsPositionInRange(myFountain, radiantFountain, 1000, 0) then
			myFaction = "radiant"
		else myFaction = "dire"
		end
	end

	return myFaction

end

function FAIO.GetMyFountainPos(myHero)

	if not myHero then return end

	local myFaction = FAIO.GetMyFaction(myHero)

	local myFountainPos
	if myFaction == "radiant" then
		myFountainPos = Vector(-7600, -7300, 640)
	else myFountainPos = Vector(7800, 7250, 640)
	end

	return myFountainPos

end

function FAIO.GetEnemyFountainPos(myHero)

	if not myHero then return end

	local myFaction = FAIO.GetMyFaction(myHero)

	local enemyFountainPos
	if myFaction == "radiant" then
		enemyFountainPos = Vector(7800, 7250, 640)
	else enemyFountainPos = Vector(-7600, -7300, 640)
	end

	return enemyFountainPos

end

function FAIO.IsCreepAncient(npc)

	if not npc then return false end

	ancientNameList = { 
		"npc_dota_neutral_black_drake",
    		"npc_dota_neutral_black_dragon",
    		"npc_dota_neutral_blue_dragonspawn_sorcerer",
    		"npc_dota_neutral_blue_dragonspawn_overseer",
    		"npc_dota_neutral_granite_golem",
    		"npc_dota_neutral_elder_jungle_stalker",
    		"npc_dota_neutral_prowler_acolyte",
    		"npc_dota_neutral_prowler_shaman",
    		"npc_dota_neutral_rock_golem",
    		"npc_dota_neutral_small_thunder_lizard",
    		"npc_dota_neutral_jungle_stalker",
    		"npc_dota_neutral_big_thunder_lizard",
    		"npc_dota_roshan" }

	for _, creepName in ipairs(ancientNameList) do
		if creepName and NPC.GetUnitName(npc) ~= nil then
			if NPC.GetUnitName(npc) == creepName then
				return true
			end
		end
	end

	return false

end

function FAIO.GetControllableEntities(myHero)

	if not myHero then return end

	for i = 1, NPCs.Count() do 
		local npc = NPCs.Get(i)

		if Wrap.EIsNPC(npc) and Wrap.EIsAlive(npc) and Entity.IsSameTeam(myHero, npc) then
			if npc ~= myHero then
				if Entity.GetOwner(npc) == Entity.GetOwner(myHero) or Entity.OwnedBy(myHero, npc) or Entity.OwnedBy(npc, myHero) then
					if npc ~= nil then
						if FAIO.ControllableEntityTable[Entity.GetIndex(npc)] == nil then
							FAIO.ControllableEntityTable[Entity.GetIndex(npc)] = npc
						end
					end
				else
					if FAIO.ControllableEntityTable[Entity.GetIndex(npc)] ~= nil then
						FAIO.ControllableEntityTable[Entity.GetIndex(npc)] = nil
					end
				end	
			else
				if FAIO.ControllableEntityTable[Entity.GetIndex(npc)] ~= nil then
					FAIO.ControllableEntityTable[Entity.GetIndex(npc)] = nil
				end
			end		
		else
			if FAIO.ControllableEntityTable[Entity.GetIndex(npc)] ~= nil then
				FAIO.ControllableEntityTable[Entity.GetIndex(npc)] = nil
			end
		end	
	end

	return

end

function FAIO.GetNecronomiconEntityTable(myHero, caster)

	if not myHero then return end
	if not caster then return end

	local necronomiconTable = {}
	for i, npc in ipairs(Wrap.UnitsInRadius(myHero, 99999, Enum.TeamType.TEAM_FRIEND)) do
    		if Entity.IsSameTeam(myHero, npc) and Entity.GetOwner(npc) == caster then
    			if NPC.GetUnitName(npc) ~= nil then
				if NPC.GetUnitName(npc) == string.match(NPC.GetUnitName(npc) , 'npc_dota_necronomicon_archer_.') or NPC.GetUnitName(npc) == string.match(NPC.GetUnitName(npc) , 'npc_dota_necronomicon_warrior_.') then
					if npc ~= nil then
						table.insert(necronomiconTable, npc)
					end
				end
			end
		end
	end
	
	return necronomiconTable

end

function FAIO.GetIllusionEntityTable(myHero, caster)

	if not myHero then return end
	if not caster then return end

	local controllableTable = {}
	if next(controllableTable) == nil then
		for i = 1, NPCs.Count() do 
		local npc = NPCs.Get(i)
			if Entity.IsSameTeam(myHero, npc) then
				if npc ~= myHero then
					if Entity.GetOwner(npc) == Entity.GetOwner(caster) then
						if NPC.HasModifier(npc, "modifier_illusion") then
							if npc ~= nil then
								table.insert(controllableTable, npc)
							else controllableTable = {}
							break
							end
						end
					end
				end
			end
		end
	end
	
	return controllableTable

end

function FAIO.NecronomiconController(necronomiconEntity, target, position)

	if not necronomiconEntity then return end
	if not target and not position then return end

	if target ~= nil then
		if NPC.GetUnitName(necronomiconEntity) == string.match(NPC.GetUnitName(necronomiconEntity) , 'npc_dota_necronomicon_archer_.') then
			if not NPC.IsAttacking(necronomiconEntity) then
				if (os.clock() - FAIO.lastCastTime) >= 0.5 then
					if not NPC.IsEntityInRange(necronomiconEntity, target, 600) then
						Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET, target, Vector(0,0,0), ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, necronomiconEntity)
						FAIO.lastCastTime = os.clock()
						FAIO.Debugger(GameRules.GetGameTime(), necronomiconEntity, "attack", "DOTA_UNIT_ORDER_ATTACK_TARGET")
					else			
						if Ability.IsReady(NPC.GetAbilityByIndex(necronomiconEntity, 0)) then
							if NPC.IsHero(target) then
								Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_TARGET, target, Vector(0,0,0), NPC.GetAbilityByIndex(necronomiconEntity, 0), Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, necronomiconEntity)
								FAIO.lastCastTime = os.clock()
								FAIO.Debugger(GameRules.GetGameTime(), necronomiconEntity, "manaBurn", "DOTA_UNIT_ORDER_CAST_TARGET")
							end
						end
						if not Ability.IsReady(NPC.GetAbilityByIndex(necronomiconEntity, 0)) then
							Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET, target, Vector(0,0,0), ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, necronomiconEntity)
							FAIO.lastCastTime = os.clock()
							FAIO.Debugger(GameRules.GetGameTime(), necronomiconEntity, "attack", "DOTA_UNIT_ORDER_ATTACK_TARGET")
						end	
					end
				end
			end
		end
		if (os.clock() - FAIO.lastCastTime) >= 0.25 then
			if NPC.GetUnitName(necronomiconEntity) == string.match(NPC.GetUnitName(necronomiconEntity) , 'npc_dota_necronomicon_warrior_.') then
				if not NPC.IsAttacking(necronomiconEntity) then
					if (os.clock() - FAIO.lastCastTime2) >= 0.5 then
						Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET, target, Vector(0,0,0), ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, necronomiconEntity)
						FAIO.lastCastTime2 = os.clock()
						FAIO.Debugger(GameRules.GetGameTime(), necronomiconEntity, "attack", "DOTA_UNIT_ORDER_ATTACK_TARGET")
					end
				end
			end
		end
	end

	if position ~= nil then
		if NPC.GetUnitName(necronomiconEntity) == string.match(NPC.GetUnitName(necronomiconEntity) , 'npc_dota_necronomicon_archer_.') then
			if not NPC.IsAttacking(necronomiconEntity) and not NPC.IsRunning(necronomiconEntity) then
				if (os.clock() - FAIO.lastCastTime) >= 0.5 then
					Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_MOVE, target, position, ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, necronomiconEntity)
					FAIO.lastCastTime = os.clock()
					FAIO.Debugger(GameRules.GetGameTime(), necronomiconEntity, "attackMove", "DOTA_UNIT_ORDER_ATTACK_MOVE")
				end
			end
		end
		if NPC.GetUnitName(necronomiconEntity) == string.match(NPC.GetUnitName(necronomiconEntity) , 'npc_dota_necronomicon_warrior_.') then
			if (os.clock() - FAIO.lastCastTime) >= 0.25 then
				if not NPC.IsAttacking(necronomiconEntity) and not NPC.IsRunning(necronomiconEntity) then
					if (os.clock() - FAIO.lastCastTime2) >= 0.5 then
						Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_MOVE, target, position, ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, necronomiconEntity)
						FAIO.lastCastTime2 = os.clock()
						FAIO.Debugger(GameRules.GetGameTime(), necronomiconEntity, "attackMove", "DOTA_UNIT_ORDER_ATTACK_MOVE")
					end
				end
			end
		end	
	end

end

function FAIO.invokerForgedSpiritController(myHero, enemy)

	if not myHero then return end
	if not enemy then return end

	for i = 1, NPCs.Count() do 
	local npc = NPCs.Get(i)
		if Entity.IsSameTeam(myHero, npc) then
			if npc ~= myHero and Entity.OwnedBy(npc, myHero) then
				if NPC.GetUnitName(npc) ~= nil then
					if  NPC.GetUnitName(npc) == "npc_dota_invoker_forged_spirit" then
						if npc ~= nil and Wrap.EIsAlive(npc) then
							FAIO.GenericAttackIssuer2("Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil, npc)
						end	
					end
				end
			end
		end
	end

end

function FAIO.MantaIlluController(target, position, myHero, tempestDoubleEntity)

	if not myHero then return end
	if next(FAIO.GetIllusionEntityTable(myHero, tempestDoubleEntity)) == nil then return end
	if not target and not position then return end
	 
	local mantaIllu1 = FAIO.GetIllusionEntityTable(myHero, tempestDoubleEntity)[1]
	local mantaIllu2 = FAIO.GetIllusionEntityTable(myHero, tempestDoubleEntity)[2]

	if target ~= nil then
		if mantaIllu1 then
			if os.clock() - FAIO.LastTickManta1 >= 0.5 then
				Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET, target, Vector(0,0,0), ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, mantaIllu1)
				FAIO.LastTickManta1 = os.clock()
				FAIO.Debugger(GameRules.GetGameTime(), mantaIllu1, "attack", "DOTA_UNIT_ORDER_ATTACK_TARGET")
			end
		end
		if mantaIllu2 then
			if os.clock() - FAIO.LastTickManta2 >= 0.5 then
				Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET, target, Vector(0,0,0), ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, mantaIllu2)
				FAIO.LastTickManta2 = os.clock()
				FAIO.Debugger(GameRules.GetGameTime(), mantaIllu2, "attack", "DOTA_UNIT_ORDER_ATTACK_TARGET")
			end
		end
	end

	if position ~= nil then
		if mantaIllu1 then
			if not NPC.IsAttacking(mantaIllu1) and not NPC.IsRunning(mantaIllu1) then
				if os.clock() - FAIO.LastTickManta1 >= 0.5 then
					Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_MOVE, target, position, ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, mantaIllu1)
					FAIO.LastTickManta1 = os.clock()
					FAIO.Debugger(GameRules.GetGameTime(), mantaIllu1, "attackMove", "DOTA_UNIT_ORDER_ATTACK_MOVE")
				end
			end
		end
		if mantaIllu2 then
			if not NPC.IsAttacking(mantaIllu2) and not NPC.IsRunning(mantaIllu2) then
				if os.clock() - FAIO.LastTickManta2 >= 0.5 then
					Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_MOVE, target, position, ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, mantaIllu2)
					FAIO.LastTickManta2 = os.clock()
					FAIO.Debugger(GameRules.GetGameTime(), mantaIllu2, "attackMove", "DOTA_UNIT_ORDER_ATTACK_MOVE")
				end
			end
		end
	end	
end

function FAIO.IsInAbilityPhase(myHero)

	if not myHero then return false end

	local myAbilities = {}

	for i= 0, 10 do
		local ability = NPC.GetAbilityByIndex(myHero, i)
		if ability and Entity.IsAbility(ability) and Ability.GetLevel(ability) > 0 then
			table.insert(myAbilities, ability)
		end
	end

	if #myAbilities < 1 then return false end

	for _, v in ipairs(myAbilities) do
		if v then
			if Ability.IsInAbilityPhase(v) then
				return true
			end
		end
	end

	return false

end

function FAIO.GenericMainAttack(myHero, attackType, target, position)
	
	if not myHero then return end
	if not target and not position then return end

	if FAIO.isHeroChannelling(myHero) == true then return end
	if FAIO.heroCanCastItems(myHero) == false then return end
	if FAIO.IsInAbilityPhase(myHero) == true then return end

	if Menu.IsEnabled(FAIO.optionOrbwalkEnable) then
		if target ~= nil then
			if NPC.HasModifier(myHero, "modifier_windrunner_focusfire") then
				FAIO.GenericAttackIssuer(attackType, target, position, myHero)
			elseif NPC.HasModifier(myHero, "modifier_item_hurricane_pike_range") then
				FAIO.GenericAttackIssuer(attackType, target, position, myHero)
			else
				FAIO.OrbWalker(myHero, target)
			end
		else
			FAIO.GenericAttackIssuer(attackType, target, position, myHero)
		end
	else
		FAIO.GenericAttackIssuer(attackType, target, position, myHero)
	end

end

function FAIO.GenericAttackIssuer(attackType, target, position, npc)

	if not npc then return end
	if not target and not position then return end
	if os.clock() - FAIO.lastAttackTime2 < 0.5 then return end

	if attackType == "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET" then
		if target ~= nil then
			if target ~= FAIO.LastTarget then
				Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET, target, Vector(0, 0, 0), ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, npc)
				FAIO.LastTarget = target
				FAIO.Debugger(GameRules.GetGameTime(), npc, "attack", "DOTA_UNIT_ORDER_ATTACK_TARGET")
			end
		end
	end

	if attackType == "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_MOVE" then
		if position ~= nil then
			if not NPC.IsAttacking(npc) or not NPC.IsRunning(npc) then
				if position:__tostring() ~= FAIO.LastTarget then
					Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_MOVE, target, position, ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, npc)
					FAIO.LastTarget = position:__tostring()
					FAIO.Debugger(GameRules.GetGameTime(), npc, "attackMove", "DOTA_UNIT_ORDER_ATTACK_MOVE")
				end
			end
		end
	end

	if attackType == "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION" then
		if position ~= nil then
			if position:__tostring() ~= FAIO.LastTarget then
				Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION, target, position, ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, npc)
				FAIO.LastTarget = position:__tostring()
				FAIO.Debugger(GameRules.GetGameTime(), npc, "move", "DOTA_UNIT_ORDER_MOVE_TO_POSITION")
			end
		end
	end

	if target ~= nil then
		if target == FAIO.LastTarget then
			if not NPC.IsAttacking(npc) then
				FAIO.LastTarget = nil
				FAIO.lastAttackTime2 = os.clock()
				return
			end
		end
	end

	if position ~= nil then
		if position:__tostring() == FAIO.LastTarget then
			if not NPC.IsRunning(npc) then
				FAIO.LastTarget = nil
				FAIO.lastAttackTime2 = os.clock()
				return
			end
		end
	end

end

function FAIO.GenericAttackIssuer2(attackType, target, position, npc)

	if not npc or (npc and not Wrap.EIsAlive(npc)) then return end
	if not target and not position then return end

	if FAIO[tostring(npc)] ~= nil then
		if os.clock() - FAIO[tostring(npc)] < 1.0 then
			return
		end
	end

	if attackType == "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET" and (Menu.IsKeyDown(FAIO.optionComboKey) or Menu.IsKeyDown(FAIO.optionHeroVisageInstStunKey)) then
		if target ~= nil then
			Player.AttackTarget(Players.GetLocal(), npc, target, false)
			FAIO.Debugger(GameRules.GetGameTime(), npc, "attack", "DOTA_UNIT_ORDER_ATTACK_TARGET")
			FAIO[tostring(npc)] = os.clock()
			return
		end
	end

	if attackType == "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_MOVE" then
		if position ~= nil then
			if #Wrap.UnitsInRadius(npc, NPC.GetAttackRange(npc)+50, 1) < 1 then
				Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_MOVE, target, position, ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, npc)
				FAIO.Debugger(GameRules.GetGameTime(), npc, "attackMove", "DOTA_UNIT_ORDER_ATTACK_MOVE")
				FAIO[tostring(npc)] = os.clock()
				return
			end
		end
	end

	if attackType == "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION" then
		if position ~= nil then
			if not NPC.IsRunning(npc) then
				NPC.MoveTo(npc, position, false, false)
				FAIO.Debugger(GameRules.GetGameTime(), npc, "move", "DOTA_UNIT_ORDER_MOVE_TO_POSITION")
				FAIO[tostring(npc)] = os.clock()
				return
			end
		end
	end
end

function FAIO.GenericControllableAttackIssuer(attackType, target, position)

	if next(FAIO.ControllableEntityTable) == nil then return end
	if not target and not position then return end

	local controllableEntity = nil
		for i, v in pairs(FAIO.ControllableEntityTable) do
			if v and Wrap.EIsNPC(v) and Wrap.EIsAlive(v) and FAIO.heroCanCastItems(v) == true then
				if FAIO.ControllableAttackTiming[Entity.GetIndex(v)] == nil or os.clock() - FAIO.ControllableAttackTiming[Entity.GetIndex(v)] > 0.5 then
					controllableEntity = v
					break
				end
			end
		end

	if controllableEntity ~= nil then

		if attackType == "ATTACK_TARGET" then
			if target ~= nil then
				Player.AttackTarget(Players.GetLocal(), controllableEntity, target, false)
				FAIO.ControllableAttackTiming[Entity.GetIndex(controllableEntity)] = os.clock()
				return
			end
		end

		if attackType == "MOVE_TO_POSITION" then
			if position ~= nil then
				if not NPC.IsRunning(controllableEntity) then
					NPC.MoveTo(controllableEntity, position, false, false)
					FAIO.ControllableAttackTiming[Entity.GetIndex(controllableEntity)] = os.clock()
					return
				end
			end
		end

	end

	return

end

function FAIO.OrbWalker(myHero, enemy)

	if not myHero then return end
	if not enemy then return end

	if NPC.IsChannellingAbility(myHero) then return end
	if FAIO.isHeroChannelling(myHero) == true then return end
	if FAIO.heroCanCastItems(myHero) == false then return end
	if FAIO.IsInAbilityPhase(myHero) == true then return end

	local myMana = NPC.GetMana(myHero)

	local attackRange = NPC.GetAttackRange(myHero)

	local increasedAS = NPC.GetIncreasedAttackSpeed(myHero)
	local attackTime = NPC.GetAttackTime(myHero)
	local movementSpeed = NPC.GetMoveSpeed(myHero)

	local attackPoint
	local attackBackSwing
	for i, v in pairs(FAIO.attackPointTable) do
		if i == NPC.GetUnitName(myHero) then
			attackPoint = v[1] / (1 + (increasedAS/100))
			attackBackSwing = v[2] / (1 + (increasedAS/100))
			break
		end
	end

	local idleTime = attackTime - attackPoint - attackBackSwing

	local turnTime180degrees = (0.03 * math.pi) / NPC.GetTurnRate(myHero)

	local orbWalkSkill
	for i, v in pairs(FAIO.orbAttackTable) do
		if i == NPC.GetUnitName(myHero) then
			orbWalkSkill = NPC.GetAbility(myHero, v)
			break
		end
	end

	if orbWalkSkill then
		if Ability.GetName(orbWalkSkill) == "viper_poison_attack" then
			if NPC.HasModifier(enemy, "modifier_viper_poison_attack_slow") then
				local dieTime = Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_viper_poison_attack_slow"))
				if dieTime - GameRules.GetGameTime() > 1.0 then
					orbWalkSkill = nil
				end
			end
		end
	end

	if Entity.IsSameTeam(myHero, enemy) then
		orbWalkSkill = nil
	end

	if NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
		orbWalkSkill = nil
	end

	if NPC.IsRanged(myHero) then
		if FAIO.AttackProjectileCreate > 0 then
			if os.clock() > FAIO.AttackAnimationCreate and os.clock() < FAIO.AttackProjectileCreate + attackBackSwing + idleTime then
				FAIO.InAttackBackswing = true
			else
				FAIO.InAttackBackswing = false
			end
		end
	else
		if FAIO.AttackParticleCreate > 0 then
			if NPC.HasItem(myHero, "item_echo_sabre", true) then
				if Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_echo_sabre", true)) > -1 and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_echo_sabre", true)) < (attackPoint / 1.49) + 0.15 then
					FAIO.InAttackBackswing = false
				else
					if os.clock() > FAIO.AttackAnimationCreate and os.clock() < FAIO.AttackParticleCreate + attackBackSwing + idleTime then
						FAIO.InAttackBackswing = true
					else
						FAIO.InAttackBackswing = false
					end
				end
			else
				if os.clock() > FAIO.AttackAnimationCreate and os.clock() < FAIO.AttackParticleCreate + attackBackSwing + idleTime then
					FAIO.InAttackBackswing = true
				else
					FAIO.InAttackBackswing = false
				end
			end
		end
	end

	if os.clock() > FAIO.AttackAnimationCreate and os.clock() < FAIO.AttackParticleCreate then
		FAIO.InAttackBackswing = false
	end

	if os.clock() > FAIO.AttackAnimationCreate and os.clock() < FAIO.AttackProjectileCreate then
		FAIO.InAttackBackswing = false
	end

	local breakPoint
		if NPC.IsRanged(myHero) then
			breakPoint = attackRange * (Menu.GetValue(FAIO.optionOrbwalkDistance) / 100)
		else
			breakPoint = attackRange
		end

	local moveDistance = NPC.GetMoveSpeed(myHero) * (attackBackSwing + idleTime - NPC.GetTimeToFace(myHero, enemy)) * (1 - (Menu.GetValue(FAIO.optionOrbwalkOffset) / 100))
		if NPC.IsRanged(myHero) then
			if (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() > breakPoint and (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() <= breakPoint + moveDistance then
				moveDistance = (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() - breakPoint
			end
		end

	local kiteDistance = 0
		if (2 * turnTime180degrees) < (attackBackSwing + idleTime) * (1 - (Menu.GetValue(FAIO.optionOrbwalkOffset) / 100)) then
			kiteDistance = ((attackBackSwing + idleTime) * (1 - (Menu.GetValue(FAIO.optionOrbwalkOffset) / 100)) - (2 * turnTime180degrees)) * NPC.GetMoveSpeed(myHero)
		end

	local styleSelector = 0
		if Menu.GetValue(FAIO.optionOrbwalkStyle) == 0 then
			styleSelector = 1
		else
			if Menu.GetValue(FAIO.optionOrbwalkMouseStyle) == 1 then
				styleSelector = 2
			else
				if NPC.IsRanged(myHero) then			
					styleSelector = 2
				else
					styleSelector = 1
				end
			end
		end
	
	if styleSelector < 2 then
		if not FAIO.InAttackBackswing then
			if orbWalkSkill and Ability.IsCastable(orbWalkSkill, myMana) then
				if os.clock() - FAIO.OrbwalkerDelay > 0.05 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) then
					Ability.CastTarget(orbWalkSkill, enemy)
					FAIO.OrbwalkerDelay = os.clock()
					return
				end
			else
				if os.clock() - FAIO.OrbwalkerDelay > 0.05 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) and os.clock() - FAIO.AttackAnimationCreate > attackPoint + 0.1 then
					Player.AttackTarget(Players.GetLocal(), myHero, enemy, false)
					FAIO.OrbwalkerDelay = os.clock()
					return
				end
			end
		else
			if (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() > breakPoint then
				if os.clock() - FAIO.OrbwalkerDelay > attackBackSwing + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) then
					if moveDistance > 50 then
						local targetVector = Entity.GetAbsOrigin(myHero) + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(moveDistance)
						NPC.MoveTo(myHero, targetVector, false, false)
						FAIO.OrbwalkerDelay = os.clock()
						return
					end
				end
	
			end
			if Menu.IsEnabled(FAIO.optionOrbwalkKiting) then
				if NPC.IsRanged(myHero) then
					if (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() < breakPoint - 50 then
						if os.clock() - FAIO.OrbwalkerDelay > attackBackSwing + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) then
							if kiteDistance > 50 then
								local targetVector = Entity.GetAbsOrigin(myHero) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(kiteDistance)
								NPC.MoveTo(myHero, targetVector, false, false)
								FAIO.OrbwalkerDelay = os.clock()
								return
							end
						end
					end
				end
			end
		end
	else
		local mousePos = Input.GetWorldCursorPos()
		local breakPoint2
			if NPC.IsRanged(myHero) then
				breakPoint2 = attackRange * (Menu.GetValue(FAIO.optionOrbwalkDistanceMouse) / 100)
			else
				breakPoint2 = attackRange
			end
		local moveDistance2 = NPC.GetMoveSpeed(myHero) * (attackBackSwing + idleTime - NPC.GetTimeToFace(myHero, enemy) - FAIO.TimeToFacePosition(myHero, mousePos)) * (1 - (Menu.GetValue(FAIO.optionOrbwalkOffset) / 100))
		
		if not FAIO.InAttackBackswing then
			if orbWalkSkill and Ability.IsCastable(orbWalkSkill, myMana) then
				if os.clock() - FAIO.OrbwalkerDelay > 0.05 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) then
					Ability.CastTarget(orbWalkSkill, enemy)
					FAIO.OrbwalkerDelay = os.clock()
					return
				end
			else
				if os.clock() - FAIO.OrbwalkerDelay > 0.05 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) and os.clock() - FAIO.AttackAnimationCreate > attackPoint + 0.1 then
					Player.AttackTarget(Players.GetLocal(), myHero, enemy, false)
					FAIO.OrbwalkerDelay = os.clock()
					return
				end
			end
		else
			if os.clock() - FAIO.OrbwalkerDelay > attackBackSwing + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) then
				local myDisToMouse = (Entity.GetAbsOrigin(myHero) - mousePos):Length2D()
				if moveDistance2 > 50 and myDisToMouse > Menu.GetValue(FAIO.optionOrbwalkMouseHold) then
					local targetVector = Entity.GetAbsOrigin(myHero) + (mousePos - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(moveDistance2)
					if not NPC.IsPositionInRange(enemy, targetVector, breakPoint2, 0) then
						NPC.MoveTo(myHero, targetVector, false, false)
						FAIO.OrbwalkerDelay = os.clock()
						return
					end
				end
			end
		end
	end

end

function FAIO.TimeToFacePosition(myHero, pos)

	if not myHero then return 0 end
	if not pos then return 0 end

	local myPos = Entity.GetAbsOrigin(myHero)
	local myRotation = Entity.GetRotation(myHero):GetForward():Normalized()

	local baseVec = (pos - myPos):Normalized()

	local tempProcessing = math.min(baseVec:Dot2D(myRotation) / (baseVec:Length2D() * myRotation:Length2D()), 1)	

	local checkAngleRad = math.acos(tempProcessing)
	local checkAngle = (180 / math.pi) * checkAngleRad

	local myTurnRate = NPC.GetTurnRate(myHero)

	local turnTime = FAIO.utilityRoundNumber(((0.033 * math.pi / myTurnRate) / 180) * checkAngle, 3)

	return turntime or 0

end

function FAIO.GetLongestCooldown(myHero, skill1, skill2, skill3, skill4, skill5)

	if not myHero then return end

	local skill1 = skill1
	local skill2 = skill2
	local skill3 = skill3
	local skill4 = skill4
	local skill5 = skill5


	local tempTable = {}

	if skill1 then
		table.insert(tempTable, math.ceil(Ability.GetCooldownTimeLeft(skill1)))
	end
	if skill2 then
		table.insert(tempTable, math.ceil(Ability.GetCooldownTimeLeft(skill2)))
	end
	if skill3 then
		table.insert(tempTable, math.ceil(Ability.GetCooldownTimeLeft(skill3)))
	end
	if skill4 then
		table.insert(tempTable, math.ceil(Ability.GetCooldownTimeLeft(skill4)))
	end
	if skill5 then
		table.insert(tempTable, math.ceil(Ability.GetCooldownTimeLeft(skill5)))
	end

	table.sort(tempTable, function(a, b)
        	return a > b
    			end)

	return tempTable[1]

end

function FAIO.GenericLanePusher(npc)

	if not npc or (npc and not Wrap.EIsAlive(npc)) then return end

	local myFaction = FAIO.GetMyFaction(npc)
	local myFountainPos = FAIO.GetMyFountainPos(npc)
	local enemyFountainPos = FAIO.GetEnemyFountainPos(npc)

	local leftCornerPos = Vector(-5750, 6050, 384)
	local rightCornerPos = Vector(6000, -5800, 384)
	local midPos = Vector(-600, -300, 128)

	local radiantTop2 = Vector(-6150, -800, 384)
	local radiantBot2 = Vector(-800, -6250, 384)
	local radiantMid2 = Vector(-2800, -2250, 256)
	
	local direTop2 = Vector(800, 6000, 384)
	local direBot2 = Vector(6200, 400, 384)
	local direMid2 = Vector(2800, 2100, 256)


	local myBotTower2
		if myFaction == "radiant"
			then myBotTower2 = radiantBot2
		else myBotTower2 = direBot2
		end

	local myTopTower2
		if myFaction == "radiant"
			then myTopTower2 = radiantTop2
		else myTopTower2 = direTop2
		end

	local myMidTower2
		if myFaction == "radiant"
			then myMidTower2 = radiantMid2
		else myMidTower2 = direMid2
		end


	local myPos = Entity.GetAbsOrigin(npc)

	local homeSide
	if myPos:__sub(myFountainPos):Length2D() < myPos:__sub(enemyFountainPos):Length2D() then
		homeSide = true
	else homeSide = false
	end
	
	if not homeSide then
		return enemyFountainPos
	end

	if homeSide then
		if myPos:__sub(leftCornerPos):Length2D() <= 800 then
			return enemyFountainPos
		elseif myPos:__sub(rightCornerPos):Length2D() <= 800 then
			return enemyFountainPos
		elseif myPos:__sub(midPos):Length2D() <= 800 then
			return enemyFountainPos
		end
	end

	if homeSide then
		if myPos:__sub(leftCornerPos):Length2D() > 800 and myPos:__sub(rightCornerPos):Length2D() > 800 and myPos:__sub(midPos):Length2D() > 800 then
			
			if myPos:__sub(leftCornerPos):Length2D() < myPos:__sub(rightCornerPos):Length2D() and myPos:__sub(leftCornerPos):Length2D() < myPos:__sub(midPos):Length2D() then
				return leftCornerPos
			elseif myPos:__sub(leftCornerPos):Length2D() < myPos:__sub(rightCornerPos):Length2D() and myPos:__sub(myTopTower2):Length2D() < myPos:__sub(midPos):Length2D() and myPos:__sub(myMidTower2):Length2D() > myPos:__sub(myTopTower2):Length2D() then
				return leftCornerPos
			elseif myPos:__sub(rightCornerPos):Length2D() < myPos:__sub(leftCornerPos):Length2D() and myPos:__sub(rightCornerPos):Length2D() < myPos:__sub(midPos):Length2D() then
				return rightCornerPos
			elseif myPos:__sub(rightCornerPos):Length2D() < myPos:__sub(leftCornerPos):Length2D() and myPos:__sub(myBotTower2):Length2D() < myPos:__sub(midPos):Length2D() and myPos:__sub(myMidTower2):Length2D() > myPos:__sub(myBotTower2):Length2D() then
				return rightCornerPos
			elseif myPos:__sub(midPos):Length2D() < myPos:__sub(leftCornerPos):Length2D() and myPos:__sub(midPos):Length2D() < myPos:__sub(rightCornerPos):Length2D() and myPos:__sub(myMidTower2):Length2D() < myPos:__sub(myTopTower2):Length2D() then
				return enemyFountainPos
			elseif myPos:__sub(midPos):Length2D() < myPos:__sub(leftCornerPos):Length2D() and myPos:__sub(midPos):Length2D() < myPos:__sub(rightCornerPos):Length2D() and myPos:__sub(myMidTower2):Length2D() < myPos:__sub(myBotTower2):Length2D() then
				return enemyFountainPos
			else return enemyFountainPos
			end
		end
	end
end

function FAIO.ForceBlink(myHero, enemy, range)

	if not myHero then return end
	
	local blink = NPC.GetItem(myHero, "item_blink", true)
		if not blink then return end
		if blink and not Ability.IsReady(blink) then return end

	if not enemy or (enemy and not NPC.IsPositionInRange(enemy, Input.GetWorldCursorPos(), range, 0)) then
		if Menu.IsKeyDown(FAIO.optionComboKey) then
			if NPC.IsPositionInRange(myHero, Input.GetWorldCursorPos(), 1100, 0) then
				Ability.CastPosition(blink, Input.GetWorldCursorPos())
				return
			else
				if FAIO.SleepReady(0.1) then
					Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION, target, Input.GetWorldCursorPos(), ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_HERO_ONLY, npc, queue, showEffects)
					FAIO.lastTick = os.clock()
					return
				end
			end	
		end
	end
end

function FAIO:WorldToMiniMap(pos, screenWidth, screenHeight)
	local screenH = screenHeight
	local screenW = screenWidth 
	local MapLeft = -8000
	local MapTop = 7350
	local MapRight = 7500
	local MapBottom = -7200
	local mapWidth = math.abs(MapLeft - MapRight)
	local mapHeight = math.abs(MapBottom - MapTop)
	

	local x = pos:GetX() - MapLeft
	local y = pos:GetY() - MapBottom

	local dx, dy, px, py
	if self.Round(screenW / screenH, 1) >= 1.7 then

		dx = 272 / 1920 * screenW
		dy = 261 / 1080 * screenH
		px = 11 / 1920 * screenW
		py = 11 / 1080 * screenH
	elseif self.Round(screenW / screenH, 1) >= 1.5 then

		dx = 267 / 1680 * screenW
		dy = 252 / 1050 * screenH
		px = 10 / 1680 * screenW
		py = 11 / 1050 * screenH
	else
		dx = 255 / 1280 * screenW
		dy = 229 / 1024 * screenH
		px = 6 / 1280 * screenW
		py = 9 / 1024 * screenH
	end
	local minimapMapScaleX = dx / mapWidth
	local minimapMapScaleY = dy / mapHeight

	local scaledX = math.min(math.max(x * minimapMapScaleX, 0), dx)
	local scaledY = math.min(math.max(y * minimapMapScaleY, 0), dy)

	local screenX = px + scaledX
	local screenY = screenH - scaledY - py

	return Vector(math.floor(screenX - 20 + Menu.GetValue(FAIO.optionWorldToMinimapOffsetX)), math.floor(screenY - 12 + Menu.GetValue(FAIO.optionWorldToMinimapOffsetY)), 0)
end

function FAIO.Round(num, numDecimalPlaces)
	local mult = 10^(numDecimalPlaces or 0)
	return math.floor(num * mult + 0.5) / mult
end

function FAIO.TargetDisableTimer(myHero, enemy)

	if not myHero then return end
	if not enemy then return end

	local stunRootList = {
		"modifier_stunned",
		"modifier_bashed",
		"modifier_alchemist_unstable_concoction", 
		"modifier_ancientapparition_coldfeet_freeze", 
		"modifier_axe_berserkers_call",
		"modifier_bane_fiends_grip",
		"modifier_bane_nightmare",
		"modifier_bloodseeker_rupture",
		"modifier_rattletrap_hookshot", 
		"modifier_earthshaker_fissure_stun", 
		"modifier_earth_spirit_boulder_smash",
		"modifier_enigma_black_hole_pull",
		"modifier_faceless_void_chronosphere_freeze",
		"modifier_jakiro_ice_path_stun", 
		"modifier_keeper_of_the_light_mana_leak_stun", 
		"modifier_kunkka_torrent", 
		"modifier_legion_commander_duel", 
		"modifier_lion_impale", 
		"modifier_magnataur_reverse_polarity", 
		"modifier_medusa_stone_gaze_stone", 
		"modifier_morphling_adaptive_strike", 
		"modifier_naga_siren_ensnare", 
		"modifier_nyx_assassin_impale", 
		"modifier_pudge_dismember", 
		"modifier_sandking_impale", 
		"modifier_shadow_shaman_shackles", 
		"modifier_techies_stasis_trap_stunned", 
		"modifier_tidehunter_ravage", 
		"modifier_treant_natures_guise",
		"modifier_windrunner_shackle_shot",
		"modifier_rooted", 
		"modifier_crystal_maiden_frostbite", 
		"modifier_ember_spirit_searing_chains", 
		"modifier_meepo_earthbind",
		"modifier_lone_druid_spirit_bear_entangle_effect",
		"modifier_slark_pounce_leash",
		"modifier_storm_spirit_electric_vortex_pull",
		"modifier_treant_overgrowth", 
		"modifier_abyssal_underlord_pit_of_malice_ensare", 
		"modifier_item_rod_of_atos_debuff",
		"modifier_eul_cyclone",
		"modifier_obsidian_destroyer_astral_imprisonment_prison",
		"modifier_shadow_demon_disruption"
			}
	
	local searchMod
	for _, modifier in ipairs(stunRootList) do
		if NPC.HasModifier(enemy, modifier) then
			searchMod = NPC.GetModifier(enemy, modifier)
			break
		end
	end

	if searchMod then
		if NPC.HasModifier(enemy, Modifier.GetName(searchMod)) then
			if Modifier.GetName(searchMod) == "modifier_enigma_black_hole_pull" then
				return Modifier.GetCreationTime(searchMod) + 4
			elseif Modifier.GetName(searchMod) == "modifier_faceless_void_chronosphere_freeze" then
				return Modifier.GetCreationTime(searchMod) + (3.5 + FAIO.GetTeammateAbilityLevel(myHero, "faceless_void_chronosphere") * 0.5)
			else
				return Modifier.GetDieTime(searchMod)
			end
		else
			return 0
		end
	else
		return 0
	end

end

function FAIO.GetTeammateAbilityLevel(myHero, ability)

	if not myHero then return end
	if not ability then return 0 end

	for _, teamMate in ipairs(Wrap.HeroesInRadius(myHero, 99999, Enum.TeamType.TEAM_FRIEND)) do
		if NPC.HasAbility(teamMate, ability) then
			if NPC.GetAbility(teamMate, ability) then
				return Ability.GetLevel(NPC.GetAbility(teamMate, ability))
			end
		end
	end
	return 0

end

function FAIO.TargetIsInvulnarable(myHero, enemy)

	if not myHero then return end
	if not enemy then return end

	local curTime = GameRules.GetGameTime()

	local invuList = {
		"modifier_eul_cyclone",
		"modifier_invoker_tornado",
		"modifier_obsidian_destroyer_astral_imprisonment_prison",
		"modifier_shadow_demon_disruption"
			}
	
	local searchMod
	for _, modifier in ipairs(invuList) do
		if NPC.HasModifier(enemy, modifier) then
			searchMod = NPC.GetModifier(enemy, modifier)
			break
		end
	end

	if searchMod then
		if NPC.HasModifier(enemy, Modifier.GetName(searchMod)) then
			return Modifier.GetDieTime(searchMod)
		else
			return 0
		end
	else
		return 0
	end

end

function FAIO.EnemyHPTracker(myHero)

	if not myHero then return end

	if Heroes.Count() == 0 then
		FAIO.enemyHeroTable = {}
		return
	end	

	for i = 1, Heroes.Count() do
		local allHeroes = Heroes.Get(i)
	
		if allHeroes == nil then
			FAIO.enemyHeroTable = {}
			return
		else
			if Entity.IsHero(allHeroes) and not Entity.IsSameTeam(myHero, allHeroes) then
				if not NPC.IsIllusion(allHeroes) then
					if FAIO.enemyHeroTable[allHeroes] == nil then
						FAIO.enemyHeroTable[allHeroes] = { 99999, 99999, 0 }
					end
				end
			end
		end
	end

	for hero, data in pairs(FAIO.enemyHeroTable) do
		if hero and not Wrap.EIsNPC(hero) then
			FAIO.enemyHeroTable[hero] = nil
		end
		if hero and Wrap.EIsNPC(hero) and Wrap.EIsAlive(hero) and not Entity.IsDormant(hero) and GameRules.GetGameTime() - data[3] > 1 then
			local heroHP = Entity.GetHealth(hero)
			local heroHPreg = NPC.GetHealthRegen(hero)
			local timeStamp = GameRules.GetGameTime()
			FAIO.enemyHeroTable[hero] = { heroHP, heroHPreg, timeStamp }
		end
	end

end

function FAIO.getEnemyBeShackledWithNPC(myHero, enemy)

	if not myHero then return end
	if not enemy then return end

	local myMana = NPC.GetMana(myHero)
	local shackleShot = NPC.GetAbility(myHero, "windrunner_shackleshot")
		if not shackleShot then return end
		if not Ability.IsCastable(shackleShot, myMana) then return end

	local shackleSearchRange = 575
	local shackleCastRange = 785

	local enemyPos = Entity.GetAbsOrigin(enemy)
	if Menu.IsEnabled(FAIO.optionHeroWindrunnerPredict) then
		enemyPos = FAIO.castPrediction(myHero, enemy, 0.15 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2))
	end

	local directLineVector = enemyPos + (enemyPos - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(shackleSearchRange)

	local npcs = Wrap.UnitsInRadius(enemy, shackleSearchRange, Enum.TeamType.TEAM_FRIEND)
		if next(npcs) == nil then return end

		local shackleNPC
		local minAngle = 180
		local minRange = 99999	

		for _, targetNPC in ipairs(npcs) do
			if targetNPC then
				local myDisToEnemy = (Entity.GetAbsOrigin(myHero) - enemyPos):Length2D()
				local myDisToNPC = (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(targetNPC)):Length2D()
				local enemyDisToNPC = (enemyPos - Entity.GetAbsOrigin(targetNPC)):Length2D()
				if myDisToEnemy < myDisToNPC then
					if myDisToEnemy < shackleCastRange then
						local vectorEnemyToNPC = Entity.GetAbsOrigin(targetNPC) - enemyPos
						local vectormyHerotoEnemy = enemyPos - Entity.GetAbsOrigin(myHero)
						local tempProcessing = vectormyHerotoEnemy:Dot2D(vectorEnemyToNPC) / (vectormyHerotoEnemy:Length2D() * vectorEnemyToNPC:Length2D())
							if tempProcessing > 1 then
								tempProcessing = 1
							end	
						local searchAngleRad = math.acos(tempProcessing)
						local searchAngle = (180 / math.pi) * searchAngleRad
						if searchAngle < minAngle then
							shackleNPC = enemy
							minAngle = searchAngle
						end
					end
				else
					if myDisToNPC < shackleCastRange then
						local vectorNPCToEnemy = enemyPos - Entity.GetAbsOrigin(targetNPC)
						local vectormyHerotoNPC = Entity.GetAbsOrigin(targetNPC) - Entity.GetAbsOrigin(myHero)
						local tempProcessing = vectormyHerotoNPC:Dot2D(vectorNPCToEnemy) / (vectormyHerotoNPC:Length2D() * vectorNPCToEnemy:Length2D())
							if tempProcessing > 1 then
								tempProcessing = 1
							end	
						local searchAngleRad = math.acos(tempProcessing)
						local searchAngle = (180 / math.pi) * searchAngleRad
						if searchAngle < minAngle and vectorNPCToEnemy:Length2D() < minRange then
							shackleNPC = targetNPC
							minAngle = searchAngle
							minRange = vectorNPCToEnemy:Length2D()
						end
					end
				end
			end
		end

		if shackleNPC and minAngle < 23 then
			return shackleNPC
		end
	
	return

end

function FAIO.getEnemyShackledBestPosition(myHero, enemy, dist)

	if not myHero then return Vector() end
	if not enemy then return Vector() end
	if not dist then return Vector() end

	local myMana = NPC.GetMana(myHero)
	local shackleShot = NPC.GetAbility(myHero, "windrunner_shackleshot")
		if not shackleShot then return Vector() end
		if not Ability.IsCastable(shackleShot, myMana) then return Vector() end

	local shackleSearchRange = 575
	local shackleCastRange = 785

	local enemyPos = Entity.GetAbsOrigin(enemy)
	if Menu.IsEnabled(FAIO.optionHeroWindrunnerPredict) then
		enemyPos = FAIO.castPrediction(myHero, enemy, 0.15 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2))
	end

	local directLineVector = enemyPos + (enemyPos - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(shackleSearchRange)

	local shacklePos = Vector()
	local minDis = 99999
	local minCreepDis = 99999

	if not FAIO.canEnemyBeShackledWithTree(myHero, enemy) and FAIO.getEnemyBeShackledWithNPC(myHero, enemy) == nil then
		local npcs = Wrap.UnitsInRadius(enemy, shackleSearchRange, Enum.TeamType.TEAM_FRIEND)
		for _, targetNPC in ipairs(npcs) do
			if targetNPC then
				local myDisToEnemy = (Entity.GetAbsOrigin(myHero) - enemyPos):Length2D()
				local myDisToNPC = (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(targetNPC)):Length2D()
				local enemyDisToNPC = (enemyPos - Entity.GetAbsOrigin(targetNPC)):Length2D()
				
				if myDisToEnemy < myDisToNPC then
					local vectorNPCtoEnemy = enemyPos - Entity.GetAbsOrigin(targetNPC)
					local searchVec = Entity.GetAbsOrigin(targetNPC) + vectorNPCtoEnemy:Normalized():Scaled(vectorNPCtoEnemy:Length2D() + 250)
					local myDisToSearchPos = (searchVec - Entity.GetAbsOrigin(myHero)):Length2D()
					if #Wrap.TInRadius(searchVec, 300, true) < 1 and #Wrap.HInRadius(searchVec, 150, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY) < 1 then
						if myDisToSearchPos < minDis then
							shacklePos = searchVec
							minDis = myDisToSearchPos
						end
					end
				else
					local vectorEnemyToNPC = Entity.GetAbsOrigin(targetNPC) - enemyPos
					local searchVec = enemyPos + vectorEnemyToNPC:Normalized():Scaled(vectorEnemyToNPC:Length2D() + 250)
					local myDisToSearchPos = (searchVec - Entity.GetAbsOrigin(myHero)):Length2D()
					if #Wrap.TInRadius(searchVec, 300, true) < 1 and #Wrap.HInRadius(searchVec, 150, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY) < 1 then
						if myDisToSearchPos < minDis and vectorEnemyToNPC:Length2D() < minCreepDis then
							shacklePos = searchVec
							minDis = myDisToSearchPos
							minCreepDis = vectorEnemyToNPC:Length2D()
						end
					end
				end
			end
		end
		
		if shacklePos:__tostring() == Vector():__tostring() then
			if next(FAIO.getEnemyShackleTrees(myHero, enemy)) ~= nil then
				for _, targetTree in ipairs(FAIO.getEnemyShackleTrees(myHero, enemy)) do
					if targetTree then
						local vectorTreeToEnemy = enemyPos - Entity.GetAbsOrigin(targetTree)
						local searchVec = Entity.GetAbsOrigin(targetTree) + vectorTreeToEnemy:Normalized():Scaled(vectorTreeToEnemy:Length2D() + 350)
						local myDisToSearchPos = (searchVec - Entity.GetAbsOrigin(myHero)):Length2D()
						if #Wrap.TInRadius(searchVec, 300, true) < 1 and #Wrap.HInRadius(searchVec, 300, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY) < 1 then
							if myDisToSearchPos < minDis then
								shacklePos = searchVec
								minDis = myDisToSearchPos
							end
						end
					end
				end
			end	
		end
	end
	
	if shacklePos:__tostring() ~= Vector():__tostring() and minDis < dist then
		return shacklePos
	end

	return Vector()

end

function FAIO.getEnemyShackleTrees(myHero, enemy)

	if not myHero then return {} end
	if not enemy then return {} end

	local shackleSearchRange = 575

	local enemyPos = Entity.GetAbsOrigin(enemy)
	if Menu.IsEnabled(FAIO.optionHeroWindrunnerPredict) then
		enemyPos = FAIO.castPrediction(myHero, enemy, 0.15 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2))
	end

	local trees = Wrap.TInRadius(enemyPos, shackleSearchRange, true)
		if next(trees) == nil then return {} end

	local returnTrees = {}
	for _, targetTree in ipairs(trees) do		
		if targetTree then
			table.insert(returnTrees, targetTree)
		end
	end

	if next(returnTrees) ~= nil then
		return returnTrees
	end
	return {}

end
			
function FAIO.canEnemyBeShackledWithTree(myHero, enemy)

	if not myHero then return end
	if not enemy then return end

	local myMana = NPC.GetMana(myHero)
	local shackleShot = NPC.GetAbility(myHero, "windrunner_shackleshot")
		if not shackleShot then return false end
		if not Ability.IsCastable(shackleShot, myMana) then return false end

	local shackleSearchRange = 575
	local shackleCastRange = 785

	local enemyPos = Entity.GetAbsOrigin(enemy)
	if Menu.IsEnabled(FAIO.optionHeroWindrunnerPredict) then
		enemyPos = FAIO.castPrediction(myHero, enemy, 0.15 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2))
	end

	local directLineVector = enemyPos + (enemyPos - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(shackleSearchRange)

	local trees = Wrap.TInRadius(directLineVector, shackleSearchRange, true)
		if next(trees) == nil then return false end

		local shackleTree
		local minAngle = 180
		
		for _, targetTree in ipairs(trees) do		
			if targetTree then
				local myDisToEnemy = (Entity.GetAbsOrigin(myHero) - enemyPos):Length2D()
				local enemyDisToTree = (enemyPos - Entity.GetAbsOrigin(targetTree)):Length2D()
				if myDisToEnemy < shackleCastRange then
					if enemyDisToTree < shackleSearchRange then
						if targetTree ~= nil then
							local vectorEnemyToTree = Entity.GetAbsOrigin(targetTree) - enemyPos
							local vectormyHerotoEnemy = enemyPos - Entity.GetAbsOrigin(myHero)
							local tempProcessing = vectormyHerotoEnemy:Dot2D(vectorEnemyToTree) / (vectormyHerotoEnemy:Length2D() * vectorEnemyToTree:Length2D())
							if tempProcessing > 1 then
								tempProcessing = 1
							end
							local searchAngleRad = math.acos(tempProcessing)
							local searchAngle = (180 / math.pi) * searchAngleRad
							if searchAngle < minAngle then
								shackleTree = targetTree
								minAngle = searchAngle
							end
						end
					end
				end
			end
		end

		if shackleTree and minAngle < 23 then
			return true
		end
	
	return false

end

function FAIO.TimberIsTreeInRangeForChain(myHero, enemy)

	if not myHero then return end
	if not enemy then return end

	local myMana = NPC.GetMana(myHero)

	local timberChain = NPC.GetAbilityByIndex(myHero, 1)
		if not timberChain then return end
		if not Ability.IsCastable(timberChain, myMana) then return end

	local chainCastRange = Ability.GetCastRange(timberChain) + 45
	

	local enemyPos = Entity.GetAbsOrigin(enemy)
	if Menu.IsEnabled(FAIO.optionHeroTimberPredict) then
		enemyPos = FAIO.castPrediction(myHero, enemy, 0.7 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2))
	end

	local remainingDis = chainCastRange - (enemyPos - Entity.GetAbsOrigin(myHero)):Length2D()
	local directLineVector = enemyPos + (enemyPos - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(remainingDis)

	local trees = Wrap.TInRadius(directLineVector, remainingDis, true)
		if next(trees) == nil then return end

		local chainTree
		local minDis = 99999
		
		for _, targetTree in ipairs(trees) do		
			if targetTree then
				local myDisToTree = (Entity.GetAbsOrigin(targetTree) - Entity.GetAbsOrigin(myHero)):Length2D()
				if myDisToTree < chainCastRange then
					local vectormyHeroToTree = Entity.GetAbsOrigin(targetTree) - Entity.GetAbsOrigin(myHero)
					if FAIO.TimberAmIhittingWithChain(myHero, enemy, Entity.GetAbsOrigin(targetTree)) == true and myDisToTree < minDis then
						chainTree = targetTree
						minDis = myDisToTree
					end
				end
			end
		end


		if chainTree then
			return chainTree
		end
	
	return 

end

function FAIO.TimberAmIhittingWithChain(myHero, enemy, pos)

	if not myHero then return false end
	if not enemy then return false end
	if not pos then return false end

	local myPos = Entity.GetAbsOrigin(myHero)
	local chainDistance = (pos - myPos):Length2D()
	local chainVector = myPos - pos

	local enemyPos = Entity.GetAbsOrigin(enemy)
	if Menu.IsEnabled(FAIO.optionHeroTimberPredict) then
		enemyPos = FAIO.castPrediction(myHero, enemy, 0.7 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2))
	end

	local checkNum = tonumber(math.floor(chainDistance/150) + 1)
	for i = checkNum, 1, -1 do 
        	chainVector:Normalize()
        	chainVector:Scale(150 * (i-1))
        	local checkPos = pos + chainVector
		if (checkPos - enemyPos):Length2D() < 200 then
            		return true
		end
	end

	return false

end

function FAIO.TimberGetEnemyChainTrees(myHero, enemy)

	if not myHero then return {} end
	if not enemy then return {} end

	local myMana = NPC.GetMana(myHero)

	local timberChain = NPC.GetAbilityByIndex(myHero, 1)
		if not timberChain then return {} end
		if not Ability.IsCastable(timberChain, myMana) then return {} end
	
	local chainCastRange = Ability.GetCastRange(timberChain) + 45
	
	local enemyPos = Entity.GetAbsOrigin(enemy)
	if Menu.IsEnabled(FAIO.optionHeroTimberPredict) then
		enemyPos = FAIO.castPrediction(myHero, enemy, 0.7 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2))
	end

	local remainingDis = chainCastRange - (enemyPos - Entity.GetAbsOrigin(myHero)):Length2D()

	local trees = Wrap.TInRadius(enemyPos, remainingDis, true)
		if next(trees) == nil then return {} end

	local returnTrees = {}
	for _, targetTree in ipairs(trees) do		
		if targetTree then
			table.insert(returnTrees, targetTree)
		end
	end

	if next(returnTrees) ~= nil then
		return returnTrees
	end
	return {}

end

function FAIO.GetClosestPoint(A,  B,  P, segmentClamp)
	
	A:SetZ(0)
	B:SetZ(0)
	P:SetZ(0)

	local Ax = A:GetX()
	local Ay = A:GetY()
	local Bx = B:GetX()
	local By = B:GetY()
	local Px = P:GetX()
	local Py = P:GetY()

	local AP = P - A
	local AB = B - A

	local APx = AP:GetX()
	local APy = AP:GetY()

	local ABx = AB:GetX()
	local ABy = AB:GetY()

	local ab2 = ABx*ABx + ABy*ABy
	local ap_ab = APx*ABx + APy*ABy

	local t = ap_ab / ab2
 
	if (segmentClamp or true) then
		if (t < 0.0) then
			t = 0.0
		elseif (t > 1.0) then
			t = 1.0
		end
	end
 
	local Closest = Vector(Ax + ABx*t, Ay + ABy * t, 0)
 
	return Closest
end

function FAIO.TimberGetBestChainPos(myHero, enemy, dist)

	if not myHero then return Vector() end
	if not enemy then return Vector() end

	local myMana = NPC.GetMana(myHero)

	local timberChain = NPC.GetAbilityByIndex(myHero, 1)
		if not timberChain then return Vector() end
		if not Ability.IsCastable(timberChain, myMana) then return Vector() end

	local chainCastRange = Ability.GetCastRange(timberChain) + 45
	
	local enemyPos = Entity.GetAbsOrigin(enemy)
	if Menu.IsEnabled(FAIO.optionHeroTimberPredict) then
		enemyPos = FAIO.castPrediction(myHero, enemy, 0.7 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2))
	end

	local remainingDis = chainCastRange - (enemyPos - Entity.GetAbsOrigin(myHero)):Length2D()

	local chainPos = Vector()
	local minDis = 99999

	if FAIO.TimberIsTreeInRangeForChain(myHero, enemy) == nil then
		if next(FAIO.TimberGetEnemyChainTrees(myHero, enemy)) ~= nil then
			for _, targetTree in ipairs(FAIO.TimberGetEnemyChainTrees(myHero, enemy)) do
				if targetTree then
					local vectorTreeToEnemy = enemyPos - Entity.GetAbsOrigin(targetTree)
					local vectorTreeTomyHero = Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(targetTree)
					local searchVec = enemyPos + vectorTreeToEnemy:Normalized():Scaled(chainCastRange)
					local closestPointToSearchVec = FAIO.GetClosestPoint(enemyPos, searchVec, Entity.GetAbsOrigin(myHero), true)
					local disClosestPointToSearchVec = (closestPointToSearchVec - Entity.GetAbsOrigin(myHero)):Length2D()
					if #Wrap.TInRadius(closestPointToSearchVec, 300, true) < 1 then
						if (closestPointToSearchVec - Entity.GetAbsOrigin(targetTree)):Length2D() < chainCastRange then
							if disClosestPointToSearchVec < minDis then
								chainPos = closestPointToSearchVec
								minDis = disClosestPointToSearchVec
							end
						end
					end
				end
			end
		end
	end
		
	
	if chainPos:__tostring() ~= Vector():__tostring() and minDis < dist then
		return chainPos
	end

	return Vector()

end

function FAIO.TimberPanicIsTreeInChainWay(myHero, pos)

	if not myHero then return false end
	if not pos then return false end

	local myPos = Entity.GetAbsOrigin(myHero)
	local chainDistance = (pos - myPos):Length2D()
	local chainVector = myPos - pos

	local checkNum = tonumber(math.floor(chainDistance/50))
	for i = checkNum, 1, -1 do 
        	chainVector:Normalize()
        	chainVector:Scale(50 * (i))
        	local checkPos = pos + chainVector
		if #Wrap.TInRadius(checkPos, 50, true) < 1 then
            		return true
		end
	end

	return false

end

function FAIO.TimberGetEscapeChainTrees(myHero)

	if not myHero then return {} end

	local timberChain = NPC.GetAbilityByIndex(myHero, 1)
		if not timberChain then return {} end
	
	local chainCastRange = Ability.GetCastRange(timberChain) + 45
	
	local myPos = Entity.GetAbsOrigin(myHero)

	local trees = Wrap.TInRadius(myPos, chainCastRange, true)
		if next(trees) == nil then return {} end

	local returnTrees = {}
	for _, targetTree in ipairs(trees) do		
		if targetTree then
			local disTreeTomyHero = (Entity.GetAbsOrigin(targetTree) - Entity.GetAbsOrigin(myHero)):Length2D()
			if FAIO.TimberPanicIsTreeInChainWay(myHero, Entity.GetAbsOrigin(targetTree)) == true then
				table.insert(returnTrees, { disTreeTomyHero, targetTree })
			end
		end
	end

	if next(returnTrees) ~= nil then
		table.sort(returnTrees, function(a, b)
        		return a[1] > b[1]
    		end)

		return returnTrees
	end
	return {}

end

function FAIO.TimberGetEscapeChainTreesFountain(myHero)

	if not myHero then return {} end

	local timberChain = NPC.GetAbilityByIndex(myHero, 1)
		if not timberChain then return {} end
	
	local chainCastRange = Ability.GetCastRange(timberChain) + 45
	
	local myPos = Entity.GetAbsOrigin(myHero)

	local trees = Wrap.TInRadius(myPos, chainCastRange, true)
		if next(trees) == nil then return {} end

	local returnTrees = {}
	for _, targetTree in ipairs(trees) do		
		if targetTree then
			local myFountainPos = FAIO.GetMyFountainPos(myHero)
			local disTreeToFountain = (Entity.GetAbsOrigin(targetTree) - myFountainPos):Length2D()
			local dismyHeroToFountain = (myPos - myFountainPos):Length2D()
			if disTreeToFountain < dismyHeroToFountain then
				if FAIO.TimberPanicIsTreeInChainWay(myHero, Entity.GetAbsOrigin(targetTree)) == true then
					table.insert(returnTrees, { disTreeToFountain, targetTree })
				end
			end
		end
	end

	if next(returnTrees) ~= nil then
		table.sort(returnTrees, function(a, b)
        		return a[1] < b[1]
    		end)

		return returnTrees
	end
	return {}

end

function FAIO.TimberGetTreesFastMoveCursor(myHero)

	if not myHero then return {} end

	local timberChain = NPC.GetAbilityByIndex(myHero, 1)
		if not timberChain then return {} end
	
	local chainCastRange = Ability.GetCastRange(timberChain) + 45
	
	local myPos = Entity.GetAbsOrigin(myHero)

	local trees = Wrap.TInRadius(myPos, chainCastRange, true)
		if next(trees) == nil then return {} end

	local returnTrees = {}
	for _, targetTree in ipairs(trees) do		
		if targetTree then
		local cursorPos = Input.GetWorldCursorPos()
		local disTreeToCursor = (Entity.GetAbsOrigin(targetTree) - cursorPos):Length2D()
		local disTreeTomyHero = (Entity.GetAbsOrigin(targetTree) - myPos):Length2D()
		local dismyHeroToCursor = (myPos - cursorPos):Length2D()
			if disTreeToCursor < dismyHeroToCursor then
				if disTreeTomyHero > 500 then
					if FAIO.TimberPanicIsTreeInChainWay(myHero, Entity.GetAbsOrigin(targetTree)) == true then
						table.insert(returnTrees, { disTreeToCursor, targetTree })
					end
				end
			end
		end
	end

	if next(returnTrees) ~= nil then
		table.sort(returnTrees, function(a, b)
        		return a[1] < b[1]
    		end)

		return returnTrees
	end
	return {}

end

function FAIO.TargetIndicator(myHero)

	if not myHero then return end

	local curtime = GameRules.GetGameTime()	

	if Menu.GetValue(FAIO.optionLockTargetParticle) < 2 then
		if FAIO.LockedTarget ~= nil then
			if curtime > FAIO.particleNextTime then
				if FAIO.currentParticle > 0 then
					Particle.Destroy(FAIO.currentParticle)
					FAIO.currentParticle = 0
				end
	
				if Menu.GetValue(FAIO.optionLockTargetParticle) == 0 then
					local sparkParticle = Particle.Create("particles/items_fx/aegis_resspawn_flash.vpcf")
					FAIO.currentParticle = sparkParticle
			
					Particle.SetControlPoint(sparkParticle, 0, Entity.GetAbsOrigin(FAIO.LockedTarget))
				else
					local bloodParticle = Particle.Create("particles/items2_fx/soul_ring_blood.vpcf")
					FAIO.currentParticle = bloodParticle
					Particle.SetControlPoint(bloodParticle, 0, Entity.GetAbsOrigin(FAIO.LockedTarget))
				end

	      		FAIO.particleNextTime = curtime + 0.35
			end
		end
	else
		if (not FAIO.LockedTarget or FAIO.LockedTarget ~= FAIO.currentParticleTarget) and FAIO.currentParticle > 0 then
			Particle.Destroy(FAIO.currentParticle)			
			FAIO.currentParticle = 0
			FAIO.currentParticleTarget = FAIO.LockedTarget
		else
			if FAIO.currentParticle == 0 and FAIO.LockedTarget then
				local towerParticle = Particle.Create("particles/ui_mouseactions/range_finder_tower_aoe.vpcf", Enum.ParticleAttachment.PATTACH_INVALID, FAIO.LockedTarget)	
				FAIO.currentParticle = towerParticle
				FAIO.currentParticleTarget = FAIO.LockedTarget			
			end
			if FAIO.currentParticle > 0 then
				Particle.SetControlPoint(FAIO.currentParticle, 2, Entity.GetOrigin(myHero))
				Particle.SetControlPoint(FAIO.currentParticle, 6, Vector(1, 0, 0))
				Particle.SetControlPoint(FAIO.currentParticle, 7, Entity.GetOrigin(FAIO.currentParticleTarget))
			end
		end
	end

end

-- dodgeIT
function FAIO.dodgeIsTargetMe(myHero, unit, radius, castrange)

	if not myHero then return false end
	if not unit then return false end

	local angle = Entity.GetRotation(unit)

	local direction = angle:GetForward()
    	local name = NPC.GetUnitName(unit)
    		direction:SetZ(0)

    	local origin = Entity.GetAbsOrigin(unit)

	if radius == 0 then
		radius = 100
	end

    	local pointsNum = math.floor(castrange/50) + 1
    	for i = pointsNum,1,-1 do 
        	direction:Normalize()
        	direction:Scale(50*(i-1))
        	local pos = origin + direction
        	if NPC.IsPositionInRange(myHero, pos, radius + NPC.GetHullRadius(myHero), 0) then 
            		return true 
        	end
    	end 
    	return false

end

function FAIO.saverGetAllyTarget(myHero, unit, radius, castrange)

	if not myHero then return end
	if not unit then return end

	local angle = Entity.GetRotation(unit)

	local direction = angle:GetForward()
    		direction:SetZ(0)

    	local origin = Entity.GetAbsOrigin(unit)

	if radius == 0 then
		radius = 100
	end

	local alliesAround = Wrap.HeroesInRadius(unit, radius + castrange, Enum.TeamType.TEAM_ENEMY)
		if #alliesAround < 1 then return end

	local pointsNum = math.floor(castrange/50) + 1
	
	local targetAlly = nil
	local facing = 99999
	local lowest = 99999
	for i, v in ipairs(alliesAround) do
		if v and Entity.IsHero(v) and Wrap.EIsAlive(v) and v ~= myHero then
			if NPC.IsEntityInRange(unit, v, radius + castrange) and NPC.IsEntityInRange(myHero, v, 885) then
				if castrange > 1 then
					if NPC.GetTimeToFace(unit, v) < facing then
						facing = NPC.GetTimeToFace(unit, v)
						targetAlly = v
					end
				else
					if Entity.GetHealth(v) < lowest then
						lowest = Entity.GetHealth(v)
						targetAlly = v
					end
				end	
			end
		end
	end	

	return targetAlly

end

function FAIO.dodgerEmberSkillsChecker(myHero, skillName)

	if not myHero then return false end
	if not skillName then return false end

	if skillName == "ember_spirit_sleight_of_fist" then
		local effectRange = Ability.GetLevel(NPC.GetAbility(myHero, "ember_spirit_sleight_of_fist")) * 100 + 150
		for i = 0, math.floor(700 / effectRange) do
			if #Wrap.NInRadius(Entity.GetAbsOrigin(myHero) + Entity.GetRotation(myHero):GetForward():Normalized():Scaled(i * effectRange), effectRange, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY) > 0 then
				return true
			end
		end
	end

	if skillName == "ember_spirit_activate_fire_remnant" then
		if NPC.HasModifier(myHero, "modifier_ember_spirit_fire_remnant_timer") then
			return true
		end
	end

	return false

end

function FAIO.saveIt(info)

	local myHero = Heroes.GetLocal()
		if not myHero then return end
		if not Wrap.EIsAlive(myHero) then return end
	
	if not info then return end

	if not Menu.IsEnabled(FAIO.optionDefensiveItemsSaver) then return end

	local glimmer = NPC.GetItem(myHero, "item_glimmer_cape", true)
	local lotus = NPC.GetItem(myHero, "item_lotus_orb", true)
	local myMana = NPC.GetMana(myHero)

	local itemCheck = glimmer or lotus or nil
		if not itemCheck then return end

	if glimmer then
		if not Ability.IsCastable(glimmer, myMana) then
			if lotus then
				if not Ability.IsCastable(lotus, myMana) then
					return
				end
			else
				return
			end
		end
	else
		if lotus then
			if not Ability.IsCastable(lotus, myMana) then
				return
			end
		else
			return
		end
	end

	if info.target and Entity.IsHero(info.target) and Wrap.EIsAlive(info.target) then
		if info.lotus == 1 and NPC.IsLinkensProtected(info.target) then return end
		if info.lotus == 1 and NPC.HasModifier(info.target, "modifier_item_lotus_orb_active") then return end
		if info.style == 2 and NPC.HasState(info.target, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then return end
		if NPC.HasModifier(info.target, "modifier_item_glimmer_cape_fade") then return end
		if NPC.HasModifier(info.target, "modifier_templar_assassin_refraction_absorb") then return end
	end

	if os.clock() - FAIO.saverTiming < 0.5 then return end

	local curTime = GameRules.GetGameTime()

	local saveObject
		if lotus then
			if Ability.IsCastable(lotus, myMana) then
				if info.lotus == 0 then
					if glimmer then
						if Ability.IsCastable(glimmer, myMana) then
							saveObject = glimmer
						else
							saveObject = nil
						end
					else
						saveObject = nil
					end
				else
					saveObject = lotus
				end
			else
				if glimmer then
					if Ability.IsCastable(glimmer, myMana) then
						saveObject = glimmer
					else
						saveObject = nil
					end
				else
					saveObject = nil
				end
			end
		else
			if glimmer then
				if Ability.IsCastable(glimmer, myMana) then
					saveObject = glimmer
				else
					saveObject = nil
				end
			else
				saveObject = nil
			end
		end
	
	if saveObject == nil then return end		

	local target = info.target

	if target and Entity.IsHero(target) and NPC.IsEntityInRange(myHero, target, 895) then
		Ability.CastTarget(saveObject, target)
		FAIO.saverTiming = os.clock()
		FAIO.lastDefItemPop = os.clock()
		return
	end

end

function FAIO.dodgeIt(info)

	local myHero = Heroes.GetLocal()
		if not myHero then return end
		if not Wrap.EIsAlive(myHero) then return end
	
	if not info then return end

	if next(FAIO.dodgeItReadyTable) == nil then return end

	if not Menu.IsEnabled(FAIO.dodgeEnemySkillsOptionsTable[info.spellname]) then return end

	local myMana = NPC.GetMana(myHero)	

	local dodgeSelector
	local dodgeItemStyle
	local dodgeTargeting
	local dodgeTiming

	if next(FAIO.dodgeItSkillReady) ~= nil then
		if NPC.HasAbility(myHero, FAIO.dodgeItSkillReady[1]["skillname"]) then
			if Ability.IsReady(NPC.GetAbility(myHero, FAIO.dodgeItSkillReady[1]["skillname"])) and Ability.IsCastable(NPC.GetAbility(myHero, FAIO.dodgeItSkillReady[1]["skillname"]), myMana) then
				if FAIO.dodgeItSkillReady[1]["skillstyle"] <= info.style then
					if FAIO.dodgeItSkillReady[1]["skilloffset"] < info.delay then
						if FAIO.dodgeItSkillReady[1]["skillname"] == "slark_dark_pact" then
							if info.type == "disable" then
								dodgeSelector = NPC.GetAbility(myHero, FAIO.dodgeItSkillReady[1]["skillname"])
								dodgeItemStyle = FAIO.dodgeItSkillReady[1]["skillstyle"]
								dodgeTargeting = FAIO.dodgeItSkillReady[1]["skilltargeting"]
								dodgeTiming = FAIO.dodgeItSkillReady[1]["skilloffset"]
							end
						else
							dodgeSelector = NPC.GetAbility(myHero, FAIO.dodgeItSkillReady[1]["skillname"])
							dodgeItemStyle = FAIO.dodgeItSkillReady[1]["skillstyle"]
							dodgeTargeting = FAIO.dodgeItSkillReady[1]["skilltargeting"]
							dodgeTiming = FAIO.dodgeItSkillReady[1]["skilloffset"]
						end
					end
				end
			end
		end
		if #FAIO.dodgeItSkillReady > 1 then
			if dodgeSelector == nil then
				if NPC.HasAbility(myHero, FAIO.dodgeItSkillReady[2]["skillname"]) then
					if Ability.IsReady(NPC.GetAbility(myHero, FAIO.dodgeItSkillReady[2]["skillname"])) and Ability.IsCastable(NPC.GetAbility(myHero, FAIO.dodgeItSkillReady[2]["skillname"]), myMana) then
						if FAIO.dodgeItSkillReady[2]["skillstyle"] <= info.style then
							if FAIO.dodgeItSkillReady[2]["skilloffset"] < info.delay then
								dodgeSelector = NPC.GetAbility(myHero, FAIO.dodgeItSkillReady[2]["skillname"])
								dodgeItemStyle = FAIO.dodgeItSkillReady[2]["skillstyle"]
								dodgeTargeting = FAIO.dodgeItSkillReady[2]["skilltargeting"]
								dodgeTiming = FAIO.dodgeItSkillReady[2]["skilloffset"]
							end
						end
					end
				end
			end
		end		
	end

	if dodgeSelector ~= nil and Ability.GetName(dodgeSelector) == "ember_spirit_sleight_of_fist" then
		if not FAIO.dodgerEmberSkillsChecker(myHero, "ember_spirit_sleight_of_fist") then
			dodgeSelector = nil
		end
	end

	if dodgeSelector == nil then
		for i, v in ipairs(FAIO.dodgeItReadyTable) do
			if info.lotus == 0 then
				if info.global == 0 then
					if v.itemname ~= "item_lotus_orb" then
						if (NPC.GetUnitName(info.source) == "npc_dota_hero_lion" and info.style == 1) or NPC.GetUnitName(info.source) == "npc_dota_hero_nyx_assassin" or NPC.GetUnitName(info.source) == "npc_dota_hero_tidehunter" then
							if v.itemname ~= "item_manta" then
								if v.itemstyle <= info.style then
									if NPC.HasItem(myHero, v.itemname) then
										if Ability.IsReady(NPC.GetItem(myHero, v.itemname)) and Ability.IsCastable(NPC.GetItem(myHero, v.itemname), myMana) then
											dodgeSelector = NPC.GetItem(myHero, v.itemname, true)
											dodgeItemStyle = v.itemstyle
											dodgeTargeting = v.itemtargeting
											dodgeTiming = v.itemoffset
											break
										end
									end
								end
							end

						else
							if v.itemstyle <= info.style then
								if NPC.HasItem(myHero, v.itemname) then
									if Ability.IsReady(NPC.GetItem(myHero, v.itemname)) and Ability.IsCastable(NPC.GetItem(myHero, v.itemname), myMana) then
										dodgeSelector = NPC.GetItem(myHero, v.itemname, true)
										dodgeItemStyle = v.itemstyle
										dodgeTargeting = v.itemtargeting
										dodgeTiming = v.itemoffset
										break
									end
								end
							end
						end
					end
				else
					if v.itemname ~= "item_blink" then
						if v.itemstyle <= info.style then
							if NPC.HasItem(myHero, v.itemname) then
								if Ability.IsReady(NPC.GetItem(myHero, v.itemname)) and Ability.IsCastable(NPC.GetItem(myHero, v.itemname), myMana) then
									dodgeSelector = NPC.GetItem(myHero, v.itemname, true)
									dodgeItemStyle = v.itemstyle
									dodgeTargeting = v.itemtargeting
									dodgeTiming = v.itemoffset
									break
								end
							end
						end
					end
				end			
			else
				if v.itemstyle <= info.style then
					if NPC.HasItem(myHero, v.itemname) then
						if Ability.IsReady(NPC.GetItem(myHero, v.itemname)) and Ability.IsCastable(NPC.GetItem(myHero, v.itemname), myMana) then
							dodgeSelector = NPC.GetItem(myHero, v.itemname, true)
							dodgeItemStyle = v.itemstyle
							dodgeTargeting = v.itemtargeting
							dodgeTiming = v.itemoffset
							break
						end
					end
				end
			end	
		end
	end

	if NPC.GetUnitName(myHero) == "npc_dota_hero_ember_spirit" and dodgeSelector == nil then
		if Menu.IsEnabled(FAIO.dodgeEnemyHeroSpecialEmber) then
			if FAIO.dodgerEmberSkillsChecker(myHero, "ember_spirit_activate_fire_remnant") then
				dodgeSelector = NPC.GetAbility(myHero, "ember_spirit_activate_fire_remnant")
				dodgeItemStyle = 0
				dodgeTargeting = "position"
				dodgeTiming = 0.1
			end
		end
	end		

	if dodgeSelector == nil then 
		return
	end


	local delay = info.delay
		if NPC.GetUnitName(info.source) == "npc_dota_hero_lina" then
			if Ability.GetName(dodgeSelector) == "item_blink" or Ability.GetName(dodgeSelector) == "item_lotus_orb" or Ability.GetName(dodgeSelector) == "nyx_assassin_spiked_carapace" or Ability.GetName(dodgeSelector) == "sandking_sand_storm" or Ability.GetName(dodgeSelector) == "templar_assassin_meld" then
				delay = info.delay - 0.225
			end
		elseif NPC.GetUnitName(info.source) == "npc_dota_hero_lion" and info.spellname == "lion_finger_of_death" then
			if Ability.GetName(dodgeSelector) == "item_blink" or Ability.GetName(dodgeSelector) == "item_lotus_orb" or Ability.GetName(dodgeSelector) == "nyx_assassin_spiked_carapace" or Ability.GetName(dodgeSelector) == "sandking_sand_storm" or Ability.GetName(dodgeSelector) == "templar_assassin_meld" then
				delay = info.delay - 0.275
			end
		end

	if info.time + delay - dodgeTiming + 0.05 < GameRules.GetGameTime() then return end

	if info.lotus == 1 and NPC.IsLinkensProtected(myHero) then return end
	if info.lotus == 1 and NPC.HasModifier(myHero, "modifier_item_lotus_orb_active") then return end
	if info.style == 2 and NPC.HasState(myHero, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then return end
	if NPC.HasModifier(myHero, "modifier_item_glimmer_cape_fade") then return end
	if NPC.HasModifier(myHero, "modifier_templar_assassin_refraction_absorb") then return end
	if NPC.HasModifier(myHero, "modifier_item_blade_mail_reflect") then return end
	if NPC.HasModifier(myHero, "modifier_item_hurricane_pike_range") then return end
	
	if NPC.HasItem(myHero, "item_blade_mail", true) and Menu.IsEnabled(FAIO.optionItemBlademail) and Ability.IsCastable(NPC.GetItem(myHero, "item_blade_mail", true), myMana) then return end
	if NPC.HasItem(myHero, "item_hurricane_pike", true) and Menu.IsEnabled(FAIO.optionItemHurricane) and Ability.IsCastable(NPC.GetItem(myHero, "item_hurricane_pike", true), myMana) then return end

	if NPC.HasItem(myHero, "item_blade_mail", true) and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_blade_mail", true)) > -1 and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_blade_mail", true)) < 0.25 then return end
	if NPC.HasItem(myHero, "item_hurricane_pike", true) and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_hurricane_pike", true)) > -1 and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_hurricane_pike", true)) < 0.25 then return end
	
	local projectilespeed = 0
		if info.projectilespeed ~= nil then
			projectilespeed = info.projectilespeed
		end

	local projectileextradelay = 0
		if info.projectileextradelay ~= nil then
			projectileextradelay = info.projectileextradelay
		end

	if next(FAIO.dodgeItTable) == nil then
		table.insert(FAIO.dodgeItTable, {casttime = info.time, delay = delay, unit = info.source, dodgeobject = dodgeSelector, objecttargeting = dodgeTargeting, objectoffset = dodgeTiming, castpoint = info.castpoint, spellname = info.spellname, originpos = Entity.GetAbsOrigin(info.source), projectilespeed = projectilespeed, projectileextradelay = projectileextradelay})
	end

end

function FAIO.dodgerSkillAvailable(myHero)

	if not myHero then return end

	if next(FAIO.dodgeItSkillReady) == nil then

		for i = 1, #FAIO.dodgeItSkills do
			if NPC.HasAbility(myHero, FAIO.dodgeItSkills[i][1]) then
				if Menu.IsEnabled(FAIO.dodgeEnemyHeroskillsOptionsTable[FAIO.dodgeItSkills[i][1]]) then
					if Ability.GetLevel(NPC.GetAbility(myHero, FAIO.dodgeItSkills[i][1])) > 0 then
						table.insert(FAIO.dodgeItSkillReady, {skillname = FAIO.dodgeItSkills[i][1], skillstyle = FAIO.dodgeItSkills[i][2], skilltargeting = FAIO.dodgeItSkills[i][3], skilloffset = FAIO.dodgeItSkills[i][4] })
					end
				end
			end
		end
	end

end
				
function FAIO.dodgerSelectItemorSkill(myHero)

	if not myHero then return end

	if next(FAIO.dodgeItReadyTable) == nil then

		for i = 1, #FAIO.dodgeItItems do
			if Menu.GetValue(FAIO.dodgeItOptionTable[i]) > 0 then
				table.insert(FAIO.dodgeItReadyTable, { prio = Menu.GetValue(FAIO.dodgeItOptionTable[i]), itemname = FAIO.dodgeItItems[i][1], itemstyle = FAIO.dodgeItItems[i][2], itemtargeting = FAIO.dodgeItItems[i][3], itemoffset = FAIO.dodgeItItems[i][4] })
			end
		end
	end

	table.sort(FAIO.dodgeItReadyTable, function(a, b)
       		return a.prio < b.prio
    	end)

end

function FAIO.dodgerRangeOffsetter(myHero, enemy, dodgeSkillName, attackSkillName)

	if not myHero then return end

	if not dodgeSkillName and not attackSkillName then 
		return 
	end

	if dodgeSkillName == "item_blink" then 
		return Entity.GetAbsOrigin(myHero) + Entity.GetRotation(myHero):GetForward():Normalized():Scaled(1150)
	end

	local maxRange = 1000
		if dodgeSkillName == "morphling_waveform" then
			maxRange = 990
		elseif dodgeSkillName == "phantom_lancer_doppelwalk" then
			maxRange = 590
		elseif dodgeSkillName == "faceless_void_time_walk" then
			maxRange = 670
		elseif dodgeSkillName == "ember_spirit_sleight_of_fist" then
			maxRange = 690
		end

	local minRange = 190
		if dodgeSkillName == "morphling_waveform" or dodgeSkillName == "faceless_void_time_walk" then
			minRange = maxRange
		end


	if dodgeSkillName ~= "ember_spirit_sleight_of_fist" then
		if attackSkillName == "enigma_black_hole" or attackSkillName == "faceless_void_chronosphere" then
			return Entity.GetAbsOrigin(myHero) + Entity.GetRotation(myHero):GetForward():Normalized():Scaled(590)
		elseif attackSkillName == "lion_impale" or attackSkillName == "nyx_assassin_impale" or spellname == "pudge_dismember" then
			return Entity.GetAbsOrigin(myHero) + Entity.GetRotation(myHero):GetForward():Normalized():Scaled(350)
		elseif attackSkillName == "queenofpain_sonic_wave" or attackSkillName == "tidehunter_ravage" then
			return Entity.GetAbsOrigin(myHero) + Entity.GetRotation(myHero):GetForward():Normalized():Scaled(maxRange)
		else
			return Entity.GetAbsOrigin(myHero) + Entity.GetRotation(myHero):GetForward():Normalized():Scaled(minRange)
		end
	else
		local effectRange = Ability.GetLevel(NPC.GetAbility(myHero, "ember_spirit_sleight_of_fist")) * 100 + 150 - 1
		for i = 0, math.ceil(maxRange / effectRange) do
			if #Wrap.NInRadius(Entity.GetAbsOrigin(myHero) + Entity.GetRotation(myHero):GetForward():Normalized():Scaled(i * effectRange), effectRange, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY) > 0 then
				return Entity.GetAbsOrigin(myHero) + Entity.GetRotation(myHero):GetForward():Normalized():Scaled(i * effectRange + 1)
			end
		end
	end

end

function FAIO.dodgerProjectileTimingAdjuster(myHero)

	if not myHero then return end

	if next(FAIO.dodgeItTable) == nil then return end

	if os.clock() - FAIO.dodgerProjectileAdjustmentTick < 0.05 then return end

	for i, info in pairs(FAIO.dodgeItTable) do
		if info.delay > info.castpoint then
			if info.spellname ~= "lion_finger_of_death" and info.spellname ~= "lina_laguna_blade" then
				local originPos = info.originpos
				local myHullSize = NPC.GetHullRadius(myHero)
				local projectileStart = info.casttime + info.castpoint
				local projectileSpeed = info.projectilespeed
				local timeElapsed = math.max((GameRules.GetGameTime() - projectileStart), 0)
				local projectilePos = originPos + (Entity.GetAbsOrigin(myHero) - originPos):Normalized():Scaled(timeElapsed*projectileSpeed)
				local myDisToOrigin = (Entity.GetAbsOrigin(myHero) - originPos):Length2D() - myHullSize
				local projectilDisToOrigin = (projectilePos - originPos):Length2D()
				local myDisToProjectile = (Entity.GetAbsOrigin(myHero) - projectilePos):Length2D() 
				if projectilDisToOrigin < myDisToOrigin then
					if myDisToProjectile > 100 and timeElapsed > 0 then
						local remainingTravelTime = ((Entity.GetAbsOrigin(myHero) - projectilePos):Length2D() - myHullSize) / projectileSpeed
						local adjustedDelay = math.max(info.projectileextradelay, 0.034)
							if info.projectileextradelay < 0 then
								adjustedDelay = info.projectileextradelay
							end
						local processImpactTime = info.castpoint + timeElapsed + remainingTravelTime - adjustedDelay
						if math.abs(info.delay - processImpactTime) > 0.015 then
							if FAIO.dodgeItTable[i] ~= nil then
								FAIO.dodgeItTable[i]["delay"] = processImpactTime
								FAIO.dodgerProjectileAdjustmentTick = os.clock()
							end
						end
					end
				else
					FAIO.dodgeItTable[i] = nil
				end
			end
		end
	end			

end

function FAIO.dodger(myHero)

	if not myHero then return end

	local myMana = NPC.GetMana(myHero)

	if next(FAIO.dodgeItTable) == nil then
		for i = 1, Heroes.Count() do
			local enemy = Heroes.Get(i)
			if enemy and Entity.IsHero(enemy) and not Entity.IsSameTeam(myHero, enemy) and not Entity.IsDormant(enemy) and (NPC.GetUnitName(enemy) == "npc_dota_hero_axe" or NPC.GetUnitName(enemy) == "npc_dota_hero_sand_king") and not NPC.IsIllusion(enemy) then
				if Wrap.EIsAlive(enemy) then
					local axe_call = NPC.GetAbility(enemy, "axe_berserkers_call")
					local call_range = 300
					if axe_call and Ability.IsInAbilityPhase(axe_call) and NPC.IsEntityInRange(myHero, enemy, call_range) then
						FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = 0.4; style = 1; source = enemy, lotus = 0, castpoint = 0.4, spellname = "axe_berserkers_call", global = 0, type = "disable"})
						break
						return
					end
					local burrowStrike = NPC.GetAbility(enemy, "sandking_burrowstrike")
					local burrowRange = 650
					local hitRange = 175
						if NPC.HasItem(enemy, "item_ultimate_scepter", true) or NPC.HasModifier(enemy, "modifier_item_ultimate_scepter_consumed") then
							burrowRange = 1300
						end
					if NPC.HasModifier(enemy, "modifier_sandking_burrowstrike") then
						if FAIO.dodgeIsTargetMe(myHero, enemy, hitRange, burrowRange) then
							FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = 0.05; style = 2; source = enemy, lotus = 1, castpoint = 0, spellname = "sandking_burrowstrike", global = 0, type = "disable"})
							break
							return
						else
							if NPC.IsEntityInRange(myHero, enemy, hitRange+burrowRange+885) then
								local targetAlly = FAIO.saverGetAllyTarget(myHero, enemy, hitRange, burrowRange)
								if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
									FAIO.saveIt({lotus = 1, target = targetAlly})
								end
							end
						end
					end
				end
			end
		end
	end

	if next(FAIO.dodgeItTable) == nil then
		if NPC.GetUnitName(myHero) == "npc_dota_hero_alchemist" then
			if NPC.HasModifier(myHero, "modifier_alchemist_unstable_concoction") then
				if Modifier.GetCreationTime(NPC.GetModifier(myHero, "modifier_alchemist_unstable_concoction")) + 5.5 - GameRules.GetGameTime() < 0.15 then
					FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = 0.15; style = 1; source = myHero, lotus = 0, castpoint = 0, spellname = "alchemist_unstable_concoction_throw", global = 0, type = "disable"})
					return
				end
			end
		end
	end

	if next(FAIO.dodgeItTable) == nil then return end
	FAIO.dodgerProjectileTimingAdjuster(myHero)
	local curTime = GameRules.GetGameTime()

	if not FAIO.heroCanCastItems(myHero) then
		return
	end

	if os.clock() - FAIO.dodgeTiming < 0.5 then return end

	local dodgeInfo = FAIO.dodgeItTable[1]
		local casttime = dodgeInfo.casttime
		local delay = dodgeInfo.delay
		local unit = dodgeInfo.unit
		local castpoint = dodgeInfo.castpoint
		local spellname = dodgeInfo.spellname
		local dodgeobject = dodgeInfo.dodgeobject
		local objecttargeting = dodgeInfo.objecttargeting
		local objectoffset = dodgeInfo.objectoffset

		if curTime > casttime + delay + 0.05 then
			FAIO.dodgeItTable = {}
			return
		end

	if NPC.GetUnitName(unit) == "npc_dota_hero_sniper" then
		if curTime >= casttime + delay - objectoffset - NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) then
			if NPC.HasModifier(myHero, "modifier_sniper_assassinate") then
				if objecttargeting == "no target" then
					Ability.CastNoTarget(dodgeobject)
					FAIO.dodgeTiming = os.clock()
					FAIO.dodgeItTable = {}
					return
				elseif objecttargeting == "position" then
					if FAIO.dodgerRangeOffsetter(myHero, unit, Ability.GetName(dodgeobject), spellname) ~= nil then
						Ability.CastPosition(dodgeobject, FAIO.dodgerRangeOffsetter(myHero, unit, Ability.GetName(dodgeobject), spellname))
						FAIO.dodgeTiming = os.clock()
						FAIO.dodgeItTable = {}
						return
					end
				elseif objecttargeting == "target" then
					Ability.CastTarget(dodgeobject, myHero)
					FAIO.dodgeTiming = os.clock()
					FAIO.dodgeItTable = {}
					return
				end
			end
		end
	else	
		if unit and not Entity.IsDormant(unit) then
			if curTime >= casttime + castpoint - objectoffset - NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) then
				if not Ability.IsInAbilityPhase(NPC.GetAbility(unit, spellname)) and castpoint > 0 then
					if delay > castpoint then
						if Ability.SecondsSinceLastUse(NPC.GetAbility(unit, spellname)) == -1 and spellname ~= "alchemist_unstable_concoction_throw" then
							FAIO.dodgeItTable = {}
							return
						else
							if curTime >= casttime + delay - objectoffset - NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) then

								if objecttargeting == "no target" then
									Ability.CastNoTarget(dodgeobject)
									FAIO.dodgeTiming = os.clock()
									FAIO.dodgeItTable = {}
									return
								elseif objecttargeting == "position" then
									if FAIO.dodgerRangeOffsetter(myHero, unit, Ability.GetName(dodgeobject), spellname) ~= nil then
										Ability.CastPosition(dodgeobject, FAIO.dodgerRangeOffsetter(myHero, unit, Ability.GetName(dodgeobject), spellname))
										FAIO.dodgeTiming = os.clock()
										FAIO.dodgeItTable = {}
										return
									end
								elseif objecttargeting == "target" then
									Ability.CastTarget(dodgeobject, myHero)
									FAIO.dodgeTiming = os.clock()
									FAIO.dodgeItTable = {}
									return
								end
							end
						end
					else
						FAIO.dodgeItTable = {}
						return
					end
				else
					if curTime >= casttime + delay - objectoffset - NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) then
						if objecttargeting == "no target" then
							Ability.CastNoTarget(dodgeobject)
							FAIO.dodgeTiming = os.clock()
							FAIO.dodgeItTable = {}
							return
						elseif objecttargeting == "position" then
							if FAIO.dodgerRangeOffsetter(myHero, unit, Ability.GetName(dodgeobject), spellname) ~= nil then
								Ability.CastPosition(dodgeobject, FAIO.dodgerRangeOffsetter(myHero, unit, Ability.GetName(dodgeobject), spellname))
								FAIO.dodgeTiming = os.clock()
								FAIO.dodgeItTable = {}
								return
							end
						elseif objecttargeting == "target" then
							Ability.CastTarget(dodgeobject, myHero)
							FAIO.dodgeTiming = os.clock()
							FAIO.dodgeItTable = {}
							return
						end
					end
				end
			end
		else
			if curTime >= casttime + delay - objectoffset - NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) then
				if objecttargeting == "no target" then
					Ability.CastNoTarget(dodgeobject)
					FAIO.dodgeTiming = os.clock()
					FAIO.dodgeItTable = {}
					return
				elseif objecttargeting == "position" then
					if FAIO.dodgerRangeOffsetter(myHero, unit, Ability.GetName(dodgeobject), spellname) ~= nil then
						Ability.CastPosition(dodgeobject, FAIO.dodgerRangeOffsetter(myHero, unit, Ability.GetName(dodgeobject), spellname))
						FAIO.dodgeTiming = os.clock()
						FAIO.dodgeItTable = {}
						return
					end
				elseif objecttargeting == "target" then
					Ability.CastTarget(dodgeobject, myHero)
					FAIO.dodgeTiming = os.clock()
					FAIO.dodgeItTable = {}
					return
				end
			end
		end
	end

end

function FAIO.dodgeProcessing(myHero, unit, activity, castpoint)

	if not myHero then return end
	if Entity.IsSameTeam(myHero, unit) then return end

	local distance = (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(unit)):Length2D() - 25

	if NPC.GetUnitName(unit) == "npc_dota_hero_antimage" then
		local radius = 500
		local castrange = 600
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and FAIO.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 1; source = unit, lotus = 1, castpoint = castpoint, spellname = "antimage_mana_void", global = 0, type = "nuke"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = FAIO.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						FAIO.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end



	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_alchemist" then
		local radius = 0
		local castrange = 775
		local impactTime = distance / 900
		if activity == Enum.GameActivity.ACT_DOTA_ALCHEMIST_CONCOCTION_THROW then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and FAIO.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint + impactTime; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "alchemist_unstable_concoction_throw", global = 0, type = "disable", projectilespeed = 900, projectileextradelay = -0.001})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = FAIO.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						FAIO.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end		
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_bane" then
		local radius = 0
		local castrange = 800
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and FAIO.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 1; source = unit, lotus = 1, castpoint = castpoint, spellname = "bane_fiends_grip", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = FAIO.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						FAIO.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end		
	end	

	if NPC.GetUnitName(unit) == "npc_dota_hero_batrider" then
		local radius = 0
		local castrange = 200
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and FAIO.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 1; source = unit, lotus = 1, castpoint = castpoint, spellname = "batrider_flaming_lasso", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = FAIO.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						FAIO.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end	

--	if NPC.GetUnitName(unit) == "npc_dota_hero_beastmaster" then
--		local radius = 
--		local castrange = 
--		if sequenceName == "cast4_primal_roar_anim" and NPC.IsEntityInRange(myHero, unit, radius+castrange) then
--			if FAIO.dodgeIsTargetMe(myHero, unit, radius, castrange) then
--				FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 1; source = unit, lotus = 0, castpoint = castpoint, spellname = })
--			end
--		end
--	end	

	if NPC.GetUnitName(unit) == "npc_dota_hero_bloodseeker" then
		local radius = 0
		local castrange = 1000
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and FAIO.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 1; source = unit, lotus = 1, castpoint = castpoint, spellname = "bloodseeker_rupture", global = 0, type = "nuke"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = FAIO.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						FAIO.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end	

	if NPC.GetUnitName(unit) == "npc_dota_hero_centaur" then
		local radius = 315
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_1 then
			if NPC.IsEntityInRange(myHero, unit, radius) then
				FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 2; source = unit, lotus = 0, castpoint = castpoint, spellname = "centaur_hoof_stomp", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+885) then
					local targetAlly = FAIO.saverGetAllyTarget(myHero, unit, radius, 0)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						FAIO.saveIt({lotus = 0, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_chaos_knight" then
		local radius = 0
		local castrange = 500
		local impactTime = distance / 1000 - 0.15
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_1 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and FAIO.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint+impactTime; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "chaos_knight_chaos_bolt", global = 0, type = "disable", projectilespeed = 1000, projectileextradelay = 0.15})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = FAIO.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						FAIO.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end	
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_crystal_maiden" then
		local radius = 0
		local castrange = 650
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_2 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and FAIO.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "crystal_maiden_frostbite", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = FAIO.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						FAIO.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_death_prophet" then
		local radius = 425
		local castrange = 1000
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_2 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and FAIO.dodgeIsTargetMe(myHero, unit, 425, 1000) then
				FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 2; source = unit, lotus = 0, castpoint = castpoint, spellname = "death_prophet_silence", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = FAIO.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						FAIO.saveIt({lotus = 0, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_doom_bringer" then
		local radius = 0
		local castrange = 550
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_6 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and FAIO.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 1; source = unit, lotus = 1, castpoint = castpoint, spellname = "doom_bringer_doom", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = FAIO.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						FAIO.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_drow_ranger" then
		local radius = 900
		local castrange = 250
		local impactTime = distance / 2000 - 0.1
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_2 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and FAIO.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint+impactTime; style = 2; source = unit, lotus = 0, castpoint = castpoint, spellname = "drow_ranger_wave_of_silence", global = 0, type = "disable", projectilespeed = 2000, projectileextradelay = 0.080})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = FAIO.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						FAIO.saveIt({lotus = 0, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_earthshaker" then
		local radius1 = 225
		local castrange = 1400
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_1 then
			if NPC.IsEntityInRange(myHero, unit, radius1+castrange) and FAIO.dodgeIsTargetMe(myHero, unit, radius1, castrange) then
				FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 2; source = unit, lotus = 0, castpoint = castpoint, spellname = "earthshaker_fissure", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius1+castrange+885) then
					local targetAlly = FAIO.saverGetAllyTarget(myHero, unit, radius1, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						FAIO.saveIt({lotus = 0, target = targetAlly})
					end
				end
			end
		end

		local radius2 = 350
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_2 then
			if NPC.IsEntityInRange(myHero, unit, radius2) then
				FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 2; source = unit, lotus = 0, castpoint = castpoint, spellname = "earthshaker_enchant_totem", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius2+885) then
					local targetAlly = FAIO.saverGetAllyTarget(myHero, unit, radius2, 0)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						FAIO.saveIt({lotus = 0, target = targetAlly})
					end
				end
			end	
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_enigma" then
		local radius = 420
		local castrange = 275
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and FAIO.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 0; source = unit, lotus = 0, castpoint = castpoint, spellname = "enigma_black_hole", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = FAIO.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						FAIO.saveIt({lotus = 0, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_faceless_void" then
		local radius = 425
		local castrange = 600
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and FAIO.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 0; source = unit, lotus = 0, castpoint = castpoint, spellname = "faceless_void_chronosphere", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = FAIO.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						FAIO.saveIt({lotus = 0, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_juggernaut" then
		local radius = 425
		local castrange = 350
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and FAIO.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 1; source = unit, lotus = 1, castpoint = castpoint, spellname = "juggernaut_omni_slash", global = 0, type = "nuke"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = FAIO.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						FAIO.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_legion_commander" then
		local radius = 0
		local castrange = 300
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and FAIO.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 1; source = unit, lotus = 0, castpoint = castpoint, spellname = "legion_commander_duel", global = 0, type = "nuke"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = FAIO.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						FAIO.saveIt({lotus = 0, target = targetAlly})
					end
				end
			end	
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_lich" then
		local radius = 0
		local castrange = 1000
		local impactTime = distance / 850
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and FAIO.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint + impactTime; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "lich_chain_frost", global = 0, type = "nuke", projectilespeed = 850, projectileextradelay = 0})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = FAIO.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						FAIO.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end	
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_lina" then
		local radius = 0
		local castrange = 725
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and FAIO.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint + 0.275; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "lina_laguna_blade", global = 0, type = "nuke"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = FAIO.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						FAIO.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_lion" then
		local radius1 = 125
		local castrange1 = 725
		local impactTime = distance / 1600 - 0.2
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_1 then
			if NPC.IsEntityInRange(myHero, unit, radius1+castrange1) and FAIO.dodgeIsTargetMe(myHero, unit, radius1, castrange1) then
				FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint+impactTime; style = 2; source = unit, lotus = 0, castpoint = castpoint, spellname = "lion_impale", global = 0, type = "disable", projectilespeed = 1600, projectileextradelay = 0.2})
			else
				if NPC.IsEntityInRange(myHero, unit, radius1+castrange1+885) then
					local targetAlly = FAIO.saverGetAllyTarget(myHero, unit, radius1, castrange1)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						FAIO.saveIt({lotus = 0, target = targetAlly})
					end
				end
			end
		end

		local radius2 = 0
		local castrange2 = 900
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius2+castrange2) and FAIO.dodgeIsTargetMe(myHero, unit, radius2, castrange2) then
				FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint + 0.275; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "lion_finger_of_death", global = 0, type = "nuke"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius2+castrange2+885) then
					local targetAlly = FAIO.saverGetAllyTarget(myHero, unit, radius2, castrange2)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						FAIO.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_luna" then
		local radius = 0
		local castrange = 800
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_1 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and FAIO.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "luna_lucent_beam", global = 0, type = "nuke"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = FAIO.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						FAIO.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_magnataur" then
		local radius = 0
		local castrange = 460
		local instant_radius = 150 + 50
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) then
				local delay = castpoint
					if distance <= instant_radius then delay = 0 end
				FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 1; source = unit, lotus = 0, castpoint = castpoint, spellname = "magnataur_reverse_polarity", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = FAIO.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						FAIO.saveIt({lotus = 0, target = targetAlly})
					end
				end
			end
		end	
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_necrolyte" then
		local radius = 0
		local castrange = 650
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and FAIO.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 1; source = unit, lotus = 1, castpoint = castpoint, spellname = "necrolyte_reapers_scythe", global = 0, type = "nuke"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = FAIO.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						FAIO.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_night_stalker" then
		local radius = 0
		local castrange = 650
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_2 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and FAIO.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint+0.075; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "night_stalker_crippling_fear", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = FAIO.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						FAIO.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_nyx_assassin" then
		local radius = 125
		local castrange = 700
		local impactTime = distance / 1600 + 0.1
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_1 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and FAIO.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 2; source = unit, lotus = 0, castpoint = castpoint, spellname = "nyx_assassin_impale", global = 0, type = "disable", projectilespeed = 1600, projectileextradelay = -0.1})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = FAIO.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						FAIO.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_ogre_magi" then
		local radius = 0
		local castrange = 600
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_1 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and FAIO.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "ogre_magi_fireblast", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = FAIO.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						FAIO.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_obsidian_destroyer" then
		local radius1 = 0
		local castrange1 = 450
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_2 then
			if NPC.IsEntityInRange(myHero, unit, radius1+castrange1) and FAIO.dodgeIsTargetMe(myHero, unit, radius1, castrange1) then
				FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "obsidian_destroyer_astral_imprisonment", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius1+castrange1+885) then
					local targetAlly = FAIO.saverGetAllyTarget(myHero, unit, radius1, castrange1)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						FAIO.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end	
		end

		local radius2 = 575
		local castrange2 = 700
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius2+castrange2) and FAIO.dodgeIsTargetMe(myHero, unit, radius2, castrange2) then
				FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 2; source = unit, lotus = 0, castpoint = castpoint, spellname = "obsidian_destroyer_sanity_eclipse", global = 0, type = "nuke"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius2+castrange2+885) then
					local targetAlly = FAIO.saverGetAllyTarget(myHero, unit, radius2, castrange2)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						FAIO.saveIt({lotus = 0, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_puck" then
		local radius = 450
		local castrange = 0
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_2 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) then
				FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 2; source = unit, lotus = 0, castpoint = castpoint, spellname = "puck_waning_rift", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = FAIO.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						FAIO.saveIt({lotus = 0, target = targetAlly})
					end
				end
			end	
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_pudge" then
		local radius = 0
		local castrange = 250
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and FAIO.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 1; source = unit, lotus = 1, castpoint = castpoint, spellname = "pudge_dismember", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = FAIO.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						FAIO.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end	
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_queenofpain" then
		local radius = 450
		local castrange = 900
		local impactTime = distance / 900 - 0.25
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and FAIO.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint+impactTime; style = 0; source = unit, lotus = 0, castpoint = castpoint, spellname = "queenofpain_sonic_wave", global = 0, type = "nuke", projectilespeed = 900, projectileextradelay = 0.25})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = FAIO.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						FAIO.saveIt({lotus = 0, target = targetAlly})
					end
				end
			end	
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_rubick" then
		local radius = 0
		local castrange = 700
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_1 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and FAIO.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "rubick_telekinesis", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = FAIO.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						FAIO.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_shadow_demon" then
		local radius = 0
		local castrange = 700
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_1 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and FAIO.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "shadow_demon_disruption", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = FAIO.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						FAIO.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_shadow_shaman" then
		local radius = 0
		local castrange = 500
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_3 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and FAIO.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "shadow_shaman_shackles", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = FAIO.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						FAIO.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_silencer" then
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 1; source = unit, lotus = 0, castpoint = castpoint, spellname = "silencer_global_silence", global = 1, type = "disable"})
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_skywrath_mage" then
		local radius = 0
		local castrange = 750
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_3 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and FAIO.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "skywrath_mage_ancient_seal", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = FAIO.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						FAIO.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_slardar" then
		local radius = 350
		local castrange = 0
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_2 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) then
				FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 2; source = unit, lotus = 0, castpoint = castpoint, spellname = "slardar_slithereen_crush", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = FAIO.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						FAIO.saveIt({lotus = 0, target = targetAlly})
					end
				end
			end	
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_sniper" then
		local radius = 0
		local castrange = 3000
		local impactTime = distance / 2500 - 0.05
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and FAIO.dodgeIsTargetMe(myHero, unit, radius, castrange) then	
				FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint+impactTime; style = 1; source = unit, lotus = 1, castpoint = castpoint, spellname = "sniper_assassinate", global = 0, type = "nuke", projectilespeed = 2500, projectileextradelay = 0.05})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = FAIO.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						FAIO.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end
		

--	if NPC.GetUnitName(unit) == "npc_dota_hero_spirit_breaker" then
--		local radius = 0
--		local castrange = 850
--	--	if sequenceName == "ultimate_anim" and NPC.IsEntityInRange(myHero, unit, radius+castrange) then
--		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 and NPC.IsEntityInRange(myHero, unit, radius+castrange) then
--			if FAIO.dodgeIsTargetMe(myHero, unit, radius, castrange) then
--				FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 1; source = unit, lotus = 1, castpoint = castpoint, spellname = "spirit_breaker_nether_strike", global = 0, type = "nuke"})
--			end
--		end
--	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_storm_spirit" then
		local radius = 0
		local castrange = 350
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_2 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and FAIO.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "storm_spirit_electric_vortex", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = FAIO.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						FAIO.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_sven" then
		local radius = 0
		local castrange = 600
		local impactTime = distance / 1000 - 0.15
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_1 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and FAIO.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint+impactTime; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "sven_storm_bolt", global = 0, type = "disable", projectilespeed = 1000, projectileextradelay = 0.15})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = FAIO.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						FAIO.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end	
		end
	end

--	if NPC.GetUnitName(unit) == "npc_dota_hero_techies" then
--		local radius = 
--		local castrange = 
--		if sequenceName == "cast_blast_off" and NPC.IsEntityInRange(myHero, unit, radius+castrange) then
--			if FAIO.dodgeIsTargetMe(myHero, unit, radius, castrange) then
--				FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 1; source = unit, lotus = 0, castpoint = castpoint, spellname = })
--			end
--		end
--	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_terrorblade" then
		local radius = 0
		local castrange = 600
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and FAIO.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 1; source = unit, lotus = 1, castpoint = castpoint, spellname = "terrorblade_sunder", global = 0, type = "nuke"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = FAIO.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						FAIO.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_tidehunter" then
		local radius = 0
		local castrange = 1100
		local impactTime = distance / 775 - 0.35
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) then
				local adjust = impactTime
					if distance <= 250 then adjust = 0 end
				FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint + adjust; style = 2; source = unit, lotus = 0, castpoint = castpoint, spellname = "tidehunter_ravage", global = 0, type = "disable", projectilespeed = 775, projectileextradelay = 0.35})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = FAIO.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						FAIO.saveIt({lotus = 0, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_tinker" then
		local radius = 0
		local castrange = 900
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_1 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and FAIO.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint+0.1; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "tinker_laser", global = 0, type = "nuke"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = FAIO.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						FAIO.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

--	if NPC.GetUnitName(unit) == "npc_dota_hero_treant" then
--		local radius = 0
--		local castrange = 850
--		if sequenceName == "cast5_Overgrowth_anim" and NPC.IsEntityInRange(myHero, unit, radius+castrange) then
--			if FAIO.dodgeIsTargetMe(myHero, unit, radius, castrange) then
--				FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 1; source = unit, lotus = 0, castpoint = castpoint, spellname = })
--			end
--		end
--	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_vengefulspirit" then
		local radius = 0
		local castrange = 500
		local impactTime = distance / 1250 - 0.1
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_1 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and FAIO.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint+impactTime; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "vengefulspirit_magic_missile", global = 0, type = "disable", projectilespeed = 1250, projectileextradelay = 0.1})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = FAIO.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						FAIO.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_warlock" then
		local radius = 600
		local castrange = 1200
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_4 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and FAIO.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint+0.5; style = 1; source = unit, lotus = 0, castpoint = castpoint, spellname = "warlock_rain_of_chaos", global = 0, type = "disable"})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = FAIO.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						FAIO.saveIt({lotus = 0, target = targetAlly})
					end
				end
			end	
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_windrunner" then
		local radius = 0
		local castrange = 800
		local impactTime = distance / 1650 - 0.1
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_1 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and FAIO.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint+impactTime; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "windrunner_shackleshot", global = 0, type = "disable", projectilespeed = 1650, projectileextradelay = 0.1})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = FAIO.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						FAIO.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end	
		end
	end

--	if NPC.GetUnitName(unit) == "npc_dota_hero_winter_wyvern" then
--		local radius = 500
--		local castrange = 800
--		if sequenceName == "cast04_winters_curse_flying_low_anim" and NPC.IsEntityInRange(myHero, unit, radius+castrange) then
--			if FAIO.dodgeIsTargetMe(myHero, unit, radius, castrange) then
--				FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 1; source = unit, lotus = 0, castpoint = castpoint, spellname = })
--			end
--		end
--	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_skeleton_king" then
		local radius = 0
		local castrange = 525
		local impactTime = distance / 1000 - 0.15
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_1 then
			if NPC.IsEntityInRange(myHero, unit, radius+castrange) and FAIO.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint+impactTime; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "skeleton_king_hellfire_blast", global = 0, type = "disable", projectilespeed = 1000, projectileextradelay = 0.15})
			else
				if NPC.IsEntityInRange(myHero, unit, radius+castrange+885) then
					local targetAlly = FAIO.saverGetAllyTarget(myHero, unit, radius, castrange)
					if targetAlly and NPC.IsEntityInRange(myHero, targetAlly, 885) then
						FAIO.saveIt({lotus = 1, target = targetAlly})
					end
				end
			end
		end
	end

	if NPC.GetUnitName(unit) == "npc_dota_hero_zuus" then
		local radius = 375
		local castrange = 900
		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_2 and NPC.IsEntityInRange(myHero, unit, radius+castrange) then
			if FAIO.dodgeIsTargetMe(myHero, unit, radius, castrange) then
				FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 2; source = unit, lotus = 1, castpoint = castpoint, spellname = "zuus_lightning_bolt", global = 0, type = "nuke"})
			end
		end

		if activity == Enum.GameActivity.ACT_DOTA_CAST_ABILITY_5 then
			if FAIO.IsHeroInvisible(myHero) == false and not NPC.HasModifier(myHero, "modifier_smoke_of_deceit") then
				FAIO.dodgeIt({time = GameRules.GetGameTime(); delay = castpoint; style = 1; source = unit, lotus = 0, castpoint = castpoint, spellname = "zuus_thundergods_wrath", global = 1, type = "nuke"})
			end
		end
	end

end

-- ward awareness
function FAIO.wardProcessing(myHero)

	if not myHero then return end

	if os.clock() - FAIO.wardCaptureTiming < 0.5 then return end

	for i = 1, Heroes.Count() do
		local heroes = Heroes.Get(i)
		if heroes and Entity.IsHero(heroes) and Wrap.EIsAlive(heroes) and not Entity.IsDormant(heroes) and not Entity.IsSameTeam(myHero, heroes) and not NPC.IsIllusion(heroes) then
			local sentry = NPC.GetItem(heroes, "item_ward_sentry", true)
			local observer = NPC.GetItem(heroes, "item_ward_observer", true)
			local dispenser = NPC.GetItem(heroes, "item_ward_dispenser", true)
			local sentryStack = 0
			local observerStack = 0
			local ownerID = Entity.GetIndex(heroes)
			if sentry then
				sentryStack = Item.GetCurrentCharges(sentry)
			elseif observer then
				observerStack = Item.GetCurrentCharges(observer)
			elseif dispenser then
				sentryStack = Item.GetSecondaryCharges(dispenser)
				observerStack = Item.GetCurrentCharges(dispenser)
			end

			if sentryStack == 0 and observerStack == 0 then
				if FAIO.wardDispenserCount[ownerID] == nil then
					FAIO.wardDispenserCount[ownerID] = nil
					FAIO.wardCaptureTiming = os.clock()
				else
					if FAIO.wardDispenserCount[ownerID]["sentry"] > sentryStack then
						FAIO.wardProcessingTable[ownerID + math.floor(GameRules.GetGameTime())] = {type = "sentry", pos = Entity.GetAbsOrigin(heroes), dieTime = math.floor(GameRules.GetGameTime() + 360)}
						FAIO.wardDispenserCount[ownerID] = nil
						FAIO.wardCaptureTiming = os.clock()
					elseif FAIO.wardDispenserCount[ownerID]["observer"] > sentryStack then
						FAIO.wardProcessingTable[ownerID + math.floor(GameRules.GetGameTime())] = {type = "observer", pos = Entity.GetAbsOrigin(heroes), dieTime = math.floor(GameRules.GetGameTime() + 360)}
						FAIO.wardDispenserCount[ownerID] = nil
						FAIO.wardCaptureTiming = os.clock()
					end
				end
			end
						
			if FAIO.wardDispenserCount[ownerID] == nil then
				if sentryStack > 0 or observerStack > 0 then
					FAIO.wardDispenserCount[ownerID] = {sentry = sentryStack, observer = observerStack}
					FAIO.wardCaptureTiming = os.clock()
				end
			else
				if FAIO.wardDispenserCount[ownerID]["sentry"] < sentryStack then
					FAIO.wardDispenserCount[ownerID] = {sentry = sentryStack, observer = observerStack}
					FAIO.wardCaptureTiming = os.clock()
				elseif FAIO.wardDispenserCount[ownerID]["observer"] < observerStack then
					FAIO.wardDispenserCount[ownerID] = {sentry = sentryStack, observer = observerStack}
					FAIO.wardCaptureTiming = os.clock()
				elseif FAIO.wardDispenserCount[ownerID]["sentry"] > sentryStack then
					FAIO.wardProcessingTable[ownerID + math.floor(GameRules.GetGameTime())] = {type = "sentry", pos = Entity.GetAbsOrigin(heroes), dieTime = math.floor(GameRules.GetGameTime() + 240)}
					FAIO.wardDispenserCount[ownerID] = {sentry = sentryStack, observer = observerStack}
					FAIO.wardCaptureTiming = os.clock()
				elseif FAIO.wardDispenserCount[ownerID]["observer"] > observerStack then
					FAIO.wardProcessingTable[ownerID + math.floor(GameRules.GetGameTime())] = {type = "observer", pos = Entity.GetAbsOrigin(heroes), dieTime = math.floor(GameRules.GetGameTime() + 360)}
					FAIO.wardDispenserCount[ownerID] = {sentry = sentryStack, observer = observerStack}
					FAIO.wardCaptureTiming = os.clock()
				end
			end
		elseif heroes and Entity.IsHero(heroes) and Entity.IsDormant(heroes) then
			local ownerID = Entity.GetIndex(heroes)
			FAIO.wardDispenserCount[ownerID] = nil
			FAIO.wardCaptureTiming = os.clock()
		end
	end

	for k, l in pairs(FAIO.wardProcessingTable) do
		if l then
			if GameRules.GetGameTime() > l.dieTime then
				FAIO.wardProcessingTable[k] = nil
			end	
		end
	end

end

function FAIO.drawWard(myHero)

	if not myHero then return end

	if next(FAIO.wardProcessingTable) == nil then return end

	local sentryImageHandle = FAIO.sentryImageHandle
		if sentryImageHandle == nil then
			sentryImageHandle = Renderer.LoadImage("resource/flash3/images/items/" .. "ward_sentry" .. ".png")
			FAIO.sentryImageHandle = sentryImageHandle
		end
	local obsImageHandle = FAIO.obsImageHandle
		if obsImageHandle == nil then
			obsImageHandle = Renderer.LoadImage("resource/flash3/images/items/" .. "ward_observer" .. ".png")
			FAIO.obsImageHandle = obsImageHandle
		end

	for i, v in pairs(FAIO.wardProcessingTable) do
		if v then
			local type = v.type
			local pos = v.pos
			local dieTime = v.dieTime
			if dieTime > GameRules.GetGameTime() then
				local x, y, visible = Renderer.WorldToScreen(pos)
				local hoveringOver = Input.IsCursorInRect(x, y, 30, 30)
				if visible then
					if type == "sentry" then
						Renderer.SetDrawColor(255, 255, 255, 255)
						Renderer.DrawImage(sentryImageHandle, x, y, 30, 30)
						Renderer.DrawText(FAIO.font, x, y+30, math.floor(dieTime - GameRules.GetGameTime()), 0)
					elseif type == "observer" then
						Renderer.SetDrawColor(255, 255, 255, 255)
						Renderer.DrawImage(obsImageHandle, x, y, 30, 30)
						Renderer.DrawText(FAIO.font, x, y+30, math.floor(dieTime - GameRules.GetGameTime()), 0)
					end
					if Menu.IsEnabled(FAIO.optionWardAwarenessClickRemove) and (os.clock() - FAIO.wardDrawingRemove) >= 0.25 then
						if hoveringOver and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) then
							FAIO.wardDrawingRemove = os.clock()
						end
					else
						if hoveringOver and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) then
							FAIO.wardProcessingTable[i] = nil
						end
					end
				end
			end
		end
	end

end

-- item usage functions
function FAIO.itemUsage(myHero, enemy)

	if not myHero then return end
	if not enemy then return end

	if not Menu.IsEnabled(FAIO.optionItemEnable) then return end
	if (os.clock() - FAIO.lastItemTick) < FAIO.itemDelay then return end
	if FAIO.ItemCastStop then return end

	if FAIO.heroCanCastItems(myHero) == false then return end
	if FAIO.isHeroChannelling(myHero) == true then return end
	if FAIO.IsHeroInvisible(myHero) == true then return end

	if Menu.GetValue(FAIO.optionItemStyle) == 0 then 
		FAIO.itemUsageNoOrder(myHero, enemy)
	elseif Menu.GetValue(FAIO.optionItemStyle) == 1 then
		FAIO.itemUsageOrder(myHero, enemy)
	elseif Menu.GetValue(FAIO.optionItemStyle) == 2 then
		FAIO.itemUsageSmartOrder(myHero, enemy)
	end

end

function FAIO.itemUsageNoOrder(myHero, enemy)

	if not myHero then return end
	if not enemy then return end

	local myMana = NPC.GetMana(myHero)

	local veil = NPC.GetItem(myHero, "item_veil_of_discord", true)
	local hex = NPC.GetItem(myHero, "item_sheepstick", true)
	local blood = NPC.GetItem(myHero, "item_bloodthorn", true)
	local eBlade = NPC.GetItem(myHero, "item_ethereal_blade", true)
	local orchid = NPC.GetItem(myHero, "item_orchid", true)
	local refresher = NPC.GetItem(myHero, "item_refresher", true)
	local atos = NPC.GetItem(myHero, "item_rod_of_atos", true)
	local abyssal = NPC.GetItem(myHero, "item_abyssal_blade", true)
	local halberd = NPC.GetItem(myHero, "item_heavens_halberd", true)
	local shivas = NPC.GetItem(myHero, "item_shivas_guard", true)
	local urn = NPC.GetItem(myHero, "item_urn_of_shadows", true)
	local manta = NPC.GetItem(myHero, "item_manta", true)
	local soulring = NPC.GetItem(myHero, "item_soul_ring", true)
	local mjollnir = NPC.GetItem(myHero, "item_mjollnir", true)
	local medallion = NPC.GetItem(myHero, "item_medallion_of_courage", true)
	local crest = NPC.GetItem(myHero, "item_solar_crest", true)
	local spiritVessel = NPC.GetItem(myHero, "item_spirit_vessel", true)
	local nullifier = NPC.GetItem(myHero, "item_nullifier", true)
	local diffusal = NPC.GetItem(myHero, "item_diffusal_blade", true)

	local dagon = NPC.GetItem(myHero, "item_dagon", true)
		if not dagon then
			for i = 2, 5 do
				dagon = NPC.GetItem(myHero, "item_dagon_" .. i, true)
				if dagon then break end
			end
		end

	if Menu.IsKeyDown(FAIO.optionComboKey) then
		
		if FAIO.ItemSleepReady(0.05) and soulring and Ability.IsReady(soulring) and Menu.IsEnabled(FAIO.optionItemSoulring) then
			Ability.CastNoTarget(soulring)
			FAIO.lastItemCast = os.clock()
			return
		end

		if NPC.IsLinkensProtected(enemy) then
			if FAIO.ItemSleepReady(0.05) and FAIO.LinkensBreakerNew(myHero) ~= nil then
				Ability.CastTarget(NPC.GetItem(myHero, FAIO.LinkensBreakerNew(myHero), true), enemy)
				FAIO.lastItemCast = os.clock()
				return
			end
		end

		if FAIO.ItemSleepReady(0.05) and abyssal and NPC.IsEntityInRange(myHero, enemy, 140) and Ability.IsCastable(abyssal, myMana) and Menu.GetValue(FAIO.optionItemAbyssal) > 0 then 
			Ability.CastTarget(abyssal, enemy)
			FAIO.lastItemCast = os.clock()
			return
		end

		if FAIO.ItemSleepReady(0.05) and shivas and NPC.IsEntityInRange(myHero, enemy, 900 + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(shivas, myMana) and Menu.GetValue(FAIO.optionItemShivas) > 0 then 
			Ability.CastNoTarget(shivas)
			FAIO.lastItemCast = os.clock()
			return
		end

		if FAIO.ItemSleepReady(0.05) and mjollnir and NPC.IsEntityInRange(myHero, enemy, NPC.GetAttackRange(myHero)) and Ability.IsCastable(mjollnir, myMana) and Menu.GetValue(FAIO.optionItemMjollnir) > 0 then 
			Ability.CastTarget(mjollnir, myHero)
			FAIO.lastItemCast = os.clock()
			return
		end

		if FAIO.ItemSleepReady(0.05) and manta and NPC.IsEntityInRange(myHero, enemy, NPC.GetAttackRange(myHero)) and Ability.IsCastable(manta, myMana) and Menu.GetValue(FAIO.optionItemManta) > 0 then 
			Ability.CastNoTarget(manta)
			FAIO.lastItemCast = os.clock()
			return
		end

		if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then

			if FAIO.ItemSleepReady(0.05) and orchid and NPC.IsEntityInRange(myHero, enemy, 900 + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(orchid, myMana) and Menu.GetValue(FAIO.optionItemOrchid) > 0 then 
				Ability.CastTarget(orchid, enemy)
				FAIO.lastItemCast = os.clock()
				return
			end

			if FAIO.ItemSleepReady(0.05) and blood and NPC.IsEntityInRange(myHero, enemy, 900 + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(blood, myMana) and Menu.GetValue(FAIO.optionItemBlood) > 0 then 
				Ability.CastTarget(blood, enemy)
				FAIO.lastItemCast = os.clock()
				return
			end

			if FAIO.ItemSleepReady(0.05) and veil and NPC.IsEntityInRange(myHero, enemy, 1000 + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(veil, myMana) and Menu.GetValue(FAIO.optionItemVeil) > 0 then 
				Ability.CastPosition(veil, Entity.GetAbsOrigin(enemy))
				FAIO.lastItemCast = os.clock()
				return
			end

			if FAIO.ItemSleepReady(0.05) and hex and NPC.IsEntityInRange(myHero, enemy, 800 + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(hex, myMana) and Menu.GetValue(FAIO.optionItemHex) > 0 then 
				Ability.CastTarget(hex, enemy)
				FAIO.lastItemCast = os.clock()
				return
			end

			if FAIO.ItemSleepReady(0.05) and nullifier and NPC.IsEntityInRange(myHero, enemy, 600 + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(nullifier, myMana) and Menu.GetValue(FAIO.optionItemNull) > 0 then 
				Ability.CastTarget(nullifier, enemy)
				FAIO.lastItemCast = os.clock()
				return
			end

			if FAIO.ItemSleepReady(0.05) and diffusal and NPC.IsEntityInRange(myHero, enemy, 600 + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(diffusal, myMana) and Menu.GetValue(FAIO.optionItemDiffusal) > 0 then 
				Ability.CastTarget(diffusal, enemy)
				FAIO.lastItemCast = os.clock()
				return
			end

			if FAIO.ItemSleepReady(0.05) and eBlade and NPC.IsEntityInRange(myHero, enemy, 800 + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(eBlade, myMana) and Menu.GetValue(FAIO.optionItemeBlade) > 0 then 
				Ability.CastTarget(eBlade, enemy)
				FAIO.lastItemCast = os.clock()
				return
			end
	
			if FAIO.ItemSleepReady(0.05) and atos and NPC.IsEntityInRange(myHero, enemy, 1150 + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(atos, myMana) and Menu.GetValue(FAIO.optionItemAtos) > 0 then 
				Ability.CastTarget(atos, enemy)
				FAIO.lastItemCast = os.clock()
				return
			end

			if FAIO.ItemSleepReady(0.05) and halberd and NPC.IsEntityInRange(myHero, enemy, 600 + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(halberd, myMana) and Menu.GetValue(FAIO.optionItemHalberd) > 0 then
				Ability.CastTarget(halberd, enemy)
				FAIO.lastItemCast = os.clock()
				return
			end

			if FAIO.ItemSleepReady(0.05) and urn and NPC.IsEntityInRange(myHero, enemy, 950 + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(urn, myMana) and Item.GetCurrentCharges(urn) >= 3 and Entity.GetHealth(enemy) >= 250 and Menu.GetValue(FAIO.optionItemUrn) > 0 then
				Ability.CastTarget(urn, enemy)
				FAIO.lastItemCast = os.clock()
				return
			end

			if FAIO.ItemSleepReady(0.05) and spiritVessel and NPC.IsEntityInRange(myHero, enemy, 950 + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(spiritVessel, myMana) and Item.GetCurrentCharges(spiritVessel) >= 2 and Entity.GetHealth(enemy) >= 250 and Menu.GetValue(FAIO.optionItemSpirit) > 0 then
				Ability.CastTarget(spiritVessel, enemy)
				FAIO.lastItemCast = os.clock()
				return
			end

			if FAIO.ItemSleepReady(0.05) and medallion and NPC.IsEntityInRange(myHero, enemy, 1000 + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(medallion, myMana) and Menu.GetValue(FAIO.optionItemMedallion) > 0 then 
				Ability.CastTarget(medallion, enemy)
				FAIO.lastItemCast = os.clock()
				return
			end

			if FAIO.ItemSleepReady(0.05) and crest and NPC.IsEntityInRange(myHero, enemy, 1000 + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(crest, myMana) and Menu.GetValue(FAIO.optionItemCrest) > 0 then 
				Ability.CastTarget(crest, enemy)
				FAIO.lastItemCast = os.clock()
				return
			end

			if FAIO.ItemSleepReady(0.05) and dagon and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(dagon) + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(dagon, myMana) and Menu.GetValue(FAIO.optionItemDagon) > 0 and not NPC.HasModifier(enemy, "modifier_item_aeon_disk_buff") then
				if eBlade then
					if Ability.SecondsSinceLastUse(eBlade) > -1 and Ability.SecondsSinceLastUse(eBlade) < ((Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Length2D() / 1275) + 0.25 then
						return
					else
						Ability.CastTarget(dagon, enemy)
						FAIO.lastItemCast = os.clock()
						return
					end
				else
					if NPC.HasAbility(myHero, "skywrath_mage_ancient_seal") then
						if Ability.IsReady(NPC.GetAbility(myHero, "skywrath_mage_ancient_seal")) then
							return
						else
							if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "skywrath_mage_ancient_seal")) <= 0.15 then
								return
							else
								Ability.CastTarget(dagon, enemy)
								FAIO.lastItemCast = os.clock()
								return
							end
						end
					elseif NPC.HasAbility(myHero, "witch_doctor_maledict") then
						if Ability.IsReady(NPC.GetAbility(myHero, "witch_doctor_maledict")) then
							return
						else
							if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "witch_doctor_maledict")) <= 0.15 then
								return
							else
								Ability.CastTarget(dagon, enemy)
								FAIO.lastItemCast = os.clock()
								return
							end
						end
					elseif NPC.HasAbility(myHero, "pugna_decrepify") then
						if Ability.IsReady(NPC.GetAbility(myHero, "pugna_decrepify")) then
							return
						else
							if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "pugna_decrepify")) <= 0.15 then
								return
							else
								Ability.CastTarget(dagon, enemy)
								FAIO.lastItemCast = os.clock()
								return
							end
						end
					else
						Ability.CastTarget(dagon, enemy)
						FAIO.lastItemCast = os.clock()
						return
					end
				end
			end

			if Menu.GetValue(FAIO.optionItemDagon) == -1 then

				if FAIO.ItemSleepReady(0.05) and dagon and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(dagon) + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(dagon, myMana) then
					local dagonDMG = (1 - NPC.GetMagicalArmorValue(enemy)) * (Ability.GetLevelSpecialValueFor(dagon, "damage") + (Ability.GetLevelSpecialValueFor(dagon, "damage") * (Hero.GetIntellectTotal(myHero) / 14 / 100)))
					local eBladeAMP = 0
						if NPC.HasModifier(enemy, "modifier_item_ethereal_blade_ethereal") then
							eBladeAMP = 0.4
						end
					local necroUltDMG = 0
						if NPC.HasAbility(myHero, "necrolyte_reapers_scythe") then
							if Ability.IsCastable(NPC.GetAbility(myHero, "necrolyte_reapers_scythe"), myMana - Ability.GetManaCost(dagon)) then
								local necroUlt = (Entity.GetMaxHealth(enemy) - Entity.GetHealth(enemy)) * Ability.GetLevelSpecialValueForFloat(NPC.GetAbility(myHero, "necrolyte_reapers_scythe"), "damage_per_health")
								necroUltDMG = (1 - NPC.GetMagicalArmorValue(enemy)) * (1 + eBladeAMP) * (necroUlt + necroUlt * (Hero.GetIntellectTotal(myHero) / 14 / 100))
							end
						end
					local dagonTrueDMG = (1 + eBladeAMP) * dagonDMG + necroUltDMG
					if Entity.GetHealth(enemy) <= dagonTrueDMG and not NPC.IsLinkensProtected(enemy) then
						if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and not NPC.HasModifier(enemy, "modifier_item_aeon_disk_buff") then
							Ability.CastTarget(dagon, enemy)
							FAIO.lastItemCast = os.clock()
							return
						end
					end
				end
			end
		end
	end
end

function FAIO.itemUsageOrder(myHero, enemy)

	if not myHero then return end
	if not enemy then return end

	local myMana = NPC.GetMana(myHero)

	local soulring = NPC.GetItem(myHero, "item_soul_ring", true)
	local mjollnir = NPC.GetItem(myHero, "item_mjollnir", true)
	local manta = NPC.GetItem(myHero, "item_manta", true)
	local dagon = NPC.GetItem(myHero, "item_dagon", true)
		if not dagon then
			for i = 2, 5 do
				dagon = NPC.GetItem(myHero, "item_dagon_" .. i, true)
				if dagon then break end
			end
		end

	if Menu.IsKeyDown(FAIO.optionComboKey) then
		
		if FAIO.ItemSleepReady(0.05) and soulring and Ability.IsReady(soulring) and Menu.IsEnabled(FAIO.optionItemSoulring) then
			Ability.CastNoTarget(soulring)
			FAIO.lastItemCast = os.clock()
			return
		end

		if NPC.IsLinkensProtected(enemy) then
			if FAIO.ItemSleepReady(0.05) and FAIO.LinkensBreakerNew(myHero) ~= nil then
				Ability.CastTarget(NPC.GetItem(myHero, FAIO.LinkensBreakerNew(myHero), true), enemy)
				FAIO.lastItemCast = os.clock()
				return
			end
		end

		if Menu.GetValue(FAIO.optionItemDagon) == -1 then

			if FAIO.ItemSleepReady(0.05) and dagon and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(dagon) + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(dagon, myMana) then
				local dagonDMG = (1 - NPC.GetMagicalArmorValue(enemy)) * (Ability.GetLevelSpecialValueFor(dagon, "damage") + (Ability.GetLevelSpecialValueFor(dagon, "damage") * (Hero.GetIntellectTotal(myHero) / 14 / 100)))
				local eBladeAMP = 0
					if NPC.HasModifier(enemy, "modifier_item_ethereal_blade_ethereal") then
						eBladeAMP = 0.4
					end
				local necroUltDMG = 0
					if NPC.HasAbility(myHero, "necrolyte_reapers_scythe") then
						if Ability.IsCastable(NPC.GetAbility(myHero, "necrolyte_reapers_scythe"), myMana - Ability.GetManaCost(dagon)) then
							local necroUlt = (Entity.GetMaxHealth(enemy) - Entity.GetHealth(enemy)) * Ability.GetLevelSpecialValueForFloat(NPC.GetAbility(myHero, "necrolyte_reapers_scythe"), "damage_per_health")
							necroUltDMG = (1 - NPC.GetMagicalArmorValue(enemy)) * (1 + eBladeAMP) * (necroUlt + necroUlt * (Hero.GetIntellectTotal(myHero) / 14 / 100))
						end
					end
				local dagonTrueDMG = (1 + eBladeAMP) * dagonDMG + necroUltDMG
				if Entity.GetHealth(enemy) <= dagonTrueDMG and not NPC.IsLinkensProtected(enemy) then
					if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and not NPC.HasModifier(enemy, "modifier_item_aeon_disk_buff") then
						Ability.CastTarget(dagon, enemy)
						FAIO.lastItemCast = os.clock()
						return
					end
				end
			end
		end

		local orderItem
		local customOrder = 0
		local itemActivation

		for k, v in ipairs(FAIO.ItemCastOrder) do

			local skipItem = 0

			if NPC.HasModifier(enemy, "modifier_black_king_bar_immune") then
				if v[2] == "item_veil_of_discord" or v[2] == "item_sheepstick" or v[2] == "item_bloodthorn" or
					v[2] == "item_ethereal_blade" or v[2] == "item_orchid" or v[2] == "item_rod_of_atos" or
					v[2] == "item_heavens_halberd" or v[2] == "item_urn_of_shadows" or v[2] == "item_dagon"
					or v[2] == "item_dagon_2" or v[2] == "item_dagon_3" or v[2] == "item_dagon_4" 
					or v[2] == "item_dagon_5" or v[2] == "item_medallion_of_courage" or v[2] == "item_solar_crest"
					or v[2] == "item_spirit_vessel" or v[2] == "item_nullifier" or v[2] == "item_diffusal_blade" then
						skipItem = v[1]
				end
			end

			if NPC.HasModifier(enemy, "modifier_item_aeon_disk_buff") then
				if v[2] ~= "item_nullifier" then
					skipItem = v[1]
				end
			end

			if NPC.HasModifier(myHero, "modifier_item_ethereal_blade") and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_ethereal_blade", true)) > -1 and
				Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_ethereal_blade", true)) < ((Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Length2D() / 1275) + 0.25 then
				if v[2] == "item_dagon" or v[2] == "item_dagon_2" or v[2] == "item_dagon_3" or v[2] == "item_dagon_4" 
					or v[2] == "item_dagon_5" then
					skipItem = v[1]
				end
			end

			if NPC.HasAbility(myHero, "skywrath_mage_ancient_seal") then
				if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "skywrath_mage_ancient_seal")) <= 0.15 then
					if v[2] == "item_dagon" or v[2] == "item_dagon_2" or v[2] == "item_dagon_3" or v[2] == "item_dagon_4" or v[2] == "item_dagon_5" then
						skipItem = v[1]
					end
				end
			end

			if NPC.HasAbility(myHero, "witch_doctor_maledict") then
				if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "witch_doctor_maledict")) <= 0.15 then
					if v[2] == "item_dagon" or v[2] == "item_dagon_2" or v[2] == "item_dagon_3" or v[2] == "item_dagon_4" or v[2] == "item_dagon_5" then
						skipItem = v[1]
					end
				end
			end

			if NPC.HasAbility(myHero, "pugna_decrepify") then
				if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "pugna_decrepify")) <= 0.15 then
					if v[2] == "item_dagon" or v[2] == "item_dagon_2" or v[2] == "item_dagon_3" or v[2] == "item_dagon_4" or v[2] == "item_dagon_5" then
						skipItem = v[1]
					end
				end
			end

			if NPC.HasItem(myHero, v[2], true) then
				if v[2] == "item_spirit_vessel" or v[2] == "item_urn_of_shadows" then
					if Item.GetCurrentCharges(NPC.GetItem(myHero, v[2], true)) <= 2 then
						skipItem = v[1]
					end
				end
			end

			if NPC.HasItem(myHero, v[2], true) then
				if Ability.IsCastable(NPC.GetItem(myHero, v[2], true), myMana) and (v[1] - skipItem) > customOrder then
					orderItem = NPC.GetItem(myHero, v[2], true)
					customOrder = v[1]
					itemActivation = v[3]
				end
			end	
		end
		
			if FAIO.ItemSleepReady(0.05) and customOrder > 0 then
				if NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(orderItem)) then
					if itemActivation == "target" then
						Ability.CastTarget(orderItem, enemy)
						FAIO.lastItemCast = os.clock()
						customOrder = 0
						return
					end
					if itemActivation == "no target" then
						Ability.CastNoTarget(orderItem)
						FAIO.lastItemCast = os.clock()
						customOrder = 0
						return
					end
					if itemActivation == "position" then
						Ability.CastPosition(orderItem, Entity.GetAbsOrigin(enemy))
						FAIO.lastItemCast = os.clock()
						customOrder = 0
						return
					end
				end
			end

		if FAIO.ItemSleepReady(0.05) and mjollnir and NPC.IsEntityInRange(myHero, enemy, NPC.GetAttackRange(myHero)) and Ability.IsCastable(mjollnir, myMana) and Menu.GetValue(FAIO.optionItemMjollnir) > 0 then
			Ability.CastTarget(mjollnir, myHero)
			FAIO.lastItemCast = os.clock()
			return
		end

		if FAIO.ItemSleepReady(0.05) and manta and NPC.IsEntityInRange(myHero, enemy, NPC.GetAttackRange(myHero)) and Ability.IsCastable(manta, myMana) and Menu.GetValue(FAIO.optionItemManta) > 0 then
			Ability.CastNoTarget(manta)
			FAIO.lastItemCast = os.clock()
			return
		end
	end
end

function FAIO.itemUsageSmartOrder(myHero, enemy, activation)

	if not myHero then return end
	if not enemy then return end

	if FAIO.heroCanCastItems(myHero) == false then return end
	if FAIO.isHeroChannelling(myHero) == true then return end
	if FAIO.IsHeroInvisible(myHero) == true then return end

	local alternateActivation
	if activation == nil then
		alternateActivation = false
	else alternateActivation = activation
	end
	
	local myMana = NPC.GetMana(myHero)

	local soulring = NPC.GetItem(myHero, "item_soul_ring", true)
	local mjollnir = NPC.GetItem(myHero, "item_mjollnir", true)
	local manta = NPC.GetItem(myHero, "item_manta", true)
	local dagon = NPC.GetItem(myHero, "item_dagon", true)
		if not dagon then
			for i = 2, 5 do
				dagon = NPC.GetItem(myHero, "item_dagon_" .. i, true)
				if dagon then break end
			end
		end

	if (Menu.IsKeyDown(FAIO.optionComboKey) or alternateActivation) then
		
		if FAIO.ItemSleepReady(0.05) and soulring and Ability.IsReady(soulring) and Menu.IsEnabled(FAIO.optionItemSoulring) then
			Ability.CastNoTarget(soulring)
			FAIO.lastItemCast = os.clock()
			return
		end

		if NPC.IsLinkensProtected(enemy) then
			if FAIO.ItemSleepReady(0.05) and FAIO.LinkensBreakerNew(myHero) ~= nil then
				Ability.CastTarget(NPC.GetItem(myHero, FAIO.LinkensBreakerNew(myHero), true), enemy)
				FAIO.lastItemCast = os.clock()
				return
			end
		end

		if Menu.GetValue(FAIO.optionItemDagon) == -1 then

			if FAIO.ItemSleepReady(0.05) and dagon and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(dagon) + NPC.GetCastRangeBonus(myHero)) and Ability.IsCastable(dagon, myMana) then
				local dagonDMG = (1 - NPC.GetMagicalArmorValue(enemy)) * (Ability.GetLevelSpecialValueFor(dagon, "damage") + (Ability.GetLevelSpecialValueFor(dagon, "damage") * (Hero.GetIntellectTotal(myHero) / 14 / 100)))
				local eBladeAMP = 0
					if NPC.HasModifier(enemy, "modifier_item_ethereal_blade_ethereal") then
						eBladeAMP = 0.4
					end
				local necroUltDMG = 0
					if NPC.HasAbility(myHero, "necrolyte_reapers_scythe") then
						if Ability.IsCastable(NPC.GetAbility(myHero, "necrolyte_reapers_scythe"), myMana - Ability.GetManaCost(dagon)) then
							local necroUlt = (Entity.GetMaxHealth(enemy) - Entity.GetHealth(enemy)) * Ability.GetLevelSpecialValueForFloat(NPC.GetAbility(myHero, "necrolyte_reapers_scythe"), "damage_per_health")
							necroUltDMG = (1 - NPC.GetMagicalArmorValue(enemy)) * (1 + eBladeAMP) * (necroUlt + necroUlt * (Hero.GetIntellectTotal(myHero) / 14 / 100))
						end
					end
				local dagonTrueDMG = (1 + eBladeAMP) * dagonDMG + necroUltDMG
				if Entity.GetHealth(enemy) <= dagonTrueDMG and not NPC.IsLinkensProtected(enemy) then
					if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and not NPC.HasModifier(enemy, "modifier_item_aeon_disk_buff") then
						Ability.CastTarget(dagon, enemy)
						FAIO.lastItemCast = os.clock()
						return
					end
				end
			end
		end

		local orderItem
		local customOrder = 0
		local itemActivation

		for k, v in ipairs(FAIO.ItemCastOrder) do

			local skipItem = 0

			if NPC.HasModifier(enemy, "modifier_black_king_bar_immune") then
				if v[2] == "item_veil_of_discord" or v[2] == "item_sheepstick" or v[2] == "item_bloodthorn" or
					v[2] == "item_ethereal_blade" or v[2] == "item_orchid" or v[2] == "item_rod_of_atos" or
					v[2] == "item_heavens_halberd" or v[2] == "item_urn_of_shadows" or v[2] == "item_dagon"
					or v[2] == "item_dagon_2" or v[2] == "item_dagon_3" or v[2] == "item_dagon_4" 
					or v[2] == "item_dagon_5" or v[2] == "item_medallion_of_courage" or v[2] == "item_solar_crest"
					or v[2] == "item_spirit_vessel" or v[2] == "item_nullifier" or v[2] == "item_diffusal_blade" then
						skipItem = v[1]
				end
			end

			if NPC.HasModifier(enemy, "modifier_item_aeon_disk_buff") then
				if v[2] ~= "item_nullifier" then
					skipItem = v[1]
				end
			end

			if NPC.HasItem(myHero, v[2], true) then
				if v[2] == "item_spirit_vessel" or v[2] == "item_urn_of_shadows" then
					if Item.GetCurrentCharges(NPC.GetItem(myHero, v[2], true)) <= 2 then
						skipItem = v[1]
					end
				end
			end

			if NPC.HasModifier(enemy, "modifier_bashed") then
				if v[2] == "item_abyssal_blade" or v[2] == "item_sheepstick" or v[2] == "item_bloodthorn" or v[2] == "item_orchid" or v[2] == "item_nullifier" or v[2] == "item_diffusal_blade" then
					skipItem = v[1]
				end
			end

			if NPC.HasModifier(enemy, "modifier_stunned") then
				local dieTime = Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_stunned"))
				if GameRules.GetGameTime() <= dieTime - 0.1 then
					if v[2] == "item_abyssal_blade" or v[2] == "item_sheepstick" or v[2] == "item_bloodthorn" or v[2] == "item_orchid" or v[2] == "item_heavens_halberd" or v[2] == "item_nullifier" or v[2] == "item_diffusal_blade" then
						skipItem = v[1]
					end
				end
			end

			if NPC.HasModifier(enemy, "modifier_sheepstick_debuff") then
				local dieTime = Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_sheepstick_debuff"))
				if Menu.IsEnabled(FAIO.optionItemStack) then
					if GameRules.GetGameTime() <= dieTime - 0.1 then
						if v[2] == "item_abyssal_blade" or v[2] == "item_sheepstick" or v[2] == "item_heavens_halberd" or v[2] == "item_nullifier" or v[2] == "item_diffusal_blade" then
							skipItem = v[1]
						end
					end
				else
					if GameRules.GetGameTime() <= dieTime - 0.1 then
						if v[2] == "item_abyssal_blade" or v[2] == "item_sheepstick" or v[2] == "item_bloodthorn" or v[2] == "item_orchid" or v[2] == "item_heavens_halberd" or v[2] == "item_nullifier" or v[2] == "item_diffusal_blade" then
							skipItem = v[1]
						end
					end
				end
			end

			if NPC.HasItem(myHero, "item_sheepstick", true) and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_sheepstick",true)) > -1 and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_sheepstick",true)) < 0.5 then
				if Menu.IsEnabled(FAIO.optionItemStack) then
					if v[2] == "item_abyssal_blade" or v[2] == "item_sheepstick" or v[2] == "item_heavens_halberd" or v[2] == "item_nullifier" or v[2] == "item_diffusal_blade" then
						skipItem = v[1]
					end
				else
					if v[2] == "item_abyssal_blade" or v[2] == "item_sheepstick" or v[2] == "item_bloodthorn" or v[2] == "item_orchid" or v[2] == "item_heavens_halberd" or v[2] == "item_nullifier" or v[2] == "item_diffusal_blade" then
						skipItem = v[1]
					end
				end
			end

			if NPC.IsSilenced(enemy) then
				if NPC.HasModifier(enemy, "modifier_bloodthorn_debuff") then
					local dieTime = Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_bloodthorn_debuff"))
					if GameRules.GetGameTime() <= dieTime - 0.1 then
						if v[2] == "item_bloodthorn" or v[2] == "item_orchid" then
							skipItem = v[1]
						end
					end
				elseif NPC.HasModifier(enemy, "modifier_orchid_malevolence_debuff") then
					local dieTime = Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_orchid_malevolence_debuff"))
					if GameRules.GetGameTime() <= dieTime - 0.1 then
						if v[2] == "item_bloodthorn" or v[2] == "item_orchid" then
							skipItem = v[1]
						end
					end
				elseif NPC.HasModifier(enemy, "modifier_silence") then
					local dieTime = Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_silence"))
					if GameRules.GetGameTime() <= dieTime - 0.1 then
						if v[2] == "item_bloodthorn" or v[2] == "item_orchid" then
							skipItem = v[1]
						end
					end
				end
			end

			if NPC.HasModifier(myHero, "modifier_item_nullifier") and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_nullifier", true)) > -1 and
				Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_nullifier", true)) < ((Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Length2D() / 1200) + 0.25 then
				if v[2] == "item_abyssal_blade" or v[2] == "item_sheepstick" or v[2] == "item_bloodthorn" or v[2] == "item_orchid" or v[2] == "item_heavens_halberd" or v[2] == "item_nullifier" or v[2] == "item_diffusal_blade" then
					skipItem = v[1]
				end
			end

			if NPC.HasModifier(enemy, "modifier_item_nullifier_mute") then
				local dieTime = Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_item_nullifier_mute"))
				if GameRules.GetGameTime() <= dieTime - 0.1 then
					if  v[2] == "item_nullifier" or v[2] == "item_diffusal_blade" then
						skipItem = v[1]
					end
				end
			end

			if NPC.HasModifier(enemy, "modifier_item_diffusal_blade_slow") then
				local dieTime = Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_item_diffusal_blade_slow"))
				if GameRules.GetGameTime() <= dieTime - 0.1 then
					if v[2] == "item_abyssal_blade" or v[2] == "item_sheepstick" or v[2] == "item_heavens_halberd" or v[2] == "item_nullifier" or v[2] == "item_diffusal_blade" then
						skipItem = v[1]
					end
				end
			end

			if NPC.HasItem(myHero, "item_diffusal_blade", true) and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_diffusal_blade", true)) > -1 and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_diffusal_blade", true)) < 0.5 then
				if v[2] == "item_abyssal_blade" or v[2] == "item_sheepstick" or v[2] == "item_heavens_halberd" or v[2] == "item_nullifier" or v[2] == "item_diffusal_blade" then
					skipItem = v[1]
				end
			end

			if NPC.HasModifier(myHero, "modifier_item_ethereal_blade") and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_ethereal_blade", true)) > -1 and
				Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_ethereal_blade", true)) < ((Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Length2D() / 1275) + 0.25 then
				if v[2] == "item_dagon" or v[2] == "item_dagon_2" or v[2] == "item_dagon_3" or v[2] == "item_dagon_4" 
					or v[2] == "item_dagon_5" then
					skipItem = v[1]
				end
			end

			if NPC.HasModifier(enemy, "modifier_item_veil_of_discord_debuff") then
				if v[2] == "item_veil_of_discord" then
					skipItem = v[1]
				end
			end		

			if NPC.HasAbility(myHero, "skywrath_mage_ancient_seal") then
				if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "skywrath_mage_ancient_seal")) <= 0.15 then
					if v[2] == "item_dagon" or v[2] == "item_dagon_2" or v[2] == "item_dagon_3" or v[2] == "item_dagon_4" or v[2] == "item_dagon_5" then
						skipItem = v[1]
					end
				end
			end

			if NPC.HasAbility(myHero, "witch_doctor_maledict") then
				if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "witch_doctor_maledict")) <= 0.15 then
					if v[2] == "item_dagon" or v[2] == "item_dagon_2" or v[2] == "item_dagon_3" or v[2] == "item_dagon_4" or v[2] == "item_dagon_5" then
						skipItem = v[1]
					end
				end
			end

			if NPC.HasAbility(myHero, "pugna_decrepify") then
				if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "pugna_decrepify")) <= 0.15 then
					if v[2] == "item_dagon" or v[2] == "item_dagon_2" or v[2] == "item_dagon_3" or v[2] == "item_dagon_4" or v[2] == "item_dagon_5" then
						skipItem = v[1]
					end
				end
			end

			if NPC.HasItem(enemy, "item_aeon_disk", true) then
				if Ability.SecondsSinceLastUse(NPC.GetItem(enemy, "item_aeon_disk", true)) < 0 then
					if Entity.GetHealth(enemy) >= 0.85 * Entity.GetMaxHealth(enemy) then
						if v[2] == "item_nullifier" then
							skipItem = v[1]
						end
					end
				end
				if Ability.SecondsSinceLastUse(NPC.GetItem(enemy, "item_aeon_disk", true)) <= 2.55 then
					if not NPC.HasModifier(enemy, "modifier_item_aeon_disk_buff") then
						if v[2] == "item_nullifier" then
							skipItem = v[1]
						end
					end
				end
			end

			if FAIO.myUnitName == "npc_dota_hero_tinker" then
				if NPC.IsLinkensProtected(enemy) then
					if v[2] == "item_sheepstick" then
						skipItem = v[1]
					end
				end
			end

			if NPC.HasModifier(enemy, "modifier_pudge_meat_hook") then
				if v[2] == "item_rod_of_atos" then
					skipItem = v[1]
				end
			end

			if NPC.HasItem(myHero, v[2], true) then
				if Ability.IsCastable(NPC.GetItem(myHero, v[2], true), myMana) and (v[1] - skipItem) > customOrder then
					orderItem = NPC.GetItem(myHero, v[2], true)
					customOrder = v[1]
					itemActivation = v[3]
				end
			end	
		end
		
			if FAIO.ItemSleepReady(0.05) and customOrder > 0 then
				if NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(orderItem)) then
					if itemActivation == "target" then
						Ability.CastTarget(orderItem, enemy)
						FAIO.lastItemCast = os.clock()
						customOrder = 0
						return
					end
					if itemActivation == "no target" then
						Ability.CastNoTarget(orderItem)
						FAIO.lastItemCast = os.clock()
						customOrder = 0
						return
					end
					if itemActivation == "position" then
						Ability.CastPosition(orderItem, Entity.GetAbsOrigin(enemy))
						FAIO.lastItemCast = os.clock()
						customOrder = 0
						return
					end
				end
			end

		if FAIO.ItemSleepReady(0.05) and mjollnir and NPC.IsEntityInRange(myHero, enemy, NPC.GetAttackRange(myHero)) and Ability.IsCastable(mjollnir, myMana) and Menu.GetValue(FAIO.optionItemMjollnir) > 0 then
			Ability.CastTarget(mjollnir, myHero)
			FAIO.lastItemCast = os.clock()
			return
		end

		if FAIO.ItemSleepReady(0.05) and manta and NPC.IsEntityInRange(myHero, enemy, NPC.GetAttackRange(myHero)) and Ability.IsCastable(manta, myMana) and Menu.GetValue(FAIO.optionItemManta) > 0 then
			Ability.CastNoTarget(manta)
			FAIO.lastItemCast = os.clock()
			return
		end
	end
end

-- hurricane
function FAIO.ItemAutoHurricaneUsage(myHero, enemy)

	if not myHero then return end

	local myMana = NPC.GetMana(myHero)

	local orbSkill = nil
	local orbSkillTable = {
		npc_dota_hero_clinkz = "clinkz_searing_arrows",
		npc_dota_hero_drow_ranger = "drow_ranger_frost_arrows",
		npc_dota_hero_enchantress = "enchantress_impetus",
		npc_dota_hero_huskar = "huskar_burning_spear",
		npc_dota_hero_obsidian_destroyer = "obsidian_destroyer_arcane_orb",
		npc_dota_hero_silencer = "silencer_glaives_of_wisdom",
		npc_dota_hero_viper = "viper_poison_attack",
		npc_dota_hero_skywrath_mage = "skywrath_mage_arcane_bolt"
			}

		if orbSkillTable[FAIO.myUnitName] ~= nil then
			orbSkill = NPC.GetAbility(myHero, orbSkillTable[FAIO.myUnitName])
		end

		if orbSkill and Ability.GetLevel(orbSkill) < 1 then
			orbSkill = nil
		end

		if orbSkill then
			if NPC.HasModifier(myHero, "modifier_item_hurricane_pike_range") then
				if Ability.GetAutoCastState(orbSkill) == false and os.clock() - FAIO.lastTick > 0.5 then
					Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_TOGGLE_AUTO, nil, Vector(), orbSkill, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_HERO_ONLY, npc, queue, showEffects)
					FAIO.lastTick = os.clock()
					return
				end
			end
		end


	local hurricanePike = NPC.GetItem(myHero, "item_hurricane_pike", true)
		if not hurricanePike then return end
		if not Ability.IsCastable(hurricanePike, myMana) then return end

	if FAIO.heroCanCastItems(myHero) == false then return end
	if FAIO.isHeroChannelling(myHero) == true then return end
	if FAIO.IsHeroInvisible(myHero) == true then return end

	if NPC.HasModifier(myHero, "modifier_item_blade_mail_reflect") then return end
	if NPC.HasItem(myHero, "item_blade_mail", true) and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_blade_mail", true)) > -1 and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_blade_mail", true)) < 0.25 then return end

	if os.clock() - FAIO.lastDefItemPop < 0.25 then return end

	local myHPperc = (Entity.GetHealth(myHero) / Entity.GetMaxHealth(myHero)) * 100

	if myHPperc <= Menu.GetValue(FAIO.optionItemHurricaneHP) then
		for _, v in ipairs(Wrap.HeroesInRadius(myHero, 400, Enum.TeamType.TEAM_ENEMY)) do
			if v and Entity.IsHero(v) and not Entity.IsDormant(v) and not NPC.IsIllusion(v) then
				if NPC.IsAttacking(v) then
					if NPC.IsEntityInRange(myHero, v, NPC.GetAttackRange(v) + 140) then
						if NPC.FindFacingNPC(v) == myHero then
							if enemy then
								if NPC.IsEntityInRange(myHero, enemy, 400) then
									Ability.CastTarget(hurricanePike, enemy)
									FAIO.lastDefItemPop = os.clock()
									break
									return
								else
									if NPC.IsEntityInRange(myHero, v, 400) then
										Ability.CastTarget(hurricanePike, v)
										FAIO.lastDefItemPop = os.clock()
										break
										return
									end
								end
							else
								if NPC.IsEntityInRange(myHero, v, 400) then
									Ability.CastTarget(hurricanePike, v)
									FAIO.lastDefItemPop = os.clock()
									break
									return
								end
							end	
						end
					end
				end
				for ability, info in pairs(FAIO.RawDamageAbilityEstimation) do
					if NPC.HasAbility(v, ability) and Ability.IsInAbilityPhase(NPC.GetAbility(v, ability)) then
						local abilityRange = math.max(Ability.GetCastRange(NPC.GetAbility(v, ability)), info[2])
						local abilityRadius = info[3]
						if FAIO.dodgeIsTargetMe(myHero, v, abilityRadius, abilityRange) then
							if next(FAIO.dodgeItTable) == nil then
								if enemy then
									if NPC.IsEntityInRange(myHero, enemy, 400) then
										Ability.CastTarget(hurricanePike, enemy)
										FAIO.lastDefItemPop = os.clock()
										break
										return
									end
								else
									if NPC.IsEntityInRange(myHero, v, 400) then
										Ability.CastTarget(hurricanePike, v)
										FAIO.lastDefItemPop = os.clock()
										break
										return
									end
								end
							end
						end
					end
				end
			end	
		end
	end

end

-- blade mail
function FAIO.ItemAutoBMUsage(myHero)

	if not myHero then return end

	local myMana = NPC.GetMana(myHero)

	local bladeMail = NPC.GetItem(myHero, "item_blade_mail", true)
		if not bladeMail then return end
		if not Ability.IsCastable(bladeMail, myMana) then return end

	if FAIO.heroCanCastItems(myHero) == false then return end
	if FAIO.isHeroChannelling(myHero) == true then return end
	if FAIO.IsHeroInvisible(myHero) == true then return end

	if NPC.HasModifier(myHero, "modifier_item_hurricane_pike_range") then return end
	if NPC.HasItem(myHero, "item_hurricane_pike", true) and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_hurricane_pike", true)) > -1 and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_hurricane_pike", true)) < 0.25 then return end

	if os.clock() - FAIO.lastDefItemPop < 0.25 then return end

	for _, v in ipairs(Wrap.HeroesInRadius(myHero, 800, Enum.TeamType.TEAM_ENEMY)) do
		if v and Entity.IsHero(v) and not Entity.IsDormant(v) and not NPC.IsIllusion(v) then
			if NPC.IsAttacking(v) then
				if NPC.IsEntityInRange(myHero, v, NPC.GetAttackRange(v) + 140) then
					if NPC.FindFacingNPC(v) == myHero then
						Ability.CastNoTarget(bladeMail)
						FAIO.lastDefItemPop = os.clock()
						break
						return
					end
				end
			end
			for ability, info in pairs(FAIO.RawDamageAbilityEstimation) do
				if NPC.HasAbility(v, ability) and Ability.IsInAbilityPhase(NPC.GetAbility(v, ability)) then
					local abilityRange = math.max(Ability.GetCastRange(NPC.GetAbility(v, ability)), info[2])
					local abilityRadius = info[3]
					if FAIO.dodgeIsTargetMe(myHero, v, abilityRadius, abilityRange) then
						if next(FAIO.dodgeItTable) == nil then
							Ability.CastNoTarget(bladeMail)
							FAIO.lastDefItemPop = os.clock()
							break
							return
						end
					end
				end
			end
		end	
	end
	return
	
end


-- armlet
function FAIO.getAbilityDamageInstances(myHero)

	if not myHero then return end

	for i, v in ipairs(Wrap.HeroesInRadius(myHero, 2000, Enum.TeamType.TEAM_ENEMY)) do
		if v and Wrap.EIsNPC(v) and Entity.IsHero(v) and not Entity.IsDormant(v) then
			for ability, info in pairs(FAIO.RawDamageAbilityEstimation) do
				if NPC.HasAbility(v, ability) and Ability.IsInAbilityPhase(NPC.GetAbility(v, ability)) then
					local abilityStyle = info[1]
					local abilityRange = math.max(Ability.GetCastRange(NPC.GetAbility(v, ability)), info[2])
					local abilityRadius = info[3]
					local abilityDamage = math.max(Ability.GetDamage(NPC.GetAbility(v, ability)), Ability.GetLevel(NPC.GetAbility(v, ability)) * info[4] * 1.1)
					local abilityDelay = Ability.GetCastPoint(NPC.GetAbility(v, ability)) + info[6]
					local projectileInfo = info[5]
					local curTime = FAIO.utilityRoundNumber(GameRules.GetGameTime(), 3)
					if projectileInfo < 1 then
						if FAIO.dodgeIsTargetMe(myHero, v, abilityRadius, abilityRange) then
							if #FAIO.armletDamageInstanceTable < 1 then
								table.insert(FAIO.armletDamageInstanceTable, { instanceindex = ability, time = FAIO.utilityRoundNumber(curTime + abilityDelay, 3), casttime = abilityDelay, type = "ability", damage = abilityDamage, isProjectile = false })
							else
								local inserted = false
								for k, info in ipairs(FAIO.armletDamageInstanceTable) do
									if info.instanceindex == ability then
										inserted = true
									end
								end
								if not inserted then
									table.insert(FAIO.armletDamageInstanceTable, { instanceindex = ability, time = FAIO.utilityRoundNumber(curTime + abilityDelay, 3), casttime = abilityDelay, type = "ability", damage = abilityDamage, isProjectile = false })
								end
							end
						end
					else
						if FAIO.dodgeIsTargetMe(myHero, v, abilityRadius, abilityRange) then
							local myProjectedPosition = Entity.GetAbsOrigin(myHero)
							local projectileTiming = ((Entity.GetAbsOrigin(v) - myProjectedPosition):Length2D() - NPC.GetHullRadius(myHero)) / projectileInfo
								if ability == "beastmaster_wild_axes" then
									projectileTiming = math.min(projectileTiming, 1)
								end
							if #FAIO.armletDamageInstanceTable < 1 then
								table.insert(FAIO.armletDamageInstanceTable, { instanceindex = ability, time = FAIO.utilityRoundNumber(curTime + abilityDelay + projectileTiming - 0.035, 3), casttime = abilityDelay, type = "ability", damage = abilityDamage, projectileorigin = Entity.GetAbsOrigin(v), projectilestarttime = GameRules.GetGameTime() + abilityDelay - 0.035, projectilespeed = projectileInfo, isProjectile = true })
							else
								local inserted = false
								for k, info in ipairs(FAIO.armletDamageInstanceTable) do
									if info.instanceindex == ability then
										inserted = true
									end
								end
								if not inserted then
									table.insert(FAIO.armletDamageInstanceTable, { instanceindex = ability, time = FAIO.utilityRoundNumber(curTime + abilityDelay + projectileTiming - 0.035, 3), casttime = abilityDelay, type = "ability", damage = abilityDamage, projectileorigin = Entity.GetAbsOrigin(v), projectilestarttime = GameRules.GetGameTime() + abilityDelay - 0.035, projectilespeed = projectileInfo, isProjectile = true })
								end
							end
						end
					end
				end
			end
		end
	end

	return

end

function FAIO.armletProcessInstanceTable(myHero)

	if not myHero then
		FAIO.armletDamageInstanceTable = {}
		return
	end

	if #FAIO.armletDamageInstanceTable < 1 then return end
	if #FAIO.armletDamageInstanceTable > 1 then
		table.sort(FAIO.armletDamageInstanceTable, function(a, b)
       			return a.time < b.time
    		end)
	end

	for i, info in ipairs(FAIO.armletDamageInstanceTable) do
		if info then	
			if info.isProjectile == true then
				local originPos = info.projectileorigin
				local myHullSize = NPC.GetHullRadius(myHero)
				local projectileStart = info.projectilestarttime
				local projectileSpeed = info.projectilespeed
				local timeElapsed = math.max((GameRules.GetGameTime() - projectileStart), 0)
				local projectilePos = originPos + (Entity.GetAbsOrigin(myHero) - originPos):Normalized():Scaled(timeElapsed*projectileSpeed)
				local myDisToOrigin = (Entity.GetAbsOrigin(myHero) - originPos):Length2D() - myHullSize
				local projectilDisToOrigin = (projectilePos - originPos):Length2D()
				if projectilDisToOrigin < myDisToOrigin and timeElapsed > 0 then
					local myDisToProjectile = (Entity.GetAbsOrigin(myHero) - projectilePos):Length2D() - myHullSize
					if myDisToProjectile > 1 then
						local remainingTravelTime = math.max(myDisToProjectile / projectileSpeed, 0)
						local processImpactTime = GameRules.GetGameTime() + remainingTravelTime
						if math.abs(info.time - processImpactTime) > 0.01 then
							local insert = table.remove(FAIO.armletDamageInstanceTable, i)
							insert.time = FAIO.utilityRoundNumber(processImpactTime, 3)
							table.insert(FAIO.armletDamageInstanceTable, insert)
							break
							return
						end
					end
				end
			end
			if GameRules.GetGameTime() > info.time then
				local backSwingCheck = 0
					if info.backswingend ~= nil then
						backSwingCheck = info.backswingend - info.time
					end
				if GameRules.GetGameTime() > info.time + math.max(backSwingCheck, 0) + 0.25 then
					table.remove(FAIO.armletDamageInstanceTable, i)
					break
					return
				end
			end
		end
	end
	
	return	

end

function FAIO.getDotDamageTicks(myHero)

	if not myHero then return end

	for dotMod, tickRate in pairs(FAIO.armletDotTickTable) do
		if NPC.HasModifier(myHero, dotMod) then
			local creationTime = FAIO.utilityRoundNumber(Modifier.GetCreationTime(NPC.GetModifier(myHero, dotMod)), 3) + 0.035
			local nextTick = creationTime + math.max(math.ceil((GameRules.GetGameTime() - creationTime) / tickRate), 1) * tickRate
			if #FAIO.armletDamageInstanceTable < 1 then
				table.insert(FAIO.armletDamageInstanceTable, { instanceindex = dotMod, time = nextTick, casttime = tickRate, type = "dot", damage = 50, isProjectile = false })
			else
				local inserted = false
				for k, info in ipairs(FAIO.armletDamageInstanceTable) do
					if info and info.instanceindex == dotMod and info.time == nextTick then
						inserted = true
					end
				end
				if not inserted then
					table.insert(FAIO.armletDamageInstanceTable, { instanceindex = dotMod, time = nextTick, casttime = tickRate, type = "dot", damage = 50, isProjectile = false })
				end
			end
		else
			for i, info in ipairs(FAIO.armletDamageInstanceTable) do
				if info.instanceindex == dotMod then
					table.remove(FAIO.armletDamageInstanceTable, i)
				end
			end	

		end
	end

	for i, v in ipairs(Wrap.HeroesInRadius(myHero, 1351, Enum.TeamType.TEAM_ENEMY)) do
		if v and Wrap.EIsNPC(v) and Entity.IsHero(v) and not Entity.IsDormant(v) and not NPC.IsIllusion(v) then
			for mod, info in pairs(FAIO.armletDotTickTableAOE) do
				if NPC.HasModifier(v, mod) then
					local effectRadius = info[1]
					local tickRate = info[2]
					if NPC.IsEntityInRange(myHero, v, effectRadius) then
						local creationTime = FAIO.utilityRoundNumber(Modifier.GetCreationTime(NPC.GetModifier(v, mod)), 2) + 0.035
						local nextTick = creationTime + math.ceil((GameRules.GetGameTime() - creationTime) / tickRate) * tickRate
						if #FAIO.armletDamageInstanceTable < 1 then
							table.insert(FAIO.armletDamageInstanceTable, { instanceindex = mod, time = nextTick, casttime = tickRate, type = "dot", damage = 50, isProjectile = false })
						else
							local inserted = false
							for k, info in ipairs(FAIO.armletDamageInstanceTable) do
								if info.instanceindex == mod then
									inserted = true
								end
							end
							if not inserted then
								table.insert(FAIO.armletDamageInstanceTable, { instanceindex = mod, time = nextTick, casttime = tickRate, type = "dot", damage = 50, isProjectile = false })
							end
						end
					else
						for i, info in ipairs(FAIO.armletDamageInstanceTable) do
							if info.instanceindex == mod then
								table.remove(FAIO.armletDamageInstanceTable, i)
							end
						end	
					end
				else
					for i, info in ipairs(FAIO.armletDamageInstanceTable) do
						if info.instanceindex == mod then
							table.remove(FAIO.armletDamageInstanceTable, i)
						end
					end
				end
			end
		end
	end

	return 

end

function FAIO.getAdjustedMaxTrueDamage(unit, target)

	if not unit then return 0 end
	if not target then return 0 end

	if Entity.IsDormant(unit) then return 0 end
	if Entity.IsDormant(target) then return 0 end

	local maxDamage = NPC.GetTrueMaximumDamage(unit)
	local maxTrueDamage = NPC.GetDamageMultiplierVersus(unit, target) * maxDamage * NPC.GetArmorDamageMultiplier(target)

	local bonusDamage = 0
	if NPC.HasModifier(unit, "modifier_storm_spirit_overload") and not NPC.HasState(target, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
		local overload = NPC.GetAbility(unit, "storm_spirit_overload")
		local bonus = 0
		if overload and Ability.GetLevel(overload) > 0 then
			bonus = Ability.GetDamage(overload)
		end
		local bonusTrue = (1 - NPC.GetMagicalArmorValue(target)) * bonus + bonus * (Hero.GetIntellectTotal(unit) / 14 / 100)
		bonusDamage = bonusDamage + bonusTrue
	end

	if NPC.HasAbility(unit, "clinkz_searing_arrows") then
		local orb = NPC.GetAbility(unit, "clinkz_searing_arrows")
		if orb and Ability.IsCastable(orb, NPC.GetMana(unit)) and Ability.GetLevel(orb) > 0 then
			local bonus = 20 + 10 * Ability.GetLevel(orb)
				if NPC.HasAbility(unit, "special_bonus_unique_clinkz_1") then
					if Ability.GetLevel(NPC.GetAbility(unit, "special_bonus_unique_clinkz_1")) > 0 then
						bonus = bonus + 30
					end
				end
			local bonusTrue = NPC.GetDamageMultiplierVersus(unit, target) * bonus * NPC.GetArmorDamageMultiplier(target)
			bonusDamage = bonusDamage + bonusTrue
		end
	end

	if NPC.HasAbility(unit, "obsidian_destroyer_arcane_orb") and not NPC.HasState(target, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
		local orb = NPC.GetAbility(unit, "obsidian_destroyer_arcane_orb")
		if orb and Ability.IsCastable(orb, NPC.GetMana(unit)) and Ability.GetLevel(orb) > 0 then
			local bonus = (0.05 + (0.01 * Ability.GetLevel(orb))) * NPC.GetMana(unit)
			local bonusTrue = bonus
			bonusDamage = bonusDamage + bonusTrue
		end
	end

	if NPC.HasAbility(unit, "silencer_glaives_of_wisdom") and not NPC.HasState(target, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
		local orb = NPC.GetAbility(unit, "silencer_glaives_of_wisdom")
		if orb and Ability.IsCastable(orb, NPC.GetMana(unit)) and Ability.GetLevel(orb) > 0 then
			local bonus = 0.15 * Ability.GetLevel(orb) * Hero.GetIntellectTotal(unit)
				if NPC.HasAbility(unit, "special_bonus_unique_silencer_3") then
					if Ability.GetLevel(NPC.GetAbility(unit, "special_bonus_unique_silencer_3")) > 0 then
						bonus = (0.2 + 0.15 * Ability.GetLevel(orb)) * Hero.GetIntellectTotal(unit)
					end
				end
			local bonusTrue = bonus
			bonusDamage = bonusDamage + bonusTrue
		end
	end

	if NPC.HasAbility(unit, "kunkka_tidebringer") then
		local orb = NPC.GetAbility(unit, "kunkka_tidebringer")
		if orb and Ability.IsCastable(orb, NPC.GetMana(unit)) and Ability.GetLevel(orb) > 0 then
			local bonus = Ability.GetLevelSpecialValueFor(orb, "damage_bonus")
			local bonusTrue = NPC.GetDamageMultiplierVersus(unit, target) * bonus * NPC.GetArmorDamageMultiplier(target)
			bonusDamage = bonusDamage + bonusTrue
		end
	end

	if NPC.HasAbility(unit, "enchantress_impetus") then
		local orb = NPC.GetAbility(unit, "enchantress_impetus")
		if orb and Ability.IsCastable(orb, NPC.GetMana(unit)) and Ability.GetLevel(orb) > 0 then
			local distance = (Entity.GetAbsOrigin(unit) - Entity.GetAbsOrigin(target)):Length2D() * 1.35
				if distance > 1750 then
					distance = 1750
				end
			local distanceDamage = Ability.GetLevelSpecialValueForFloat(orb, "distance_damage_pct")
				if NPC.HasAbility(unit, "special_bonus_unique_enchantress_4") then
					if Ability.GetLevel(NPC.GetAbility(unit, "special_bonus_unique_enchantress_4")) > 0 then
						distanceDamage = distanceDamage + 8
					end
				end
			local bonus = distance * (distanceDamage / 100)
			local bonusTrue = bonus
			bonusDamage = bonusDamage + bonusTrue
		end
	end

	if Entity.IsSameTeam(unit, target) then
		bonusDamage = 0
	end

	if NPC.IsStructure(target) then
		bonusDamage = 0
	end
	
	return math.ceil(maxTrueDamage + bonusDamage)

end

function FAIO.armletShouldBeToggledOff(myHero)

	if not myHero then return true end

	if FAIO.isArmletActive == false then return false end
	if FAIO.armletCurrentHPGain < 250 then return false end

	if Menu.IsEnabled(FAIO.optionItemArmletManuallyOverride) then
		if FAIO.isArmletManuallyToggled == true then 
			return false 
		end
	end

	local hpTreshold = Menu.GetValue(FAIO.optionItemArmletHPTreshold)
	local curTime = GameRules.GetGameTime()

	if #FAIO.armletDamageInstanceTable < 1 then
		if Menu.IsEnabled(FAIO.optionItemArmletCombo) then
			if Menu.IsKeyDown(FAIO.optionComboKey) then
				return false
			end
		end
		if Menu.IsEnabled(FAIO.optionItemArmletRightClick) then
			if FAIO.armletRightClickToggle then
				return false
			end
		end
		local gettingFaced = false
		for i, v in ipairs(Wrap.UnitsInRadius(myHero, 1000, Enum.TeamType.TEAM_ENEMY)) do
			if v and Wrap.EIsNPC(v) and not Entity.IsDormant(v) and not NPC.IsWaitingToSpawn(v) and NPC.GetUnitName(v) ~= "npc_dota_neutral_caster" then
				if NPC.FindFacingNPC(v) == myHero then
					if NPC.IsRanged(v) then
						if NPC.IsEntityInRange(myHero, v, NPC.GetAttackRange(v) + 145) then
							gettingFaced = true
						end
					else
						if NPC.IsEntityInRange(myHero, v, 285) then
							gettingFaced = true
						end
					end
				end
			end
		end
		if gettingFaced then
			if Entity.GetHealth(myHero) > hpTreshold then
				return false
			end
		end
		return true
	else
		local nextDamageInstance = 9999
			for i, v in ipairs(FAIO.armletDamageInstanceTable) do
				if v and v.time - GameRules.GetGameTime() > 0.0 then
					if i < nextDamageInstance then
						nextDamageInstance = i
					end
				end
			end
		if nextDamageInstance > 999 then
			if Menu.IsEnabled(FAIO.optionItemArmletCombo) then
				if Menu.IsKeyDown(FAIO.optionComboKey) then
					if Entity.GetHealth(myHero) > hpTreshold then
						return false
					end
				end
			end
			if Menu.IsEnabled(FAIO.optionItemArmletRightClick) then
				if FAIO.armletRightClickToggle then
					if Entity.GetHealth(myHero) > hpTreshold then
						return false
					end
				end
			end
			local gettingFaced = false
			for i, v in ipairs(Wrap.UnitsInRadius(myHero, 1000, Enum.TeamType.TEAM_ENEMY)) do
				if v and Wrap.EIsNPC(v) and not Entity.IsDormant(v) and not NPC.IsWaitingToSpawn(v) and NPC.GetUnitName(v) ~= "npc_dota_neutral_caster" then
					if NPC.FindFacingNPC(v) == myHero then
						if NPC.IsRanged(v) then
							if NPC.IsEntityInRange(myHero, v, NPC.GetAttackRange(v) + 145) then
								gettingFaced = true
							end
						else
							if NPC.IsEntityInRange(myHero, v, 285) then
								gettingFaced = true
							end
						end
					end
				end
			end
			if gettingFaced then
				if Entity.GetHealth(myHero) > hpTreshold then
					return false
				end
			end
			
			local inBackSwing = true
				for k, l in ipairs(FAIO.armletDamageInstanceTable) do
					if l.backswingstart ~= nil and l.backswingend ~= nil then
						if GameRules.GetGameTime() < l.backswingstart or GameRules.GetGameTime() > l.backswingend - 0.15 then
							inBackSwing = false
							break
						end
					end
				end

			if not inBackSwing then
				return false
			end

			local lastDamageInstanceTime = FAIO.armletDamageInstanceTable[#FAIO.armletDamageInstanceTable]["time"]
			if GameRules.GetGameTime() > lastDamageInstanceTime + 0.075 then
				return true
			end
		else
			local safeToggle = false
			local emergencyToggle = false
			for i, instance in ipairs(FAIO.armletDamageInstanceTable) do
				local instanceTiming = instance.time
				local instanceDamage = instance.damage + math.ceil((instanceTiming - curTime) / 0.11) * 6	
				local toggleTreshold = math.max(instanceDamage, hpTreshold)
				if instanceDamage > Entity.GetHealth(myHero) then
					if i > 1 then
						if GameRules.GetGameTime() - FAIO.armletDamageInstanceTable[i-1]["time"] > 0.075 then
							emergencyToggle = true
							break
						end
					else
						emergencyToggle = true
						break
					end
				else
					if Entity.GetHealth(myHero) <= toggleTreshold then
						if instanceTiming - GameRules.GetGameTime() > 0.42 then
							local inBackSwing = true
								for k, l in ipairs(FAIO.armletDamageInstanceTable) do
									if l.backswingstart ~= nil and l.backswingend ~= nil then
										if GameRules.GetGameTime() < l.backswingstart or GameRules.GetGameTime() > l.backswingend - 0.15 then
											if l.casttime < 0.25 then
												inBackSwing = false
												break
											end
										end
									end
								end
							if inBackSwing then
								if i > 1 then
									if GameRules.GetGameTime() - FAIO.armletDamageInstanceTable[i-1]["time"] > 0.075 then
										safeToggle = true
										break
									end
								else
									safeToggle = true
									break
								end	
							end
						end
					else
						local adjustedHP = math.max((Entity.GetHealth(myHero) - FAIO.armletCurrentHPGain), 1)
						if adjustedHP > toggleTreshold and (not Menu.IsKeyDown(FAIO.optionComboKey) or FAIO.armletRightClickToggle) then
							safeToggle = true
						end
					end
				end	
			end

			if emergencyToggle then
				return true
			end

			if safeToggle then
				return true
			end
		end
	end

	return false
end
				
function FAIO.armletShouldBeToggledOn(myHero)

	if not myHero then return false end

	if FAIO.isArmletActive == true then return false end

	if Menu.IsEnabled(FAIO.optionItemArmletManuallyOverride) then
		if FAIO.isArmletManuallyToggled == true then 
			return false 
		end
	end

	if NPC.HasModifier(myHero, "modifier_ice_blast") then
		return false
	end

	local hpTreshold = Menu.GetValue(FAIO.optionItemArmletHPTreshold)
	local myHP = Entity.GetHealth(myHero)

	if Menu.IsEnabled(FAIO.optionItemArmletCombo) then
		if Menu.IsKeyDown(FAIO.optionComboKey) then
			if FAIO.LockedTarget ~= nil then
				return true
			end
		end
	end

	if myHP < hpTreshold then
		for i, v in ipairs(Wrap.UnitsInRadius(myHero, 1000, Enum.TeamType.TEAM_ENEMY)) do
			if v and Wrap.EIsNPC(v) and not Entity.IsDormant(v) and not NPC.IsWaitingToSpawn(v) and NPC.GetUnitName(v) ~= "npc_dota_neutral_caster" then
				if NPC.FindFacingNPC(v) == myHero then
					if NPC.IsRanged(v) then
						if NPC.IsEntityInRange(myHero, v, NPC.GetAttackRange(v) + 145) then
							return true
						end
					else
						if NPC.IsEntityInRange(myHero, v, 285) then
							return true
						end
					end
				end
			end
		end
	end

	if Menu.IsEnabled(FAIO.optionItemArmletRightClick) then
		if FAIO.armletRightClickToggle then
			return true
		end
	end

	for i, info in ipairs(FAIO.armletDamageInstanceTable) do
		if info then
			local nextInstance = info.time
			local nextDamage = info.damage
			local triggerTreshold = math.max(hpTreshold, nextDamage)
			if nextInstance > GameRules.GetGameTime() then
				if nextInstance - GameRules.GetGameTime() <= 1.0 then
					if myHP <= triggerTreshold then	
						return true
					end
				end
			end
		end
	end

	return false
end

function FAIO.armletHandler(myHero)

	if not myHero then return end

	local armlet = NPC.GetItem(myHero, "item_armlet", true)
		if not armlet then return end

	FAIO.armletProcessInstanceTable(myHero)
	FAIO.getDotDamageTicks(myHero)
	FAIO.getAbilityDamageInstances(myHero)

	if Ability.GetToggleState(armlet) then
		if os.clock() - FAIO.armletToggleTimePingAdjuster <= (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetAvgLatency(Enum.Flow.FLOW_INCOMING)) / 2 + 0.05 then
			FAIO.isArmletActive = FAIO.isArmletActive
		else
			FAIO.isArmletActive = true
		end
	else
		if os.clock() - FAIO.armletToggleTimePingAdjuster <= (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetAvgLatency(Enum.Flow.FLOW_INCOMING)) / 2 + 0.05 then
			FAIO.isArmletActive = FAIO.isArmletActive
		else
			FAIO.isArmletActive = false
		end
		if FAIO.isArmletManuallyToggled == true and GameRules.GetGameTime() - FAIO.isArmletManuallyToggledTime >= 0.1 then
			FAIO.isArmletManuallyToggled = false
		end
	end

	local armletModifier = NPC.GetModifier(myHero, "modifier_item_armlet_unholy_strength")
	local maxHPGain = 464
	if armletModifier ~= nil then
		local armletStartTime = Modifier.GetCreationTime(armletModifier)
		if GameRules.GetGameTime() - armletStartTime > 0.6 then
			FAIO.armletCurrentHPGain = maxHPGain
		else
			if GameRules.GetGameTime() - armletStartTime > 0 then
				FAIO.armletCurrentHPGain = math.floor((GameRules.GetGameTime() - armletStartTime) * (maxHPGain/0.6))
			end
		end
	else
		FAIO.armletCurrentHPGain = 0
	end

	if os.clock() < FAIO.armletDelayer then return end

	if Menu.IsEnabled(FAIO.optionItemArmletManuallyOverride) then
		if FAIO.isArmletManuallyToggled then 
			return 
		end
	end

	if FAIO.heroCanCastItems(myHero) == false then return end
	if FAIO.IsHeroInvisible(myHero) == true then return end

	if os.clock() < FAIO.armletToggleTime then return end

	if FAIO.armletShouldBeToggledOn(myHero) then
		Ability.Toggle(armlet)
		FAIO.isArmletActive = true
		FAIO.armletToggleTime = os.clock() + 0.65 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)
		FAIO.armletToggleTimePingAdjuster = os.clock()
		return
	end

	if FAIO.armletShouldBeToggledOff(myHero) then
		if os.clock() - FAIO.armletToggleTime > 0.04 then
			Ability.Toggle(armlet)
			FAIO.isArmletActive = false
			FAIO.armletToggleTime = os.clock() + 0.01
			FAIO.armletToggleTimePingAdjuster = os.clock()
			return
		end
	end

end

-- linkens breaker functions
function FAIO.LinkensBreakerNew(myHero)

	if not myHero then return end

	if not Menu.IsEnabled(FAIO.optionLinkensEnable) then return end

	local myMana = NPC.GetMana(myHero)

 	local prioItem
	local prioOrder = 0

	for k, v in ipairs(FAIO.LinkensBreakerItemOrder) do
	
		if NPC.HasItem(myHero, v[2], true) then
			if Ability.IsCastable(NPC.GetItem(myHero, v[2], true), myMana) and v[1] > prioOrder then
					prioItem = v[2]
					prioOrder = v[1]
				
			end
		end	
	
	end
	return prioItem	
end
	
-- utility item usage functions
function FAIO.utilityItemUsage(myHero)

	if not myHero then return end

	if FAIO.heroCanCastItems(myHero) == false then return end
	if FAIO.isHeroChannelling(myHero) == true then return end
	if FAIO.IsHeroInvisible(myHero) == true then return end

	local stick = NPC.GetItem(myHero, "item_magic_stick", true)
	local wand = NPC.GetItem(myHero, "item_magic_wand", true)
	local mekansm = NPC.GetItem(myHero, "item_mekansm", true)
	local greaves = NPC.GetItem(myHero, "item_guardian_greaves", true)
	local arcane = NPC.GetItem(myHero, "item_arcane_boots", true)
	local midas = NPC.GetItem(myHero, "item_hand_of_midas", true)
	local cheese = NPC.GetItem(myHero, "item_cheese", true)
	local faerie = NPC.GetItem(myHero, "item_faerie_fire", true)
	local bottle = NPC.GetItem(myHero, "item_bottle", true)

	local myMana = NPC.GetMana(myHero)

	if (stick or wand or cheese or faerie) and Menu.IsEnabled(FAIO.optionUtilityStick) then
		FAIO.utilityItemStick(myHero, stick, wand, cheese, faerie)
	end
	if mekansm and Menu.IsEnabled(FAIO.optionUtilityMek) then
		FAIO.utilityItemMek(myHero, mekansm, myMana)
	end
	if greaves and Menu.IsEnabled(FAIO.optionUtilityGreaves) then
		FAIO.utilityItemGreaves(myHero, greaves)
	end
	if arcane and Menu.IsEnabled(FAIO.optionUtilityArcane) then
		FAIO.utilityItemArcane(myHero, arcane)
	end
	if midas and Menu.IsEnabled(FAIO.optionUtilityMidas) then
		FAIO.utilityItemMidas(myHero, midas)
	end
	if bottle and Menu.IsEnabled(FAIO.optionUtilityBottle) then
		FAIO.utilityItemBottle(myHero, bottle)
	end

end

function FAIO.utilityItemStick(myHero, stick, wand, cheese, faerie)

	if not myHero then return end
	if (Entity.GetAbsOrigin(myHero) - FAIO.GetMyFountainPos(myHero)):Length2D() < 1500 then return end
	
	local myHealthPerc = (Entity.GetHealth(myHero) / Entity.GetMaxHealth(myHero)) * 100
	
	if Wrap.EIsAlive(myHero) and not NPC.HasModifier(myHero, "modifier_ice_blast") then
		if stick and myHealthPerc <= Menu.GetValue(FAIO.optionUtilityHealth) and Ability.IsReady(stick) then
			if Item.GetCurrentCharges(stick) >= 1 then 
				Ability.CastNoTarget(stick)
				return
			end
		end
		if wand and myHealthPerc <= Menu.GetValue(FAIO.optionUtilityHealth) and Ability.IsReady(wand) then 
			if Item.GetCurrentCharges(wand) >= 1 then 
				Ability.CastNoTarget(wand)
				return
			end
		end
		if cheese and myHealthPerc <= Menu.GetValue(FAIO.optionUtilityHealth) and Ability.IsReady(cheese) then 
			Ability.CastNoTarget(cheese)
			return
		end
		if faerie and myHealthPerc <= Menu.GetValue(FAIO.optionUtilityHealth) and Ability.IsReady(faerie) then 
			Ability.CastNoTarget(faerie)
			return
		end
	end
end

function FAIO.utilityItemBottle(myHero, bottle)

	if not myHero then return end
	if not bottle then return end
		if Item.GetCurrentCharges(bottle) < 2 then return end

	if Ability.SecondsSinceLastUse(bottle) > -1 and Ability.SecondsSinceLastUse(bottle) < 0.5 then return end
	if os.clock() < FAIO.lastTick then return end

	for i = 1, Abilities.Count() do 
		local abilities = Abilities.Get(i)

		if Entity.GetOwner(abilities) == myHero then
			if Ability.SecondsSinceLastUse(abilities) > -1 and Ability.SecondsSinceLastUse(abilities) < 0.5 then 
				return
			end
		end
	end

	if NPC.HasModifier(myHero, "modifier_bottle_regeneration") then return end
	if not NPC.HasModifier(myHero, "modifier_item_empty_bottle") then return end

	local hpGap = Entity.GetHealth(myHero) / Entity.GetMaxHealth(myHero)
	local manaGap = NPC.GetMana(myHero) / NPC.GetMaxMana(myHero)

	for i, v in ipairs(Wrap.UnitsInRadius(myHero, 1000, Enum.TeamType.TEAM_ENEMY)) do
		if v and Wrap.EIsNPC(v) and Wrap.EIsAlive(v) and not Entity.IsDormant(v) then
			if Entity.IsHero(v) then
				if NPC.IsEntityInRange(myHero, v, NPC.GetAttackRange(v) + 250) then
					return
				end
			else
				if NPC.GetUnitName(v) == "npc_dota_roshan" then
					if NPC.IsEntityInRange(myHero, v, NPC.GetAttackRange(v) + 375) then
						return
					end
				end
			end	
		end
	end
			
	if hpGap < 0.75 then
		Ability.CastNoTarget(bottle)
		return
	end

	if manaGap < 0.75 then
		Ability.CastNoTarget(bottle)
		return
	end

	return

end

function FAIO.utilityItemMek(myHero, mekansm, myMana)

	if not myHero then return end
	if not mekansm then return end

	if (Entity.GetAbsOrigin(myHero) - FAIO.GetMyFountainPos(myHero)):Length2D() < 1500 then return end

	local myHealthPerc = (Entity.GetHealth(myHero) / Entity.GetMaxHealth(myHero)) * 100

	if Ability.IsCastable(mekansm, myMana) then
		if Wrap.EIsAlive(myHero) and not NPC.HasModifier(myHero, "modifier_ice_blast") then	
			if (myHealthPerc <= Menu.GetValue(FAIO.optionUtilityHealth)) and Ability.IsCastable(mekansm, myMana) then 
				Ability.CastNoTarget(mekansm) 
				return
			end
		end

		for _, teamMates in ipairs(Wrap.HeroesInRadius(myHero, 900, Enum.TeamType.TEAM_FRIEND)) do
			if teamMates then
				if Wrap.EIsAlive(myHero) and Wrap.EIsAlive(teamMates) and not NPC.HasModifier(teamMates, "modifier_ice_blast") then	
					if (Entity.GetHealth(teamMates) / Entity.GetMaxHealth(teamMates)) * 100 <= Menu.GetValue(FAIO.optionUtilityHealth) and Ability.IsCastable(mekansm, myMana) then
						for _, v in ipairs(Wrap.HeroesInRadius(teamMates, 1000, Enum.TeamType.TEAM_ENEMY)) do
							if v and Entity.IsHero(v) and not Entity.IsDormant(v) then
								if NPC.FindFacingNPC(v) == teamMates then
									Ability.CastNoTarget(mekansm) 
									break
									return
								end
							end
						end
					end
				end
			end
		end
	end
end

function FAIO.utilityItemGreaves(myHero, greaves)

	if not myHero then return end
	if not greaves then return end

	if (Entity.GetAbsOrigin(myHero) - FAIO.GetMyFountainPos(myHero)):Length2D() < 1500 then return end

	local myHealthPerc = (Entity.GetHealth(myHero) / Entity.GetMaxHealth(myHero)) * 100

	if Ability.IsReady(greaves) then
		if Wrap.EIsAlive(myHero) and not NPC.HasModifier(myHero, "modifier_ice_blast") then	
			if greaves and (myHealthPerc <= Menu.GetValue(FAIO.optionUtilityHealth)) and Ability.IsReady(greaves) then 
				Ability.CastNoTarget(greaves) 
				return
			end
		end

		for _, teamMates in ipairs(Wrap.HeroesInRadius(myHero, 900, Enum.TeamType.TEAM_FRIEND)) do
			if teamMates then
				if Wrap.EIsAlive(myHero) and Wrap.EIsAlive(teamMates) and not NPC.HasModifier(teamMates, "modifier_ice_blast") then	
					if greaves and (Entity.GetHealth(teamMates) / Entity.GetMaxHealth(teamMates)) * 100 <= Menu.GetValue(FAIO.optionUtilityHealth) and Ability.IsReady(greaves) then
						for _, v in ipairs(Wrap.HeroesInRadius(teamMates, 1000, Enum.TeamType.TEAM_ENEMY)) do
							if v and Entity.IsHero(v) and not Entity.IsDormant(v) then
								if NPC.FindFacingNPC(v) == teamMates then
									Ability.CastNoTarget(greaves) 
									break
									return
								end
							end
						end
					end
				end
			end
		end
	end
end

function FAIO.utilityItemArcane(myHero, arcane)

	if not myHero then return end
	if not arcane then return end

	if (Entity.GetAbsOrigin(myHero) - FAIO.GetMyFountainPos(myHero)):Length2D() < 3000 then return end

	local myManaMissing = NPC.GetMaxMana(myHero) - NPC.GetMana(myHero)

	if Ability.IsReady(arcane) then
		if Wrap.EIsAlive(myHero) then
			if arcane and myManaMissing >= 200 then 
				Ability.CastNoTarget(arcane)
				return 
			end
		end


		for _, teamMates in ipairs(Wrap.HeroesInRadius(myHero, 900, Enum.TeamType.TEAM_FRIEND)) do
			if teamMates then
				if Wrap.EIsAlive(myHero) and Wrap.EIsAlive(teamMates) then
					if arcane and (NPC.GetMana(teamMates) / NPC.GetMaxMana(teamMates)) * 100 <= 40 and Ability.IsReady(arcane) then 
						Ability.CastNoTarget(arcane)
						break
						return
					end
				end 
			end
		end
	end
end

function FAIO.utilityItemMidas(myHero, midas)

	if not myHero then return end
	if not midas then return end
	if not Ability.IsReady(midas) then return end

	if FAIO.heroCanCastItems(myHero) == false then return end
	if FAIO.isHeroChannelling(myHero) == true then return end
	if FAIO.IsHeroInvisible(myHero) == true then return end

	if NPC.HasModifier(myHero, "modifier_spirit_breaker_charge_of_darkness") then return end

	local targetCreep
	local maxXP = 0

	for _, creeps in ipairs(Wrap.UnitsInRadius(myHero, 600, Enum.TeamType.TEAM_ENEMY)) do
		if creeps and not Entity.IsHero(creeps) then
			local bounty = NPC.GetBountyXP(creeps)
			if FAIO.IsCreepAncient(creeps) == false then
				if (NPC.IsLaneCreep(creeps) or NPC.IsCreep(creeps)) and not Entity.IsDormant(creeps) then
					if bounty > maxXP then
						targetCreep = creeps
						maxXP = bounty
					end	
				end
			end
		end
	end

	if targetCreep ~= nil and maxXP > 0 then
		Ability.CastTarget(midas, targetCreep)
		return
	end

end

function FAIO.useDefensiveItems(myHero, enemy)

	if not myHero then return end
	if not Menu.IsEnabled(FAIO.optionDefensiveItems) then return end

	if (Entity.GetAbsOrigin(myHero) - FAIO.GetMyFountainPos(myHero)):Length2D() < 1500 then return end

	if os.clock() - FAIO.lastDefItemPop < 0.25 then return end

	if FAIO.ItemCastStop then return end

	if FAIO.heroCanCastItems(myHero) == false then return end
	if FAIO.IsHeroInvisible(myHero) == true then return end

	local myMana = NPC.GetMana(myHero)

	local glimmerCape = NPC.GetItem(myHero, "item_glimmer_cape", true)
	local lotusOrb = NPC.GetItem(myHero, "item_lotus_orb", true)
	local crimsonGuard = NPC.GetItem(myHero, "item_crimson_guard", true)
	local pipe = NPC.GetItem(myHero, "item_pipe", true)
	local solarCrest = NPC.GetItem(myHero, "item_solar_crest", true)
	local BKB = NPC.GetItem(myHero, "item_black_king_bar", true)
	local satanic = NPC.GetItem(myHero, "item_satanic", true)
	local medallion = NPC.GetItem(myHero, "item_medallion_of_courage", true)
	local ghost = NPC.GetItem(myHero, "item_ghost", true)
	local eBlade = NPC.GetItem(myHero, "item_ethereal_blade", true)

	local channellingTable = {
		"bane_fiends_grip",
		"crystal_maiden_freezing_field",
		"enigma_black_hole",
		"pudge_dismember",
		"pugna_life_drain",
		"sandking_epicenter",
		"shadow_shaman_shackles",
		"warlock_upheaval",
		"witch_doctor_death_ward"
				}

	if Menu.IsEnabled(FAIO.optionDefensiveItemsGlimmer) then
		if glimmerCape and Ability.IsCastable(glimmerCape, myMana) then
			if FAIO.IsNPCinDanger(myHero, myHero) then
				Ability.CastTarget(glimmerCape, myHero)
				FAIO.lastDefItemPop = os.clock()
				return
			end
			if NPC.IsChannellingAbility(myHero) then
				for _, ability in ipairs(channellingTable) do
					if NPC.HasAbility(myHero, ability) and Ability.IsChannelling(NPC.GetAbility(myHero, ability)) then
						Ability.CastTarget(glimmerCape, myHero)
						FAIO.lastDefItemPop = os.clock()
						return
					end
				end
			end
			if NPC.HasModifier(myHero, "modifier_teleporting") then
				local myFountain = FAIO.GetMyFountainPos(myHero)
				if not NPC.IsPositionInRange(myHero, myFountain, 2500, 0) then
					Ability.CastTarget(glimmerCape, myHero)
					FAIO.lastDefItemPop = os.clock()
					return
				end
			end
			if Menu.IsEnabled(FAIO.optionDefensiveItemsAlly) then
				local teamMatesAround = Wrap.HeroesInRadius(myHero, 1000, Enum.TeamType.TEAM_FRIEND)
				for _, ally in ipairs(teamMatesAround) do
					if ally and not NPC.IsIllusion(ally) and Wrap.EIsAlive(ally) then
						if FAIO.IsNPCinDanger(myHero, ally) then
							Ability.CastTarget(glimmerCape, ally)
							FAIO.lastDefItemPop = os.clock()
							break
							return
						end
						if NPC.IsChannellingAbility(ally) then
							for _, ability in ipairs(channellingTable) do
								if NPC.HasAbility(ally, ability) and Ability.IsChannelling(NPC.GetAbility(ally, ability)) then
									Ability.CastTarget(glimmerCape, ally)
									FAIO.lastDefItemPop = os.clock()
									return
								end
							end
						end
					end
				end
			end
		end
	end

	if FAIO.isHeroChannelling(myHero) == true then return end

	if Menu.IsEnabled(FAIO.optionDefensiveItemsGhost) then
		if ghost and Ability.IsReady(ghost) then
			if Entity.GetHealth(myHero) <= Menu.GetValue(FAIO.optionDefensiveItemsThreshold)/100 * Entity.GetMaxHealth(myHero) then
				for _, v in ipairs(Wrap.HeroesInRadius(myHero, 800, Enum.TeamType.TEAM_ENEMY)) do
					if v and Entity.IsHero(v) and not Entity.IsDormant(v) and not NPC.IsIllusion(v) then
						if NPC.FindFacingNPC(v) == myHero then
							if NPC.IsEntityInRange(myHero, v, NPC.GetAttackRange(v) + 140) then
								if NPC.IsAttacking(v) then
									Ability.CastNoTarget(ghost)
									FAIO.lastDefItemPop = os.clock()
									break
									return
								end
							end
						end
					end
				end	
			end
		end
	end
				
	if Menu.IsEnabled(FAIO.optionDefensiveItemslotusOrb) then
		if lotusOrb and Ability.IsCastable(lotusOrb, myMana) then
			if FAIO.IsNPCinDanger(myHero, myHero) then
				Ability.CastTarget(lotusOrb, myHero)
				FAIO.lastDefItemPop = os.clock()
				return
			end
			if Menu.IsEnabled(FAIO.optionDefensiveItemsAlly) then
				local teamMatesAround = Wrap.HeroesInRadius(myHero, 875, Enum.TeamType.TEAM_FRIEND)
				for _, ally in ipairs(teamMatesAround) do
					if ally and not NPC.IsIllusion(ally) and Wrap.EIsAlive(ally) then
						if FAIO.IsNPCinDanger(myHero, ally) then
							Ability.CastTarget(lotusOrb, ally)
							FAIO.lastDefItemPop = os.clock()
							break
							return
						end
					end
				end
			end
		end
	end
	
	if Menu.IsEnabled(FAIO.optionDefensiveItemsCrimson) then
		if crimsonGuard and Ability.IsCastable(crimsonGuard, myMana) then
			if FAIO.IsNPCinDanger(myHero, myHero) then
				Ability.CastNoTarget(crimsonGuard)
				FAIO.lastDefItemPop = os.clock()
				return
			end
			local teamMatesAround = Wrap.HeroesInRadius(myHero, 875, Enum.TeamType.TEAM_FRIEND)
			for _, ally in ipairs(teamMatesAround) do
				if ally and not NPC.IsIllusion(ally) and Wrap.EIsAlive(ally) then
					if FAIO.IsNPCinDanger(myHero, ally) then
						Ability.CastNoTarget(crimsonGuard)
						FAIO.lastDefItemPop = os.clock()
						break
						return
					end
				end
			end
		end
	end

	if Menu.IsEnabled(FAIO.optionDefensiveItemsCrest) then
		if solarCrest and Ability.IsCastable(solarCrest, myMana) then
			if Menu.IsEnabled(FAIO.optionDefensiveItemsAlly) then
				local teamMatesAround = Wrap.HeroesInRadius(myHero, 975, Enum.TeamType.TEAM_FRIEND)
				for _, ally in ipairs(teamMatesAround) do
					if ally and not NPC.IsIllusion(ally) and Wrap.EIsAlive(ally) then
						if FAIO.IsNPCinDanger(myHero, ally) then
							Ability.CastTarget(solarCrest, ally)
							FAIO.lastDefItemPop = os.clock()
							break
							return
						end
					end
				end
			end
		end
	end

	if Menu.IsEnabled(FAIO.optionDefensiveItemsMedallion) then
		if medallion and Ability.IsCastable(medallion, myMana) then
			if Menu.IsEnabled(FAIO.optionDefensiveItemsAlly) then
				local teamMatesAround = Wrap.HeroesInRadius(myHero, 975, Enum.TeamType.TEAM_FRIEND)
				for _, ally in ipairs(teamMatesAround) do
					if ally and not NPC.IsIllusion(ally) and Wrap.EIsAlive(ally) then
						if FAIO.IsNPCinDanger(myHero, ally) then
							Ability.CastTarget(medallion, ally)
							FAIO.lastDefItemPop = os.clock()
							break
							return
						end
					end
				end
			end
		end
	end

	if Menu.IsEnabled(FAIO.optionDefensiveItemsPipe) then
		if pipe and Ability.IsCastable(pipe, myMana) then
			if FAIO.IsNPCinDanger(myHero, myHero) then
				Ability.CastNoTarget(pipe)
				FAIO.lastDefItemPop = os.clock()
				return
			end
			local teamMatesAround = Wrap.HeroesInRadius(myHero, 875, Enum.TeamType.TEAM_FRIEND)
			for _, ally in ipairs(teamMatesAround) do
				if ally and not NPC.IsIllusion(ally) and Wrap.EIsAlive(ally) then
					if FAIO.IsNPCinDanger(myHero, ally) then
						Ability.CastNoTarget(pipe)
						FAIO.lastDefItemPop = os.clock()
						break
						return
					end
				end
			end
		end
	end

	if Menu.IsEnabled(FAIO.optionDefensiveItemsBKB) then
		if BKB and Ability.IsReady(BKB) then
			if FAIO.shouldCastBKB(myHero) == true then
				Ability.CastNoTarget(BKB)
				FAIO.lastDefItemPop = os.clock()
				return
			end
		end
	end
	
	if Menu.IsEnabled(FAIO.optionDefensiveItemsSatanic) then
		if satanic and Ability.IsCastable(satanic, myMana) then			
			if FAIO.shouldCastSatanic(myHero, enemy) == true then
				Ability.CastNoTarget(satanic)
				FAIO.lastDefItemPop = os.clock()
				return
			end
		end
	end
end

function FAIO.IsNPCinDanger(myHero, npc)

	if not myHero then return false end
	if not npc or NPC.IsIllusion(npc) or not Wrap.EIsAlive(npc) then return false end

	if NPC.HasState(npc, Enum.ModifierState.MODIFIER_STATE_INVULNERABLE) then return false end
	if NPC.HasState(myHero, Enum.ModifierState.MODIFIER_STATE_INVULNERABLE) then return false end
	if NPC.HasModifier(npc, "modifier_item_lotus_orb_active") then return false end

	if NPC.HasModifier(npc, "modifier_dazzle_shallow_grave") then return false end
	if FAIO.IsHeroInvisible(npc) == true then return false end
	if NPC.HasModifier(npc, "modifier_fountain_aura_buff") then return false end

	if #Wrap.HeroesInRadius(npc, 1500, Enum.TeamType.TEAM_ENEMY) < 1 then return false end
	if #Wrap.HeroesInRadius(myHero, 1500, Enum.TeamType.TEAM_ENEMY) < 1 then return false end
	if (Entity.GetAbsOrigin(myHero) - FAIO.GetMyFountainPos(myHero)):Length2D() < 1500 then return end

	if NPC.GetUnitName(npc) == "npc_dota_hero_monkey_king" then
		if NPC.GetAbilityByIndex(npc, 1) ~= nil then
			if Ability.SecondsSinceLastUse(NPC.GetAbilityByIndex(npc, 1)) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbilityByIndex(npc, 1)) < 2 then
				return false
			end
		end
	end

	if NPC.GetUnitName(npc) == "npc_dota_hero_nyx_assassin" then
		if NPC.GetAbility(npc, "nyx_assassin_burrow") ~= nil and Ability.GetLevel(NPC.GetAbility(npc, "nyx_assassin_burrow")) > 0 then
			if Ability.IsInAbilityPhase(NPC.GetAbility(npc, "nyx_assassin_burrow")) then
				return false
			elseif not Ability.IsHidden(NPC.GetAbility(npc, "nyx_assassin_unburrow")) then
				return false
			end
		end
	end

	if NPC.GetUnitName(npc) == "npc_dota_hero_sand_king" then
		if NPC.GetAbility(npc, "sandking_burrowstrike") ~= nil then
			local burrow = NPC.GetAbility(npc, "sandking_burrowstrike")
			if Ability.SecondsSinceLastUse(burrow) > -1 and Ability.SecondsSinceLastUse(burrow) < 1 then
				return false
			end
		end
	end

	if NPC.GetUnitName(npc) == "npc_dota_hero_earth_spirit" then
		if NPC.GetAbility(npc, "earth_spirit_rolling_boulder") ~= nil then
			local boulder = NPC.GetAbility(npc, "earth_spirit_rolling_boulder")
			if Ability.SecondsSinceLastUse(boulder) > -1 and Ability.SecondsSinceLastUse(boulder) < 2 then
				return false
			end
		end
	end
	
	local momSilenced = false
	if NPC.HasItem(npc, "item_mask_of_madness", true) then
		local mom = NPC.GetItem(npc, "item_mask_of_madness", true)
		if Ability.SecondsSinceLastUse(mom) > -1 and Ability.SecondsSinceLastUse(mom) < 8 then
			momSilenced = true
		end
	end

	if NPC.HasModifier(npc, "modifier_nyx_assassin_burrow") then return false end
	if NPC.HasModifier(npc, "modifier_monkey_king_tree_dance_activity") then return false end

	if FAIO.TargetGotDisableModifier(myHero, npc) == true or (NPC.IsSilenced(npc) and not momSilenced) or
		NPC.HasModifier(npc, "modifier_item_nullifier_mute") or NPC.HasState(npc, Enum.ModifierState.MODIFIER_STATE_HEXED) then

		if Entity.GetHealth(npc) / Entity.GetMaxHealth(npc) <= (Menu.GetValue(FAIO.optionDefensiveItemsThresholdDisable) / 100) then
			for _, v in ipairs(Wrap.HeroesInRadius(myHero, 1000, Enum.TeamType.TEAM_ENEMY)) do
				if v and Entity.IsHero(v) and not Entity.IsDormant(v) then
					if NPC.FindFacingNPC(v) == npc or NPC.IsEntityInRange(npc, v, NPC.GetAttackRange(v) + 150) then
						return true
					end
				end
			end
		end
	end

	if Entity.GetHealth(npc) <= Menu.GetValue(FAIO.optionDefensiveItemsThreshold)/100 * Entity.GetMaxHealth(npc) then
		for _, v in ipairs(Wrap.HeroesInRadius(npc, 1000, Enum.TeamType.TEAM_ENEMY)) do
			if v and Entity.IsHero(v) and not Entity.IsDormant(v) then
				if NPC.FindFacingNPC(v) == npc then
					return true
				end
			end
		end
	end

	return false

end

function FAIO.IsHeroInvisible(myHero)

	if not myHero then return false end
	if not Wrap.EIsAlive(myHero) then return false end

	if NPC.HasState(myHero, Enum.ModifierState.MODIFIER_STATE_INVISIBLE) then return true end
	if NPC.HasModifier(myHero, "modifier_invoker_ghost_walk_self") then return true end
	if NPC.HasAbility(myHero, "invoker_ghost_walk") then
		if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) < 1 then 
			return true
		end
	end

	if NPC.HasItem(myHero, "item_invis_sword", true) then
		if Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_invis_sword", true)) > -1 and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_invis_sword", true)) < 1 then 
			return true
		end
	end
	if NPC.HasItem(myHero, "item_silver_edge", true) then
		if Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_silver_edge", true)) > -1 and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_silver_edge", true)) < 1 then 
			return true
		end
	end

	return false
		
end

function FAIO.TargetGotDisableModifier(myHero, npc)

	if not myHero then return false end
	if not npc then return false end

	local stunRootList = {
		"modifier_stunned",
		"modifier_bashed",
		"modifier_alchemist_unstable_concoction", 
		"modifier_ancientapparition_coldfeet_freeze", 
		"modifier_axe_berserkers_call",
		"modifier_bane_fiends_grip",
		"modifier_bane_nightmare",
		"modifier_bloodseeker_rupture",
		"modifier_rattletrap_hookshot", 
		"modifier_earthshaker_fissure_stun", 
		"modifier_earth_spirit_boulder_smash",
		"modifier_enigma_black_hole_pull",
		"modifier_faceless_void_chronosphere_freeze",
		"modifier_jakiro_ice_path_stun", 
		"modifier_keeper_of_the_light_mana_leak_stun", 
		"modifier_kunkka_torrent", 
		"modifier_legion_commander_duel", 
		"modifier_lion_impale", 
		"modifier_magnataur_reverse_polarity", 
		"modifier_medusa_stone_gaze_stone", 
		"modifier_morphling_adaptive_strike", 
		"modifier_naga_siren_ensnare", 
		"modifier_nyx_assassin_impale", 
		"modifier_pudge_dismember", 
		"modifier_sandking_impale", 
		"modifier_shadow_shaman_shackles", 
		"modifier_techies_stasis_trap_stunned", 
		"modifier_tidehunter_ravage", 
		"modifier_treant_natures_guise",
		"modifier_windrunner_shackle_shot",
		"modifier_rooted", 
		"modifier_crystal_maiden_frostbite", 
		"modifier_ember_spirit_searing_chains", 
		"modifier_meepo_earthbind",
		"modifier_lone_druid_spirit_bear_entangle_effect",
		"modifier_slark_pounce_leash",
		"modifier_storm_spirit_electric_vortex_pull",
		"modifier_treant_overgrowth", 
		"modifier_abyssal_underlord_pit_of_malice_ensare", 
		"modifier_item_rod_of_atos_debuff",
			}
	
	local searchMod
	for _, modifier in ipairs(stunRootList) do
		if NPC.HasModifier(npc, modifier) then
			searchMod = NPC.GetModifier(npc, modifier)
			break
		end
	end

	local timeleft = 0
	if searchMod then
		if NPC.HasModifier(npc, Modifier.GetName(searchMod)) then
			if Modifier.GetName(searchMod) == "modifier_enigma_black_hole_pull" then
				timeleft = Modifier.GetCreationTime(searchMod) + 4
			elseif Modifier.GetName(searchMod) == "modifier_faceless_void_chronosphere_freeze" then
				timeleft = Modifier.GetCreationTime(searchMod) + 4.5
			else
				timeleft = Modifier.GetDieTime(searchMod)
			end
		else
			timeleft = 0
		end
	else
		timeleft = 0
	end

	if timeleft > 0.75 then
		return true
	end

	return false

end

function FAIO.heroCanCastSpells(myHero, enemy)

	if not myHero then return false end
	if not Wrap.EIsAlive(myHero) then return false end

	if NPC.IsSilenced(myHero) then return false end 
	if NPC.IsStunned(myHero) then return false end
	if NPC.HasModifier(myHero, "modifier_bashed") then return false end
	if NPC.HasState(myHero, Enum.ModifierState.MODIFIER_STATE_INVULNERABLE) then return false end	
	if NPC.HasModifier(myHero, "modifier_eul_cyclone") then return false end
	if NPC.HasModifier(myHero, "modifier_obsidian_destroyer_astral_imprisonment_prison") then return false end
	if NPC.HasModifier(myHero, "modifier_shadow_demon_disruption") then return false end	
	if NPC.HasModifier(myHero, "modifier_invoker_tornado") then return false end
	if NPC.HasState(myHero, Enum.ModifierState.MODIFIER_STATE_HEXED) then return false end
	if NPC.HasModifier(myHero, "modifier_legion_commander_duel") then return false end
	if NPC.HasModifier(myHero, "modifier_axe_berserkers_call") then return false end
	if NPC.HasModifier(myHero, "modifier_winter_wyvern_winters_curse") then return false end
	if NPC.HasModifier(myHero, "modifier_bane_fiends_grip") then return false end
	if NPC.HasModifier(myHero, "modifier_bane_nightmare") then return false end
	if NPC.HasModifier(myHero, "modifier_faceless_void_chronosphere_freeze") then return false end
	if NPC.HasModifier(myHero, "modifier_enigma_black_hole_pull") then return false end
	if NPC.HasModifier(myHero, "modifier_magnataur_reverse_polarity") then return false end
	if NPC.HasModifier(myHero, "modifier_pudge_dismember") then return false end
	if NPC.HasModifier(myHero, "modifier_shadow_shaman_shackles") then return false end
	if NPC.HasModifier(myHero, "modifier_techies_stasis_trap_stunned") then return false end
	if NPC.HasModifier(myHero, "modifier_storm_spirit_electric_vortex_pull") then return false end
	if NPC.HasModifier(myHero, "modifier_tidehunter_ravage") then return false end
	if NPC.HasModifier(myHero, "modifier_windrunner_shackle_shot") then return false end
	if NPC.HasModifier(myHero, "modifier_item_nullifier_mute") then return false end

	if enemy then
		if NPC.HasModifier(enemy, "modifier_item_aeon_disk_buff") then return false end
	end

	return true	

end

function FAIO.heroCanCastItems(myHero)

	if not myHero then return false end
	if not Wrap.EIsAlive(myHero) then return false end

	if NPC.IsStunned(myHero) then return false end
	if NPC.HasModifier(myHero, "modifier_bashed") then return false end
	if NPC.HasState(myHero, Enum.ModifierState.MODIFIER_STATE_INVULNERABLE) then return false end	
	if NPC.HasModifier(myHero, "modifier_eul_cyclone") then return false end
	if NPC.HasModifier(myHero, "modifier_obsidian_destroyer_astral_imprisonment_prison") then return false end
	if NPC.HasModifier(myHero, "modifier_shadow_demon_disruption") then return false end	
	if NPC.HasModifier(myHero, "modifier_invoker_tornado") then return false end
	if NPC.HasState(myHero, Enum.ModifierState.MODIFIER_STATE_HEXED) then return false end
	if NPC.HasModifier(myHero, "modifier_legion_commander_duel") then return false end
	if NPC.HasModifier(myHero, "modifier_axe_berserkers_call") then return false end
	if NPC.HasModifier(myHero, "modifier_winter_wyvern_winters_curse") then return false end
	if NPC.HasModifier(myHero, "modifier_bane_fiends_grip") then return false end
	if NPC.HasModifier(myHero, "modifier_bane_nightmare") then return false end
	if NPC.HasModifier(myHero, "modifier_faceless_void_chronosphere_freeze") then return false end
	if NPC.HasModifier(myHero, "modifier_enigma_black_hole_pull") then return false end
	if NPC.HasModifier(myHero, "modifier_magnataur_reverse_polarity") then return false end
	if NPC.HasModifier(myHero, "modifier_pudge_dismember") then return false end
	if NPC.HasModifier(myHero, "modifier_shadow_shaman_shackles") then return false end
	if NPC.HasModifier(myHero, "modifier_techies_stasis_trap_stunned") then return false end
	if NPC.HasModifier(myHero, "modifier_storm_spirit_electric_vortex_pull") then return false end
	if NPC.HasModifier(myHero, "modifier_tidehunter_ravage") then return false end
	if NPC.HasModifier(myHero, "modifier_windrunner_shackle_shot") then return false end
	if NPC.HasModifier(myHero, "modifier_item_nullifier_mute") then return false end

	return true	

end

function FAIO.isHeroChannelling(myHero)

	if not myHero then return true end

	if NPC.IsChannellingAbility(myHero) then return true end
	if NPC.HasModifier(myHero, "modifier_teleporting") then return true end

	return false

end

function FAIO.shouldCastBKB(myHero)

	if not myHero then return end

	local dangerousRangeTable = {
		alchemist_unstable_concoction_throw = 775,
		beastmaster_primal_roar = 600,
		centaur_hoof_stomp = 315,
		chaos_knight_chaos_bolt = 500,
		crystal_maiden_frostbite = 525,
		dragon_knight_dragon_tail = 400,
		drow_ranger_wave_of_silence = 900,
		earth_spirit_boulder_smash = 300,
		earthshaker_fissure = 1400,
		ember_spirit_searing_chains = 400,
		invoker_tornado = 1000,
		jakiro_ice_path = 1200,
		lion_impale = 500,
		lion_voodoo = 500,
		naga_siren_ensnare = 650,
		nyx_assassin_impale = 700,
		puck_dream_coil = 750,
		rubick_telekinesis = 625,
		sandking_burrowstrike = 650,
		shadow_shaman_shackles = 400,
		shadow_shaman_voodoo = 500,
		skeleton_king_hellfire_blast = 525,
		slardar_slithereen_crush = 400,
		storm_spirit_electric_vortex = 400,
		sven_storm_bolt = 600,
		tidehunter_ravage = 1025,
		tiny_avalanche = 600,
		vengefulspirit_magic_missile = 500,
		warlock_rain_of_chaos = 1200,
		windrunner_shackleshot = 800,
		slark_pounce = 700,
		ogre_magi_fireblast = 475,
		meepo_poof = 400
			}

	local enemyTable = {}
	local enemiesAround = Wrap.HeroesInRadius(myHero, Menu.GetValue(FAIO.optionDefensiveItemsBKBRadius), Enum.TeamType.TEAM_ENEMY)
		for _, enemy in ipairs(enemiesAround) do
			if enemy then
				if not Entity.IsDormant(enemy) and not NPC.IsIllusion(enemy) and not NPC.IsStunned(enemy) and not NPC.IsSilenced(enemy) then
					table.insert(enemyTable, enemy)
				end
			end
		end

	if next(enemyTable) == nil then return false end

	local tempTable = {}
	for i = 1, #FAIO.preemptiveBKBtable do
		if Menu.IsEnabled(FAIO.preemptiveBKB[i]) then
			table.insert(tempTable, FAIO.preemptiveBKBtable[i])
		end
	end

	if next(tempTable) == nil then return false end

	local searchAbility
	for _, enemy in ipairs(enemyTable) do
		for _, ability in ipairs(tempTable) do
			if NPC.HasAbility(enemy, ability) then
				if NPC.GetAbility(enemy, ability) ~= nil and Ability.IsReady(NPC.GetAbility(enemy, ability)) then
					if Ability.GetLevel(NPC.GetAbility(enemy, ability)) > 0 and Ability.GetCooldownTimeLeft(NPC.GetAbility(enemy, ability)) < 1 and not Ability.IsHidden(NPC.GetAbility(enemy, ability)) then
						if dangerousRangeTable[ability] > (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() then
							searchAbility = ability
							break
						end
					end
				end
			end
		end
	end

	if searchAbility ~= nil and #enemyTable >= Menu.GetValue(FAIO.optionDefensiveItemsBKBEnemies) then
		return true
	end

	return false

end

function FAIO.shouldCastSatanic(myHero, enemy)

	if not myHero then return end
	if not enemy then return false end
	if Entity.GetHealth(myHero) > Entity.GetMaxHealth(myHero) * 0.3 then return false end

	if enemy then
		if NPC.IsAttacking(myHero) and Entity.GetHealth(enemy) >= Entity.GetMaxHealth(enemy) * 0.25 then
			return true
		end
	end

	return false

end

-- hero functions
function FAIO.axeCombo(myHero, enemy)

	if not Menu.IsEnabled(FAIO.optionHeroAxe) then return end
	if not NPC.IsEntityInRange(myHero, enemy, 3000)	then return end

	local call = NPC.GetAbilityByIndex(myHero, 0)
	local hunger = NPC.GetAbilityByIndex(myHero, 1)
	local culling = NPC.GetAbility(myHero, "axe_culling_blade")

	local blademail = NPC.GetItem(myHero, "item_blade_mail", true)
	local blink = NPC.GetItem(myHero, "item_blink", true)
	local myMana = NPC.GetMana(myHero)

	local callRange = 300
		if NPC.HasAbility(myHero, "special_bonus_unique_axe_2") then
			if Ability.GetLevel(NPC.GetAbility(myHero, "special_bonus_unique_axe_2")) > 0 then
				callRange = 400
			end
		end
		if NPC.IsRunning(enemy) then
			if not blink then
				callRange = callRange - 100
			else
				if Ability.SecondsSinceLastUse(blink) > 0.75 then
					callRange = callRange - 100
				end
			end	
		end	

	if Menu.IsEnabled(FAIO.optionHeroAxeCulling) then
		if culling and Ability.IsCastable(culling, myMana) and FAIO.isHeroChannelling(myHero) == false and FAIO.IsHeroInvisible(myHero) == false then
			local cullingEnemy = Wrap.HeroesInRadius(myHero, 150 + NPC.GetCastRangeBonus(myHero), Enum.TeamType.TEAM_ENEMY)
			for i, v in ipairs(cullingEnemy) do
				if v then
					if not Entity.IsDormant(v) and not NPC.IsIllusion(v) and Wrap.EIsAlive(v) then
						if Entity.GetHealth(v) + NPC.GetHealthRegen(v) < Ability.GetLevelSpecialValueFor(culling, "kill_threshold") and not NPC.IsLinkensProtected(v) then
							Ability.CastTarget(culling, v)
							break
						end
					end
				end
			end
		end
	end

	local cursorCheck
	if Menu.IsEnabled(FAIO.optionHeroAxeForceBlink) then
		if NPC.IsPositionInRange(enemy, Input.GetWorldCursorPos(), Menu.GetValue(FAIO.optionHeroAxeForceBlinkRange)-1, 0) then
			cursorCheck = true
		else
			cursorCheck = false
		end
	else
		cursorCheck = true
	end
	
	FAIO.itemUsage(myHero, enemy)
	
	if Menu.IsKeyDown(FAIO.optionComboKey) and Entity.GetHealth(enemy) > 0 and cursorCheck then
		if FAIO.heroCanCastSpells(myHero, enemy) == true then
			if not NPC.IsEntityInRange(myHero, enemy, callRange) then
				if blink and Ability.IsReady(blink) then
					if NPC.IsEntityInRange(myHero, enemy, 1150) then
						if Menu.GetValue(FAIO.optionHeroAxeJump) == 0 then
							Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy))
							return
						else
							local bestPos = FAIO.getBestPosition(Wrap.HInRadius(Entity.GetAbsOrigin(enemy), callRange * 2, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY), callRange)
							if bestPos ~= nil then
								Ability.CastPosition(blink, bestPos)
								return
							end
						end
					end
				end
			end

			if os.clock() > FAIO.lastTick then

				if culling and Ability.IsCastable(culling, myMana) and NPC.IsEntityInRange(myHero, enemy, 150) then
					if Entity.GetHealth(enemy) + NPC.GetHealthRegen(enemy) < Ability.GetLevelSpecialValueFor(culling, "kill_threshold") and not NPC.IsLinkensProtected(enemy) then 
						Ability.CastTarget(culling, enemy)
						FAIO.lastTick = os.clock() + 0.3 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)
						return 
					end
				end

				if call and Ability.IsCastable(call, myMana) and NPC.IsEntityInRange(myHero, enemy, callRange) then 
					Ability.CastNoTarget(call)
					FAIO.lastTick = os.clock() + 0.4 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)
					return
				end

				if blademail and Ability.IsCastable(blademail, myMana) and NPC.HasModifier(enemy, "modifier_axe_berserkers_call") then 
					Ability.CastNoTarget(blademail)
					FAIO.lastTick = os.clock() + 0.05 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)
					return
				end

				if hunger and Ability.IsCastable(hunger, myMana - 120) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(hunger)) and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then 
					Ability.CastTarget(hunger, enemy)
					FAIO.lastTick = os.clock() + 0.3 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)
					return
				end
			end
		end

	FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	return
	end

end

function FAIO.centaurCombo(myHero, enemy)

	if not Menu.IsEnabled(FAIO.optionHeroCentaur) then return end
	if not NPC.IsEntityInRange(myHero, enemy, 3000)	then return end

	local hoofStomp = NPC.GetAbilityByIndex(myHero, 0)
	local doubleEdge = NPC.GetAbilityByIndex(myHero, 1)

	local blademail = NPC.GetItem(myHero, "item_blade_mail", true)
	local blink = NPC.GetItem(myHero, "item_blink", true)
	local myMana = NPC.GetMana(myHero)

	local cursorCheck
	if Menu.IsEnabled(FAIO.optionHeroCentaurForceBlink) then
		if NPC.IsPositionInRange(enemy, Input.GetWorldCursorPos(), Menu.GetValue(FAIO.optionHeroCentaurForceBlinkRange)-1, 0) then
			cursorCheck = true
		else
			cursorCheck = false
		end
	else
		cursorCheck = true
	end
	
	FAIO.itemUsage(myHero, enemy)

	local stunRange = 315
		if NPC.IsRunning(enemy) then
			if not blink then
				stunRange = 175
			else
				if Ability.SecondsSinceLastUse(blink) > 0.75 then
					stunRange = 175
				end
			end
		end	
	
	if Menu.IsKeyDown(FAIO.optionComboKey) and Entity.GetHealth(enemy) > 0 and cursorCheck then
		if FAIO.heroCanCastSpells(myHero, enemy) == true then
			if not NPC.IsEntityInRange(myHero, enemy, stunRange) then
				if blink and Ability.IsReady(blink) then
					if NPC.IsEntityInRange(myHero, enemy, 1150) then
						if Menu.GetValue(FAIO.optionHeroCentaurJump) == 0 then
							Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy))
							return
						else
							local bestPos = FAIO.getBestPosition(Wrap.HInRadius(Entity.GetAbsOrigin(enemy), stunRange * 2, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY), stunRange)
							if bestPos ~= nil then
								Ability.CastPosition(blink, bestPos)
								return
							end
						end
					end
				end
			end

			if os.clock() > FAIO.lastTick then
			
				if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then

					if hoofStomp and Ability.IsCastable(hoofStomp, myMana) and NPC.IsEntityInRange(myHero, enemy, stunRange) then 
						Ability.CastNoTarget(hoofStomp)
						FAIO.lastTick = os.clock() + 0.5 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) 
						return
					end

					if blademail and Ability.IsCastable(blademail, myMana) and NPC.HasModifier(enemy, "modifier_stunned") then 
						Ability.CastNoTarget(blademail)
						FAIO.lastTick = os.clock() + 0.05 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)
						return
					end

					if doubleEdge and Ability.IsCastable(doubleEdge, myMana) and NPC.IsEntityInRange(myHero, enemy, 150) and not NPC.IsLinkensProtected(enemy) then 
						Ability.CastTarget(doubleEdge, enemy)
						FAIO.lastTick = os.clock() + 0.5 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)
						return
					end
				end
			end
		end

	FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	return
	end

end

function FAIO.PudgeCombo(myHero, enemy)

	if not Menu.IsEnabled(FAIO.optionHeroPudge) then return end

	local Q = NPC.GetAbilityByIndex(myHero, 0)
 	local W = NPC.GetAbilityByIndex(myHero, 1)
	local ult = NPC.GetAbility(myHero, "pudge_dismember")

	local blink = NPC.GetItem(myHero, "item_blink", true)
	local force = NPC.GetItem(myHero, "item_force_staff", true)

	local myMana = NPC.GetMana(myHero)

	FAIO.itemUsage(myHero, enemy)
	FAIO.PudgeHookTargetIndicatorDel(myHero)

	local maxInitRange = 0
		if blink and Ability.IsReady(blink) and Menu.IsEnabled(FAIO.optionHeroPudgeBlink) then
			maxInitRange = maxInitRange + 1200
		end
		if force and Ability.IsCastable(force, myMana) and Menu.IsEnabled(FAIO.optionHeroPudgeStaff) then
			maxInitRange = maxInitRange + 600
		end
		if enemy then
			if NPC.HasModifier(enemy, "modifier_pudge_meat_hook") then
				maxInitRange = 0
			end
		end
		if Q and Ability.SecondsSinceLastUse(Q) > -1 and Ability.SecondsSinceLastUse(Q) < 0.5 then
			maxInitRange = 0
		end

	if FAIO.PudgeRotComboActivation and not Menu.IsKeyDown(FAIO.optionComboKey) then
		if Ability.GetToggleState(W) then
			local checkEnemies = false
				for i, v in ipairs(Wrap.HeroesInRadius(myHero, 250, Enum.TeamType.TEAM_ENEMY)) do
					if v and Entity.IsHero(v) and Wrap.EIsAlive(v) and not NPC.IsIllusion(v) then
						checkEnemies = true
						break
					end
				end

				if Entity.GetHealth(myHero) / Entity.GetMaxHealth(myHero) < 0.2 then
					checkEnemies = false
				end

			if not checkEnemies then		
				if os.clock() > FAIO.PudgeRotComboDeactivation then
					Ability.Toggle(W)
					FAIO.PudgeRotComboActivation = false
					FAIO.PudgeRotComboDeactivation = os.clock() + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetAvgLatency(Enum.Flow.FLOW_INCOMING) + 0.05
					return
				end
			end
		end
	end

	if Menu.IsEnabled(FAIO.optionHeroPudgeHook) then
		if Menu.IsKeyDown(FAIO.optionHeroPudgeHookKey) then
			local target = FAIO.PudgeHookGetTarget(myHero)
			if FAIO.PudgeHookTarget == nil then
				FAIO.PudgeHookTarget = target
			end
			if FAIO.PudgeHookTarget ~= nil then
				if Entity.IsHero(FAIO.PudgeHookTarget) and Wrap.EIsAlive(FAIO.PudgeHookTarget) then
					FAIO.PudgeHookCombo(myHero, myMana, FAIO.PudgeHookTarget, Q, W, ult)
				else
					FAIO.PudgeHookTarget = nil
				end	
			end
		else
			if FAIO.PudgeHookTarget ~= nil then
				FAIO.PudgeHookTarget = nil
			end
		end
	end					

	if enemy and NPC.IsEntityInRange(myHero, enemy, 3000) then
		if Menu.IsKeyDown(FAIO.optionComboKey) and Wrap.EIsAlive(enemy) then
 			if FAIO.heroCanCastSpells(myHero, enemy) == true then
				if maxInitRange > 1200 then
					if not NPC.IsEntityInRange(myHero, enemy, 1200) then
						if NPC.IsEntityInRange(myHero, enemy, 1750) then
							local pred = 600/1500 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
							local predPos = FAIO.castPrediction(myHero, enemy, pred)
							if FAIO.AmIFacingPos(myHero, predPos, 10) then
								Ability.CastTarget(force, myHero)
								return
							else
								FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, predPos)
								return
							end
						end
					else
						if not NPC.IsEntityInRange(myHero, enemy, Menu.GetValue(FAIO.optionHeroPudgeBlinkMinRange)) then
							if not NPC.HasModifier(myHero, "modifier_item_forcestaff_active") then
								Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(75)))
								FAIO.lastTick = os.clock() + NetChannel.GetAvgLatency(Enum.Flow.FLOW_INCOMING)
								return
							end
						end
					end
				end
				if maxInitRange == 1200 then
					if NPC.IsEntityInRange(myHero, enemy, 1200) then
						if not NPC.IsEntityInRange(myHero, enemy, Menu.GetValue(FAIO.optionHeroPudgeBlinkMinRange)) then
							if not NPC.HasModifier(myHero, "modifier_item_forcestaff_active") then
								Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(75)))
								FAIO.lastTick = os.clock() + NetChannel.GetAvgLatency(Enum.Flow.FLOW_INCOMING)
								return
							end
						end
					end
				end
				if maxInitRange == 600 then
					if NPC.IsEntityInRange(myHero, enemy, 725) then
						if not NPC.IsEntityInRange(myHero, enemy, 550) then
							local pred = 600/1500 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
							local predPos = FAIO.castPrediction(myHero, enemy, pred)
							if FAIO.AmIFacingPos(myHero, predPos, 5) then
								Ability.CastTarget(force, myHero)
								FAIO.lastTick = os.clock() + 600/1500 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)
								return
							else
								FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, predPos)
								return
							end
						end
					end
				end

				if FAIO.PudgeHookCanceller(myHero, enemy) then
					Player.HoldPosition(Players.GetLocal(), myHero, false)
					FAIO.PudgeHookStartTimer = 0
					FAIO.lastTick = 0
					FAIO.PudgeHookTargetedPos = nil
					return
				end	

				if W and Ability.IsReady(W) and NPC.IsEntityInRange(myHero, enemy, 245) and not Ability.GetToggleState(W) then
					if os.clock() > FAIO.PudgeHookRotDelayer then	
						Ability.Toggle(W)
						FAIO.PudgeRotComboActivation = true
						FAIO.PudgeHookRotDelayer = os.clock() + 0.2
						return
					end
				end
	
				if os.clock() > FAIO.lastTick then

					if ult and Ability.IsCastable(ult, myMana) then
						if NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(ult)) then
							if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_HEXED) and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_STUNNED) then
								Ability.CastTarget(ult, enemy)
								FAIO.lastTick = os.clock() + 0.5
								return
							end
						end	
					end

					local check = false
						if maxInitRange == 600 then
							if NPC.IsEntityInRange(myHero, enemy, 725) then
								if not NPC.IsEntityInRange(myHero, enemy, 550) then
									check = true
								end
							end
						end
						if ult and Ability.IsCastable(ult, myMana) then
							if force and Ability.SecondsSinceLastUse(force) > -1 and Ability.SecondsSinceLastUse(force) < 1 then
								check = true
							end
							if blink and Ability.SecondsSinceLastUse(blink) > -1 and Ability.SecondsSinceLastUse(blink) < 0.5 then
								check = true
							end
						end

					if Menu.IsEnabled(FAIO.optionHeroPudgeHookCombo) and not check and not NPC.HasModifier(myHero, "modifier_item_forcestaff_active") then
						if Q and Ability.IsCastable(Q, myMana) and NPC.IsEntityInRange(myHero, enemy, Menu.GetValue(FAIO.optionHeroPudgeHookComboMaxRange)) and not NPC.IsChannellingAbility(myHero) then
							if FAIO.PudgeHookCollisionChecker(myHero, enemy) and not FAIO.PudgeHookJukingChecker(myHero, enemy) then
								local hookPrediction = Ability.GetCastPoint(Q) + NPC.GetTimeToFace(myHero, enemy) + (Entity.GetAbsOrigin(enemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1450) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
								local hookPredictedPos = FAIO.castPrediction(myHero, enemy, hookPrediction)
								Ability.CastPosition(Q, Entity.GetAbsOrigin(myHero) + (hookPredictedPos - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(500))
								FAIO.PudgeHookStartTimer = os.clock() + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) + FAIO.TimeToFacePosition(myHero, hookPredictedPos)
								FAIO.PudgeHookTargetedPos = hookPredictedPos
								FAIO.lastTick = os.clock() + 0.3
								return
							end
						end
					end
				end
			end

			local attCheck = false
				if ult and Ability.IsCastable(ult, myMana) then
					if force and Ability.SecondsSinceLastUse(force) > -1 and Ability.SecondsSinceLastUse(force) < 1 then
						check = true
					end
					if blink and Ability.SecondsSinceLastUse(blink) > -1 and Ability.SecondsSinceLastUse(blink) < 0.5 then
						check = true
					end
				end

			if not NPC.HasModifier(enemy, "modifier_pudge_meat_hook") and not attCheck then
				FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
				return
			end
		end
	end

	if Menu.IsEnabled(FAIO.optionHeroPudgeFarm) then
		FAIO.PudgeAutoFarm(myHero, myMana, W)
	end

	if Menu.IsEnabled(FAIO.optionHeroPudgeSuicide) then
		FAIO.PudgeAutoSuicide(myHero, myMana, W)
	end

	return

end

function FAIO.PudgeAutoSuicide(myHero, myMana, rot)

	if not myHero then return end
	if not rot then return end

	if FAIO.heroCanCastItems(myHero) == false then return end
	if FAIO.isHeroChannelling(myHero) == true then return end
	if FAIO.IsHeroInvisible(myHero) == true then return end

	if os.clock() < FAIO.PudgeRotFarmToggledTime then return end

	if NPC.HasItem(myHero, "item_armlet", true) then return end

	local rotDamage = Ability.GetLevelSpecialValueFor(rot, "rot_damage")
		if NPC.HasAbility(myHero, "special_bonus_unique_pudge_2") then
			if Ability.GetLevel(NPC.GetAbility(myHero, "special_bonus_unique_pudge_2")) > 0 then
				rotDamage = rotDamage + 35
			end
		end

	rotDamage = ((1 - NPC.GetMagicalArmorValue(myHero)) * rotDamage + rotDamage * (Hero.GetIntellectTotal(myHero) / 14 / 100)) / 4

	local soulRing = NPC.GetItem(myHero, "item_soul_ring", true)
		if soulRing and Ability.IsReady(soulRing) and FAIO.heroCanCastItems(myHero) then
			rotDamage = rotDamage + 150
		end

	local myHP = Entity.GetHealth(myHero)

	if myHP <= rotDamage then
		for _, v in ipairs(Wrap.HeroesInRadius(myHero, 800, Enum.TeamType.TEAM_ENEMY)) do
			if v and Entity.IsHero(v) and not Entity.IsDormant(v) and not NPC.IsIllusion(v) then
				if NPC.IsAttacking(v) then
					if NPC.IsEntityInRange(myHero, v, NPC.GetAttackRange(v) + 140) then
						if NPC.FindFacingNPC(v) == myHero then
							if soulRing and Ability.IsReady(soulRing) and FAIO.heroCanCastItems(myHero) then
								Ability.CastNoTarget(soulRing)
								if not Ability.GetToggleState(rot) then
									Ability.Toggle(rot)
								end
								FAIO.PudgeRotFarmToggledTime = os.clock() + 0.2 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)
								break
								return
							else
								if not Ability.GetToggleState(rot) then
									Ability.Toggle(rot)
								end
								FAIO.PudgeRotFarmToggledTime = os.clock() + 0.2 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)
								break
								return
							end		
						end
					end
				end
				for ability, info in pairs(FAIO.RawDamageAbilityEstimation) do
					if NPC.HasAbility(v, ability) and Ability.IsInAbilityPhase(NPC.GetAbility(v, ability)) then
						local abilityRange = math.max(Ability.GetCastRange(NPC.GetAbility(v, ability)), info[2])
						local abilityRadius = info[3]
						if FAIO.dodgeIsTargetMe(myHero, v, abilityRadius, abilityRange) then
							if next(FAIO.dodgeItTable) == nil then
								if soulRing and Ability.IsReady(soulRing) and FAIO.heroCanCastItems(myHero) then
									Ability.CastNoTarget(soulRing)
									if not Ability.GetToggleState(rot) then
										Ability.Toggle(rot)
									end
									FAIO.PudgeRotFarmToggledTime = os.clock() + 0.2 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)
									break
									return
								else
									if not Ability.GetToggleState(rot) then
										Ability.Toggle(rot)
									end
									FAIO.PudgeRotFarmToggledTime = os.clock() + 0.2 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)
									break
									return
								end
							end
						end
					end
				end
			end	
		end
	end

	return	

end

function FAIO.PudgeAutoFarm(myHero, myMana, rot)

	if not myHero then return end
	if not rot then return end

	if FAIO.heroCanCastItems(myHero) == false then return end
	if FAIO.isHeroChannelling(myHero) == true then return end
	if FAIO.IsHeroInvisible(myHero) == true then return end

	if os.clock() < FAIO.PudgeRotFarmToggledTime then return end

	if FAIO.PudgeRotFarmToggled and not Ability.GetToggleState(rot) then
		FAIO.PudgeRotFarmToggled = false
		return
	end

	if Entity.GetHealth(myHero) / Entity.GetMaxHealth(myHero) < Menu.GetValue(FAIO.optionHeroPudgeFarmHP) / 100 then
		if Ability.GetToggleState(rot) and FAIO.PudgeRotFarmToggled then
			Ability.Toggle(rot)
			FAIO.PudgeRotFarmToggled = false
			FAIO.PudgeRotFarmToggledTime = os.clock() + 0.2 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)
			return
		else
			return
		end
	end

	local rotDamage = Ability.GetLevelSpecialValueFor(rot, "rot_damage")
		if NPC.HasAbility(myHero, "special_bonus_unique_pudge_2") then
			if Ability.GetLevel(NPC.GetAbility(myHero, "special_bonus_unique_pudge_2")) > 0 then
				rotDamage = rotDamage + 35
			end
		end

	if #Wrap.UnitsInRadius(myHero, 240, Enum.TeamType.TEAM_ENEMY) < 1 then
		if Ability.GetToggleState(rot) and FAIO.PudgeRotFarmToggled then
			Ability.Toggle(rot)
			FAIO.PudgeRotFarmToggled = false
			FAIO.PudgeRotFarmToggledTime = os.clock() + 0.2 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)
			return
		end
	end	

	
	for _, creeps in ipairs(Wrap.UnitsInRadius(myHero, 240, Enum.TeamType.TEAM_ENEMY)) do
		if creeps and Wrap.EIsNPC(creeps) and not Entity.IsHero(creeps) and Wrap.EIsAlive(creeps) and not Entity.IsDormant(creeps) and not NPC.IsWaitingToSpawn(creeps) and NPC.GetUnitName(creeps) ~= "npc_dota_neutral_caster" and NPC.IsCreep(creeps) and NPC.GetUnitName(creeps) ~= nil and NPC.IsKillable(creeps) then
			local rotTrueDamage = ((1 - NPC.GetMagicalArmorValue(creeps)) * rotDamage + rotDamage * (Hero.GetIntellectTotal(myHero) / 14 / 100)) / 4
			if Entity.GetHealth(creeps) < rotTrueDamage then
				if not Ability.GetToggleState(rot) then
					Ability.Toggle(rot)
					FAIO.PudgeRotFarmToggled = true
					FAIO.PudgeRotFarmToggledTime = os.clock() + 0.2 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)
					return
				end
			else
				if Ability.GetToggleState(rot) and FAIO.PudgeRotFarmToggled then
					Ability.Toggle(rot)
					FAIO.PudgeRotFarmToggled = false
					FAIO.PudgeRotFarmToggledTime = os.clock() + 0.2 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)
					return
				end
			end
		else
			if Ability.GetToggleState(rot) and FAIO.PudgeRotFarmToggled then
				Ability.Toggle(rot)
				FAIO.PudgeRotFarmToggled = false
				FAIO.PudgeRotFarmToggledTime = os.clock() + 0.2 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)
				return
			end
		end
	end
	
	return
		
end

function FAIO.PudgeHookCombo(myHero, myMana, npc, hook, rot, ult)

	if not myHero then return end
	if not npc then return end

	if not hook then return end
		if Ability.GetLevel(hook) < 1 then return end

	FAIO.PudgeHookTargetIndicator(myHero, npc)
	FAIO.PudgeHookHitTracker(myHero, hook)

	if not Entity.IsSameTeam(myHero, npc) then
		if ult and Ability.IsCastable(ult, myMana) and Menu.IsEnabled(FAIO.optionHeroPudgeHookUlt) then
			if not NPC.HasState(npc, Enum.ModifierState.MODIFIER_STATE_HEXED) and not NPC.HasState(npc, Enum.ModifierState.MODIFIER_STATE_STUNNED) then
				if os.clock() > FAIO.PudgeHookDelayer then
					if NPC.IsEntityInRange(myHero, FAIO.PudgeHookTarget, Ability.GetCastRange(ult)) then
						Ability.CastTarget(ult, FAIO.PudgeHookTarget)
						FAIO.PudgeHookDelayer = os.clock() + 0.3
						return
					end
				end
			end
		end

		if rot and Ability.IsReady(rot) and NPC.IsEntityInRange(myHero, FAIO.PudgeHookTarget, 250) and not Ability.GetToggleState(rot) and Menu.IsEnabled(FAIO.optionHeroPudgeHookRot) then
			if os.clock() > FAIO.PudgeHookRotDelayer then
				Ability.Toggle(rot)
				FAIO.PudgeHookRotDelayer = os.clock() + 0.25
				return
			end
		end

		if FAIO.PudgeHookHit then
			if Menu.IsEnabled(FAIO.optionHeroPudgeHookItems) then
				FAIO.itemUsageSmartOrder(myHero, npc, true)
			end
			if not NPC.HasModifier(npc, "modifier_pudge_meat_hook") then
				FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", npc, nil)
			end
		end	
	end

	local hookRange = Ability.GetCastRange(hook)
	local pred = Ability.GetCastPoint(hook) + NPC.GetTimeToFace(myHero, npc) + (Entity.GetAbsOrigin(npc):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1450) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
	local predPos = FAIO.castPrediction(myHero, npc, pred)

	if not NPC.IsPositionInRange(myHero, predPos, hookRange + 100, 20) then return end

	local atos = NPC.GetItem(myHero, "item_rod_of_atos", true)

	if hook and Ability.IsCastable(hook, myMana) and not NPC.IsChannellingAbility(myHero) then

		if FAIO.PudgeHookCanceller(myHero, npc) then
			Player.HoldPosition(Players.GetLocal(), myHero, false)
			FAIO.PudgeHookTarget = nil
			FAIO.PudgeHookStartTimer = 0
			FAIO.PudgeHookDelayer = 0
			FAIO.PudgeHookTargetedPos = nil
			return
		end
			
		if os.clock() > FAIO.PudgeHookDelayer then
			if not FAIO.PudgeHookJukingChecker(myHero, npc) then
				if FAIO.PudgeHookCollisionChecker(myHero, npc) then
					if FAIO.PudgeHookTiming(myHero, npc) > 0 then
						local modTiming = FAIO.PudgeHookTiming(myHero, npc) + 0.1
						local hookTiming = Ability.GetCastPoint(hook) + NPC.GetTimeToFace(myHero, npc) + ((Entity.GetAbsOrigin(npc):__sub(Entity.GetAbsOrigin(myHero)):Length2D() - 125) / 1450) + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)
						if GameRules.GetGameTime() > modTiming - hookTiming then
							Ability.CastPosition(hook, Entity.GetAbsOrigin(myHero) + (predPos - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(500))
							FAIO.PudgeHookStartTimer = os.clock() + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) + FAIO.TimeToFacePosition(myHero, predPos)
							FAIO.PudgeHookDelayer = os.clock() + 0.35 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) + FAIO.TimeToFacePosition(myHero, predPos)
							return	
						end
					else
						if atos and Ability.IsCastable(atos, myMana) and NPC.IsEntityInRange(myHero, npc, 1150) and not NPC.HasState(npc, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and not NPC.IsLinkensProtected(npc) then
							Ability.CastTarget(atos, npc)
							FAIO.PudgeHookTarget = npc
							return
						else
							if atos and Ability.SecondsSinceLastUse(atos) > -1 and Ability.SecondsSinceLastUse(atos) < ((Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(npc)):Length2D() / 1500) + 0.55 then
								local atosTiming = GameRules.GetGameTime() - math.max(Ability.SecondsSinceLastUse(atos), 0) + ((Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(npc)):Length2D() / 1500) + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) - 0.1
								if GameRules.GetGameTime() >= atosTiming then
									Ability.CastPosition(hook, Entity.GetAbsOrigin(npc))
									FAIO.PudgeHookStartTimer = os.clock() + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) + FAIO.TimeToFacePosition(myHero, predPos)
									FAIO.PudgeHookDelayer = os.clock() + 0.35 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) + FAIO.TimeToFacePosition(myHero, predPos)
									return
								end	
							else
								Ability.CastPosition(hook, Entity.GetAbsOrigin(myHero) + (predPos - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(500))
								FAIO.PudgeHookStartTimer = os.clock() + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) + FAIO.TimeToFacePosition(myHero, predPos)
								FAIO.PudgeHookDelayer = os.clock() + 0.35 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) + FAIO.TimeToFacePosition(myHero, predPos)
								FAIO.PudgeHookTargetedPos = predPos
								return
							end
						end
					end
				else
					if FAIO.PudgeHookForceStaffFun(myHero, myMana, npc, hook) then
						local targetRotation = Entity.GetRotation(npc):GetForward()
						local targetForcedPos = Entity.GetAbsOrigin(npc) + targetRotation:Normalized():Scaled(600)
						Ability.CastTarget(NPC.GetItem(myHero, "item_force_staff", true), npc)
						FAIO.PudgeHookTarget = npc
						Ability.CastPosition(hook, Entity.GetAbsOrigin(myHero) + (targetForcedPos - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(500), true)
						FAIO.PudgeHookStartTimer = os.clock() + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) + FAIO.TimeToFacePosition(myHero, targetForcedPos)
						FAIO.PudgeHookDelayer = os.clock() + 0.35 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) + FAIO.TimeToFacePosition(myHero, targetForcedPos)
						return	
					end
				end
							
			end
		end

	end

end

function FAIO.PudgeHookCollisionChecker(myHero, target)

	if not myHero then return false end
	if not target then return false end

	local pred = 0.3 + NPC.GetTimeToFace(myHero, target) + (Entity.GetAbsOrigin(target):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1450) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
	local predPos = FAIO.castPrediction(myHero, target, pred)

	local searchRadius = 125
	local distance = (Entity.GetAbsOrigin(myHero) - predPos):Length2D()

	for i = 1, math.floor(distance / searchRadius) do
		local checkVec = (predPos - Entity.GetAbsOrigin(myHero)):Normalized()
		local checkPos = Entity.GetAbsOrigin(myHero) + checkVec:Scaled(i * searchRadius)
		local unitsAround = Wrap.NInRadius(checkPos, searchRadius, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_BOTH)
		local check = false
			for _, unit in ipairs(unitsAround) do
				if unit and Wrap.EIsNPC(unit) and unit ~= target and unit ~= myHero and Wrap.EIsAlive(unit) and not Entity.IsDormant(unit) and not NPC.IsStructure(unit) and not NPC.IsBarracks(unit) and not NPC.IsWaitingToSpawn(unit) and NPC.GetUnitName(unit) ~= "npc_dota_neutral_caster" and NPC.GetUnitName(unit) ~= nil then
					check = true
					break
				end
			end

		if check then
			return false
		end	

	end

	return true

end

function FAIO.PudgeHookCanceller(myHero, target)

	if not myHero then return false end
	if not target then return false end

	local hook = NPC.GetAbilityByIndex(myHero, 0)
		if not hook then return false end
			if Ability.GetLevel(hook) < 1 then return false end

	local hookRange = Ability.GetCastRange(hook)

	if FAIO.PudgeHookTargetedPos == nil then return false end

	if os.clock() > FAIO.PudgeHookStartTimer + 0.3 then return false end
	if os.clock() < FAIO.PudgeHookStartTimer + 0.1 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) then return false end

	local timePassed = math.min(os.clock() - FAIO.PudgeHookStartTimer, 0.3)

	local pred = (0.3 - timePassed) + (Entity.GetAbsOrigin(target):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1450) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
	local predPos = FAIO.castPrediction(myHero, target, pred)
	
	if (predPos - Entity.GetAbsOrigin(myHero)):Length2D() > hookRange + 100 then return true end

	local searchRadius = 120
	local distance = (Entity.GetAbsOrigin(myHero) - predPos):Length2D()

	local check = false
		for i = 1, math.ceil(distance / searchRadius) do
			local checkVec = (FAIO.PudgeHookTargetedPos - Entity.GetAbsOrigin(myHero)):Normalized()
			local checkPos = Entity.GetAbsOrigin(myHero) + checkVec:Scaled(i * searchRadius)
			if (checkPos - predPos):Length2D() < searchRadius then
				check = true
				break
			end
		end

	if not check then
		return true
	end

	return false

end

function FAIO.PudgeHookJukingChecker(myHero, target)

	if not myHero then return false end
	if not target then return false end

	if not NPC.IsRunning(target) then return false end

	local turning = NPC.IsTurning(target)

	if NPC.IsRunning(target) then
		if NPC.IsRunning(target) then
			table.insert(FAIO.rotationTable, turning)
			if #FAIO.rotationTable > Menu.GetValue(FAIO.optionHeroPudgeHookJuke) then
				table.remove(FAIO.rotationTable, 1)
			end
		end
	end

	if #FAIO.rotationTable < Menu.GetValue(FAIO.optionHeroPudgeHookJuke) then 
		return true
	else
		local check = false
		for i = 1, #FAIO.rotationTable do
			if FAIO.rotationTable[i] == true then
				check = true
				break
			end
		end

		if check then
			return true
		end
	end

	return false
 
end

function FAIO.PudgeHookGetTarget(myHero)

	if not myHero then return end

	local targetingRange = Menu.GetValue(FAIO.optionHeroPudgeHookAcquiRange)
	local mousePos = Input.GetWorldCursorPos()

	
	local enemyTable = Wrap.HInRadius(mousePos, targetingRange, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY)
		if Menu.IsEnabled(FAIO.optionHeroPudgeHookAllies) then
			enemyTable = Wrap.HInRadius(mousePos, targetingRange, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_BOTH)
		end
		if #enemyTable < 1 then return end

	local nearestTarget = nil
	local distance = 99999

	for i, v in ipairs(enemyTable) do
		if v and Entity.IsHero(v) and Wrap.EIsAlive(v) and v ~= myHero then
			if FAIO.targetChecker(v) ~= nil then
				local enemyDist = (Entity.GetAbsOrigin(v) - mousePos):Length2D()
				if enemyDist < distance then
					nearestTarget = v
					distance = enemyDist
				end
			end
		end
	end

	return nearestTarget or nil

end

function FAIO.PudgeHookTiming(myHero, target)

	if not myHero then return 0 end
	if not target then return 0 end

	local invulnerabilityList = {
		"modifier_eul_cyclone",
		"modifier_obsidian_destroyer_astral_imprisonment_prison",
		"modifier_shadow_demon_disruption",
		"modifier_invoker_tornado"
			}
	
	local searchMod
	for _, modifier in ipairs(invulnerabilityList) do
		if NPC.HasModifier(target, modifier) then
			searchMod = NPC.GetModifier(target, modifier)
			break
		end
	end

	if not searchMod then return 0 end

	local timing = 0
	if searchMod then
		local dieTime = Modifier.GetDieTime(searchMod)
		timing = dieTime
	end

	return timing

end

function FAIO.PudgeHookHitTracker(myHero, hook)

	if not myHero then return end
	if not hook then return end

	if Ability.SecondsSinceLastUse(hook) == -1 and FAIO.PudgeHookHit then
		FAIO.PudgeHookHit = false
	end

	if FAIO.PudgeHookTarget == nil and FAIO.PudgeHookHit then
		FAIO.PudgeHookHit = false
	end

	if FAIO.PudgeHookTarget then
		if NPC.HasModifier(FAIO.PudgeHookTarget, "modifier_pudge_meat_hook") then
			FAIO.PudgeHookHit = true
		end
	end
	
	return

end

function FAIO.PudgeHookForceStaffFun(myHero, myMana, target, hook)

	if not myHero then return false end
	if not target then return false end
		if NPC.HasState(target, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then return false end

	if not Menu.IsEnabled(FAIO.optionHeroPudgeHookStaff) then return false end
	if not hook then return false end

	if FAIO.heroCanCastSpells(myHero, enemy) == false then return false end
	if FAIO.isHeroChannelling(myHero) == true then return false end 

	if not NPC.IsEntityInRange(myHero, target, 750) then return false end
	if FAIO.PudgeHookJukingChecker(myHero, target) then return false end

	local force = NPC.GetItem(myHero, "item_force_staff", true)
		if not force then return false end
		if not Ability.IsCastable(force, myMana) then return false end

	local targetTurnTime90 = (0.03 * math.pi) / NPC.GetTurnRate(target) / 3.5
	if NPC.GetTimeToFace(target, myHero) > targetTurnTime90 then return false end

	local targetRotation = Entity.GetRotation(target):GetForward()
	local targetForcedPos = Entity.GetAbsOrigin(target) + targetRotation:Normalized():Scaled(600)

	if not FAIO.PudgeHookCollisionCheckerPosition(myHero, targetForcedPos) then return false end
	local hookRange = Ability.GetCastRange(hook)
		if (Entity.GetAbsOrigin(myHero) - targetForcedPos):Length2D() > hookRange then return false end

	return true

end

function FAIO.PudgeHookCollisionCheckerPosition(myHero, pos)

	if not myHero then return false end
	if not pos then return false end

	local searchRadius = 125
	local distance = (Entity.GetAbsOrigin(myHero) - pos):Length2D()

	for i = 1, math.floor(distance / searchRadius) do
		local checkVec = (pos - Entity.GetAbsOrigin(myHero)):Normalized()
		local checkPos = Entity.GetAbsOrigin(myHero) + checkVec:Scaled(i * searchRadius)
		local unitsAround = Wrap.NInRadius(checkPos, searchRadius, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_BOTH)
		local check = false
			for _, unit in ipairs(unitsAround) do
				if unit and Wrap.EIsNPC(unit) and unit ~= target and unit ~= myHero and Wrap.EIsAlive(unit) and not Entity.IsDormant(unit) and not NPC.IsStructure(unit) and not NPC.IsBarracks(unit) and not NPC.IsWaitingToSpawn(unit) and NPC.GetUnitName(unit) ~= "npc_dota_neutral_caster" and NPC.GetUnitName(unit) ~= nil then
					check = true
					break
				end
			end

		if check then
			return false
		end	

	end

	return true

end
			
function FAIO.PudgeHookTargetIndicatorDel(myHero)

	if not myHero then return end

	local curtime = GameRules.GetGameTime()

	if not Menu.IsKeyDown(FAIO.optionHeroPudgeHookKey) or FAIO.PudgeHookTarget == nil then
		if FAIO.PudgecurrentParticle > 0 then
			Particle.Destroy(FAIO.PudgecurrentParticle)			
			FAIO.PudgecurrentParticle = 0
		end
	end

	return

end

function FAIO.PudgeHookTargetIndicator(myHero, target)

	if not myHero then return end
	if not Menu.IsEnabled(FAIO.optionHeroPudgeHook) then return end

	local curtime = GameRules.GetGameTime()
		
	if (not target or target ~= FAIO.PudgecurrentParticleTarget) and FAIO.PudgecurrentParticle > 0 then
		Particle.Destroy(FAIO.PudgecurrentParticle)			
		FAIO.PudgecurrentParticle = 0
		FAIO.PudgecurrentParticleTarget = target
	else
		if FAIO.PudgecurrentParticle == 0 and target then
			local Particle = Particle.Create("particles/ui_mouseactions/range_finder_tower_aoe.vpcf", Enum.ParticleAttachment.PATTACH_INVALID, target)	
			FAIO.PudgecurrentParticle = Particle
			FAIO.PudgecurrentParticleTarget = target			
		end
		if FAIO.PudgecurrentParticle > 0 then
			Particle.SetControlPoint(FAIO.PudgecurrentParticle, 2, Entity.GetOrigin(myHero))
			Particle.SetControlPoint(FAIO.PudgecurrentParticle, 6, Vector(1, 0, 0))
			Particle.SetControlPoint(FAIO.PudgecurrentParticle, 7, Entity.GetOrigin(FAIO.PudgecurrentParticleTarget))
		end
	end

end

function FAIO.OgreCombo(myHero, enemy)

	if not Menu.IsEnabled(FAIO.optionHeroOgre) then return end
	if not  NPC.IsEntityInRange(myHero, enemy, 3000) then return end

  	local Q = NPC.GetAbilityByIndex(myHero, 0)
 	local W = NPC.GetAbilityByIndex(myHero, 1)
 	local S = NPC.GetAbility(myHero, "ogre_magi_unrefined_fireblast")

	local blink = NPC.GetItem(myHero, "item_blink", true)

	local myMana = NPC.GetMana(myHero)

	FAIO.itemUsage(myHero, enemy)

	if Menu.IsKeyDown(FAIO.optionComboKey) and Wrap.EIsAlive(enemy) then
 		if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and FAIO.heroCanCastSpells(myHero, enemy) == true then
			if not NPC.IsEntityInRange(myHero, enemy, 500) then
				if Menu.IsEnabled(FAIO.optionHeroOgreBlink) and blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1150) then
					Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy))
					return
				end
			end	

			if os.clock() > FAIO.lastTick then
		
				if Q and Ability.IsCastable(Q, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(Q)) then
					Ability.CastTarget(Q, enemy)
					FAIO.lastTick = os.clock() + 0.45
					return
				end

				if W and Ability.IsCastable(W, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(W)) then
					Ability.CastTarget(W, enemy)
					FAIO.lastTick = os.clock() + 0.45
					return
				end

				if S and Ability.IsCastable(S, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(S)) then
					Ability.CastTarget(S, enemy)
					FAIO.lastTick = os.clock() + 0.45
					return
				end
			end
		end

		FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
		return
	end

end

function FAIO.VSCombo(myHero, enemy)

	if not Menu.IsEnabled(FAIO.optionHeroVS) then return end
	if not  NPC.IsEntityInRange(myHero, enemy, 3000) then return end

  	local Q = NPC.GetAbilityByIndex(myHero, 0)
 	local W = NPC.GetAbilityByIndex(myHero, 1)

	local blink = NPC.GetItem(myHero, "item_blink", true)

	local myMana = NPC.GetMana(myHero)

	FAIO.itemUsage(myHero, enemy)

	if Menu.IsKeyDown(FAIO.optionComboKey) and Wrap.EIsAlive(enemy) then
 		if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and FAIO.heroCanCastSpells(myHero, enemy) == true then
			if not NPC.IsEntityInRange(myHero, enemy, 999) then
				if Menu.IsEnabled(FAIO.optionHeroVSBlink) and blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1150 + Menu.GetValue(FAIO.optionHeroVSBlinkRange)) then
					Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(Menu.GetValue(FAIO.optionHeroVSBlinkRange))))
					return
				end
			end	

			if os.clock() > FAIO.lastTick then

				if not Menu.IsEnabled(FAIO.optionHeroVSStun) then
		
					if Q and Ability.IsCastable(Q, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(Q)) and not NPC.IsLinkensProtected(enemy) then
						Ability.CastTarget(Q, enemy)
						FAIO.lastTick = os.clock() + 0.35
						return
					end

					if W and Ability.IsCastable(W, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(W)) then
						if not NPC.HasModifier(enemy, "modifier_vengefulspirit_wave_of_terror") then
							local pred = 0.3 + ((Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Length2D() / 2000) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
							Ability.CastPosition(W, FAIO.castPrediction(myHero, enemy, pred))
							FAIO.lastTick = os.clock() + 0.35
							return
						end
					end

				else

					if Q and Ability.IsCastable(Q, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(Q)) and not NPC.IsLinkensProtected(enemy) then
						Ability.CastTarget(Q, enemy)
						FAIO.lastTick = os.clock() + 0.35
						return
					end

					local check = false
						if Q and Ability.IsCastable(Q, myMana) then
							check = true
						end

					if not check then
						if W and Ability.IsCastable(W, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(W)) then
							if not NPC.HasModifier(enemy, "modifier_vengefulspirit_wave_of_terror") then
								local pred = 0.3 + ((Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Length2D() / 2000) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
								local predPos = FAIO.castPrediction(myHero, enemy, pred)
								Ability.CastPosition(W, Entity.GetAbsOrigin(myHero) + (predPos - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(300))
								FAIO.lastTick = os.clock() + 0.35
								return
							end
						end
					end
				end	
			end
		end

		FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
		return
	end

end

function FAIO.AACombo(myHero, enemy)

	if not Menu.IsEnabled(FAIO.optionHeroAA) then return end
	if not  NPC.IsEntityInRange(myHero, enemy, 3000) then return end

  	local Q = NPC.GetAbilityByIndex(myHero, 0)
 	local W = NPC.GetAbilityByIndex(myHero, 1)

	local blink = NPC.GetItem(myHero, "item_blink", true)

	local myMana = NPC.GetMana(myHero)

	FAIO.itemUsage(myHero, enemy)

	if Menu.IsKeyDown(FAIO.optionComboKey) and Wrap.EIsAlive(enemy) then
 		if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and FAIO.heroCanCastSpells(myHero, enemy) == true then
			if not NPC.IsEntityInRange(myHero, enemy, 999) then
				if Menu.IsEnabled(FAIO.optionHeroAABlink) and blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1150 + Menu.GetValue(FAIO.optionHeroAABlinkRange)) then
					Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(Menu.GetValue(FAIO.optionHeroAABlinkRange))))
					return
				end
			end	

			if os.clock() > FAIO.lastTick then
		
				if Q and Ability.IsCastable(Q, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(Q)) then
					Ability.CastTarget(Q, enemy)
					FAIO.lastTick = os.clock() + 0.05
					return
				end

				if W and Ability.IsCastable(W, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(W)) then
					if not NPC.HasModifier(enemy, "modifier_ice_vortex") then
						local pred = 0.87 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
						Ability.CastPosition(W, FAIO.castPrediction(myHero, enemy, pred))
						FAIO.lastTick = os.clock() + 0.05
						return
					end
				end
			end
		end

		FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
		return
	end

end

function FAIO.CMCombo(myHero, enemy)

	if not Menu.IsEnabled(FAIO.optionHeroCM) then return end
	if not  NPC.IsEntityInRange(myHero, enemy, 3000) then return end

  	local Q = NPC.GetAbilityByIndex(myHero, 0)
 	local W = NPC.GetAbilityByIndex(myHero, 1)

	local blink = NPC.GetItem(myHero, "item_blink", true)

	local myMana = NPC.GetMana(myHero)

	FAIO.itemUsage(myHero, enemy)

	if Menu.IsKeyDown(FAIO.optionComboKey) and Wrap.EIsAlive(enemy) then
 		if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and FAIO.heroCanCastSpells(myHero, enemy) == true then
			if not NPC.IsEntityInRange(myHero, enemy, 800) then
				if Menu.IsEnabled(FAIO.optionHeroCMBlink) and blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1150 + Menu.GetValue(FAIO.optionHeroCMBlinkRange)) then
					Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(Menu.GetValue(FAIO.optionHeroCMBlinkRange))))
					return
				end
			end	

			if os.clock() > FAIO.lastTick then

				if W and Ability.IsCastable(W, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(W)) then
					if FAIO.TargetGotDisableModifier(myHero, enemy) == false then
						Ability.CastTarget(W, enemy)
						FAIO.lastTick = os.clock() + 0.3
						return
					end
				end
		
				if Q and Ability.IsCastable(Q, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(Q)) then
					local bestPos = FAIO.getBestPosition(Wrap.HInRadius(Entity.GetAbsOrigin(enemy), 820, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY), 410)
					if bestPos ~= nil then
						Ability.CastPosition(Q, bestPos)
						FAIO.lastTick = os.clock() + 0.3
						return
					end
				end

			end
		end

		FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
		return
	end

	if Menu.IsEnabled(FAIO.optionHeroCMUlt) then
		local ult = NPC.GetAbility(myHero, "crystal_maiden_freezing_field")
		local glimmer = NPC.GetItem(myHero, "item_glimmer_cape", true)
		local bkb = NPC.GetItem(myHero, "item_black_king_bar", true)
			if not ult or (ult and not Ability.IsCastable(ult, myMana)) then return end
			if not blink or (blink and not Ability.IsReady(blink)) then return end
			if os.clock() < FAIO.lastTick then return end

		if Menu.IsKeyDown(FAIO.optionHeroCMUltKey) and Wrap.EIsAlive(enemy) and NPC.IsEntityInRange(myHero, enemy, 1150 + 450) then
 			if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and FAIO.heroCanCastSpells(myHero, enemy) == true then
				local bestPos = FAIO.getBestPosition(Wrap.HInRadius(Entity.GetAbsOrigin(enemy), 1220, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY), 600)
				if bestPos ~= nil and #Wrap.HInRadius(bestPos, 700, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY) >= Menu.GetValue(FAIO.optionHeroCMUltMin) then
					if #Wrap.HInRadius(bestPos, 700, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY) == 1 then
						if NPC.IsPositionInRange(myHero, bestPos, 1150 + 350, 0) then
							if bkb and Ability.IsCastable(bkb, myMana) then
								Ability.CastNoTarget(bkb)
								FAIO.lastTick = os.clock() + 0.05 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)
								return
							end
							if glimmer and Ability.IsCastable(glimmer, myMana) then
								Ability.CastTarget(glimmer, myHero)
								FAIO.lastTick = os.clock() + 0.55 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)
								return
							end
							Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(350)))
							Ability.CastNoTarget(ult, true)
							FAIO.lastTick = os.clock() + 0.5
							return
						else
							FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
							return
						end
					else
						if NPC.IsPositionInRange(myHero, bestPos, 1150, 0) then
							if bkb and Ability.IsCastable(bkb, myMana) then
								Ability.CastNoTarget(bkb)
								FAIO.lastTick = os.clock() + 0.05 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)
								return
							end
							if glimmer and Ability.IsCastable(glimmer, myMana) then
								Ability.CastTarget(glimmer, myHero)
								FAIO.lastTick = os.clock() + 0.55 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)
								return
							end

							local savePos = bestPos
								if #Wrap.HInRadius(savePos, 350, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY) > 0 then
									local myPos = Entity.GetAbsOrigin(myHero)
									local dist = (myPos - savePos):Length2D()
									for k = 1, math.floor(dist/25) do
										local searchPos = savePos + (myPos - savePos):Normalized():Scaled(k*25)
										if #Wrap.HInRadius(searchPos, 350, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY) < 1 then
											savePos = searchPos
											break
										end
									end		
								end

							Ability.CastPosition(blink, savePos)
							Ability.CastNoTarget(ult, true)
							FAIO.lastTick = os.clock() + 0.5
							return
						else
							FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
							return
						end
					end
				end
			end
		end
	end

end

function FAIO.DPCombo(myHero, enemy)

	if not Menu.IsEnabled(FAIO.optionHeroDP) then return end
	if not  NPC.IsEntityInRange(myHero, enemy, 3000) then return end

  	local Q = NPC.GetAbilityByIndex(myHero, 0)
 	local W = NPC.GetAbilityByIndex(myHero, 1)
	local E = NPC.GetAbilityByIndex(myHero, 2)

	local blink = NPC.GetItem(myHero, "item_blink", true)

	local myMana = NPC.GetMana(myHero)

	FAIO.itemUsage(myHero, enemy)

	if Menu.IsKeyDown(FAIO.optionComboKey) and Wrap.EIsAlive(enemy) then
 		if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and FAIO.heroCanCastSpells(myHero, enemy) == true then
			if not NPC.IsEntityInRange(myHero, enemy, 999) then
				if Menu.IsEnabled(FAIO.optionHeroDPBlink) and blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1150 + Menu.GetValue(FAIO.optionHeroDPBlinkRange)) then
					Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(Menu.GetValue(FAIO.optionHeroDPBlinkRange))))
					return
				end
			end	

			if os.clock() > FAIO.lastTick then
		
				if Q and Ability.IsCastable(Q, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(Q)) then
					local carrionPrediction = 0.5 + (Entity.GetAbsOrigin(enemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1100) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
					local predictedPos = Entity.GetAbsOrigin(myHero) + (FAIO.castLinearPrediction(myHero, enemy, carrionPrediction) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(250)
					Ability.CastPosition(Q, predictedPos)
					FAIO.lastTick = os.clock() + 0.5
					return
				end

				if W and Ability.IsCastable(W, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(W)) then
					local bestPos = FAIO.getBestPosition(Wrap.HInRadius(Entity.GetAbsOrigin(enemy), 820, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY), 410)
					if bestPos ~= nil then
						Ability.CastPosition(W, bestPos)
						FAIO.lastTick = os.clock() + 0.5
						return
					end
				end

				if E and Ability.IsCastable(E, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(E)) then
					Ability.CastTarget(E, enemy)
					FAIO.lastTick = os.clock() + 0.1
					return
				end
			end
		end

		FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
		return
	end

end

function FAIO.ViperCombo(myHero, enemy)

	if not Menu.IsEnabled(FAIO.optionHeroViper) then return end

	local Q = NPC.GetAbilityByIndex(myHero, 0)
 	local W = NPC.GetAbilityByIndex(myHero, 1)
	local ult = NPC.GetAbility(myHero, "viper_viper_strike")

	local blink = NPC.GetItem(myHero, "item_blink", true)

	local myMana = NPC.GetMana(myHero)

	FAIO.itemUsage(myHero, enemy)

	if enemy and NPC.IsEntityInRange(myHero, enemy, 3000) then
		if Menu.IsKeyDown(FAIO.optionComboKey) and Wrap.EIsAlive(enemy) then
 			if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and FAIO.heroCanCastSpells(myHero, enemy) == true then
				if not NPC.IsEntityInRange(myHero, enemy, 925) then
					if Menu.IsEnabled(FAIO.optionHeroViperBlink) and blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1150 + Menu.GetValue(FAIO.optionHeroViperBlinkRange)) then
						Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(Menu.GetValue(FAIO.optionHeroViperBlinkRange))))
						return
					end
				end		

				if os.clock() > FAIO.lastTick then

					if W and Ability.IsCastable(W, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(W)) and not NPC.HasModifier(enemy, "modifier_viper_nethertoxin") then
						local bestPos = FAIO.getBestPosition(Wrap.HInRadius(Entity.GetAbsOrigin(enemy), 570, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY), 285)
						if bestPos ~= nil and NPC.IsPositionInRange(myHero, bestPos, Ability.GetCastRange(W), 0) then
							Ability.CastPosition(W, bestPos)
							FAIO.lastTick = os.clock() + 0.2
							return
						end
					end

					if ult and Ability.IsCastable(ult, myMana) then
						if Menu.IsEnabled(FAIO.optionHeroViperForceUlt) then
							if not NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(ult)) then
								FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Entity.GetAbsOrigin(enemy))
								return
							else
								Ability.CastTarget(ult, enemy)
								FAIO.lastTick = os.clock() + 0.3
								return
							end

						else
							if NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(ult)) then
								Ability.CastTarget(ult, enemy)
								FAIO.lastTick = os.clock() + 0.3
								return
							end
						end
					end
				end
			end

			FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
			return
		end
	end

	if Menu.IsEnabled(FAIO.optionHeroViperHarass) then
		if Menu.IsKeyDown(FAIO.optionHeroViperHarassKey) then
			FAIO.ViperAutoHarass(myHero, myMana, Q)
		end
	end

	if Menu.IsEnabled(FAIO.optionHeroViperFarm) then
		FAIO.ViperFarmHelper(myHero, myMana, W)
	end

end

function FAIO.ViperAutoHarass(myHero, myMana, Q)

	if not myHero then return end
	if not Menu.IsEnabled(FAIO.optionHeroViperHarass) then return end

	if not Q then return end
		if Ability.GetLevel(Q) < 1 then return end

	if FAIO.heroCanCastSpells(myHero, enemy) == false then return end
	if FAIO.isHeroChannelling(myHero) == true then return end 
	if FAIO.IsHeroInvisible(myHero) == true then return end

	local harassTarget = nil
		for _, hero in ipairs(Wrap.HeroesInRadius(myHero, NPC.GetAttackRange(myHero), Enum.TeamType.TEAM_ENEMY)) do
			if hero and Entity.IsHero(hero) and not Entity.IsDormant(hero) and not NPC.IsIllusion(hero) then 
				if Wrap.EIsAlive(hero) and not NPC.HasState(hero, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
        				harassTarget = hero
					break
				end
      			end			
		end

	local mousePos = Input.GetWorldCursorPos()
	if harassTarget ~= nil then
		if not FAIO.lastHitBackswingChecker(myHero) then
			Ability.CastTarget(Q, harassTarget)
			return
		else
			if not NPC.IsPositionInRange(myHero, mousePos, 50, 0) then
				FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, mousePos)
				return
			end
		end
	else
		if not NPC.IsPositionInRange(myHero, mousePos, 50, 0) then
			FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, mousePos)
			return
		end
	end

	return

end

function FAIO.ViperFarmHelper(myHero, myMana, W)

	if not myHero then return end
	if not Menu.IsEnabled(FAIO.optionHeroViperFarm) then return end
	local myManaPerc = math.floor((myMana / NPC.GetMaxMana(myHero)) * 100)
		if myManaPerc < Menu.GetValue(FAIO.optionHeroViperFarmMana) then return end

	if not W then return end
		if not Ability.IsCastable(W, myMana) then return end

	if FAIO.heroCanCastSpells(myHero, enemy) == false then return end
	if FAIO.isHeroChannelling(myHero) == true then return end 
	if FAIO.IsHeroInvisible(myHero) == true then return end

	for _, creeps in ipairs(Wrap.UnitsInRadius(myHero, 800, Enum.TeamType.TEAM_ENEMY)) do
		if creeps and Wrap.EIsNPC(creeps) and not Entity.IsHero(creeps) and Wrap.EIsAlive(creeps) and not Entity.IsDormant(creeps) and not NPC.IsWaitingToSpawn(creeps) and NPC.GetUnitName(creeps) ~= "npc_dota_neutral_caster" and NPC.IsCreep(creeps) and NPC.GetUnitName(creeps) ~= nil then
			if creeps ~= nil and not NPC.IsRunning(creeps) and NPC.IsAttacking(creeps) and not NPC.IsRanged(creeps) and not NPC.HasModifier(creeps, "modifier_viper_nethertoxin") and #Wrap.UnitsInRadius(creeps, 290, Enum.TeamType.TEAM_FRIEND) >= Menu.GetValue(FAIO.optionHeroViperFarmCount) - 1 then
				local bestPos = FAIO.getBestPosition(Wrap.NInRadius(Entity.GetAbsOrigin(creeps), 580, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY), 290)
				if bestPos ~= nil and NPC.IsPositionInRange(myHero, bestPos, Ability.GetCastRange(W), 0) then

					Ability.CastPosition(W, bestPos)
					break
					return
				end
			end
		end
	end
	return

end

function FAIO.PugnaCombo(myHero, enemy)

	if not Menu.IsEnabled(FAIO.optionHeroPugna) then return end
	if not NPC.IsEntityInRange(myHero, enemy, 3000) then return end

  	local Q = NPC.GetAbilityByIndex(myHero, 0)
 	local W = NPC.GetAbilityByIndex(myHero, 1)
	local E = NPC.GetAbilityByIndex(myHero, 2)
	local ult = NPC.GetAbility(myHero, "pugna_life_drain")
		if ult and Ability.SecondsSinceLastUse(ult) > -1 and Ability.SecondsSinceLastUse(ult) < 0.15 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetAvgLatency(Enum.Flow.FLOW_INCOMING)) then
			return
		end

	local blink = NPC.GetItem(myHero, "item_blink", true)

	local myMana = NPC.GetMana(myHero)

	FAIO.itemUsage(myHero, enemy)

	if Menu.IsKeyDown(FAIO.optionComboKey) and Wrap.EIsAlive(enemy) then
 		if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and FAIO.heroCanCastSpells(myHero, enemy) == true then
			if not NPC.IsEntityInRange(myHero, enemy, 700) then
				if Menu.IsEnabled(FAIO.optionHeroPugnaBlink) and blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1150 + Menu.GetValue(FAIO.optionHeroPugnaBlinkRange)) then
					Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(Menu.GetValue(FAIO.optionHeroPugnaBlinkRange))))
					return
				end
			end

			if os.clock() > FAIO.lastTick and not NPC.IsChannellingAbility(myHero) then

				if W and Ability.IsCastable(W, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(W)) then
					Ability.CastTarget(W, enemy)
					FAIO.lastTick = os.clock() + 0.2
					return
				end
		
				if Q and Ability.IsCastable(Q, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(Q) + 300) then
					local pred = 1.1 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
					local predPos = FAIO.castPrediction(myHero, enemy, pred)
					if not NPC.IsPositionInRange(myHero, predPos, Ability.GetCastRange(Q), 0) then
						local myPos = Entity.GetAbsOrigin(myHero)
						local dist = (myPos - predPos):Length2D()
						local saveCastPos = predPos
						for k = 1, math.floor(dist/25) do
							local searchPos = predPos + (myPos - predPos):Normalized():Scaled(k*25)
							if NPC.IsPositionInRange(myHero, searchPos, Ability.GetCastRange(Q), 0) then
								saveCastPos = searchPos
								break
							end
						end
						if NPC.IsPositionInRange(myHero, saveCastPos, Ability.GetCastRange(Q), 0) then	
							Ability.CastPosition(Q, saveCastPos)
							FAIO.lastTick = os.clock() + 0.2
							return
						end
					else
						Ability.CastPosition(Q, predPos)
						FAIO.lastTick = os.clock() + 0.2
						return
					end

				end

				if Menu.IsEnabled(FAIO.optionHeroPugnaWard) then
					if #Wrap.HeroesInRadius(myHero, 1200, Enum.TeamType.TEAM_ENEMY) >= Menu.GetValue(FAIO.optionHeroPugnaWardCount) then
						if E and Ability.IsCastable(E, myMana) and NPC.IsEntityInRange(myHero, enemy, 700) then
							Ability.CastPosition(E, Entity.GetAbsOrigin(myHero) + Entity.GetRotation(myHero):GetForward():Normalized():Scaled(100))
							FAIO.lastTick = os.clock() + 0.2
							return
						end
					end
				end

				if Menu.IsEnabled(FAIO.optionHeroPugnaInvis) then
					local glimmer = NPC.GetItem(myHero, "item_glimmer_cape", true)
					local blade = NPC.GetItem(myHero, "item_invis_sword", true)
					local silver = NPC.GetItem(myHero, "item_silver_edge", true)
					if ult and Ability.IsCastable(ult, myMana - 90) and not FAIO.IsHeroInvisible(myHero) then
						if glimmer and Ability.IsCastable(glimmer, myMana) then
							Ability.CastTarget(glimmer, myHero)
							return
						end

						if blade and Ability.IsCastable(blade, myMana) then
							Ability.CastNoTarget(blade)
							return
						end

						if silver and Ability.IsCastable(silver, myMana) then
							Ability.CastNoTarget(silver)
							return
						end
					end
				end

				if ult and Ability.IsCastable(ult, myMana) then
					local castRangeAdjustment = Ability.GetCastRange(ult)
					local dagon = NPC.GetItem(myHero, "item_dagon", true)
						if not dagon then
							for i = 2, 5 do
								dagon = NPC.GetItem(myHero, "item_dagon_" .. i, true)
								if dagon then 
									break 
								end
							end
						end

						if dagon then
							if Ability.GetCastRange(dagon) < Ability.GetCastRange(ult) then
								castRangeAdjustment = Ability.GetCastRange(dagon)
							end
						end

					if not Ability.IsChannelling(ult) then
						if NPC.IsEntityInRange(myHero, enemy, castRangeAdjustment) then
							Ability.CastTarget(ult, enemy)
							FAIO.lastTick = os.clock() + 0.2
							return
						else
							if NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_ATTACK_IMMUNE) then
								FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Entity.GetAbsOrigin(enemy))
								return
							end
						end	
					end
				end
			end
		end

		FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
		return
	end

end

function FAIO.NSCombo(myHero, enemy)

	if not Menu.IsEnabled(FAIO.optionHeroNS) then return end
	if not  NPC.IsEntityInRange(myHero, enemy, 3000) then return end

  	local Q = NPC.GetAbilityByIndex(myHero, 0)
 	local W = NPC.GetAbilityByIndex(myHero, 1)

	local blink = NPC.GetItem(myHero, "item_blink", true)

	local myMana = NPC.GetMana(myHero)

	FAIO.itemUsage(myHero, enemy)

	if Menu.IsKeyDown(FAIO.optionComboKey) and Wrap.EIsAlive(enemy) then
 		if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and FAIO.heroCanCastSpells(myHero, enemy) == true then
			if not NPC.IsEntityInRange(myHero, enemy, 500) then
				if Menu.IsEnabled(FAIO.optionHeroNSBlink) and blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1150) then
					Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy))
					return
				end
			end	

			if os.clock() > FAIO.lastTick then
		
				if Q and Ability.IsCastable(Q, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(Q)) then
					Ability.CastTarget(Q, enemy)
					FAIO.lastTick = os.clock() + 0.3
					return
				end

				if W and Ability.IsCastable(W, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(W)) then
					Ability.CastTarget(W, enemy)
					FAIO.lastTick = os.clock() + 0.3
					return
				end
			end
		end

		FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
		return
	end

end

function FAIO.UndyingCombo(myHero, enemy)

	if not Menu.IsEnabled(FAIO.optionHeroUndying) then return end
	if not  NPC.IsEntityInRange(myHero, enemy, 3000) then return end

  	local Q = NPC.GetAbilityByIndex(myHero, 0)
 	local W = NPC.GetAbilityByIndex(myHero, 1)
	local ult = NPC.GetAbility(myHero, "undying_flesh_golem")

	local blink = NPC.GetItem(myHero, "item_blink", true)

	local myMana = NPC.GetMana(myHero)

	FAIO.itemUsage(myHero, enemy)

	if Menu.IsEnabled(FAIO.optionHeroUndyingSoulKS) then
		FAIO.UndyingSoulKS(myHero, myMana, W)
	end

	if Menu.IsKeyDown(FAIO.optionComboKey) and Wrap.EIsAlive(enemy) then
 		if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and FAIO.heroCanCastSpells(myHero, enemy) == true then
			if not NPC.IsEntityInRange(myHero, enemy, 500) then
				if Menu.IsEnabled(FAIO.optionHeroUndyingBlink) and blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1150) then
					Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy))
					return
				end
			end	

			if os.clock() > FAIO.lastTick then
		
				if Q and Ability.IsCastable(Q, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(Q)) then
					local bestPos = FAIO.getBestPosition(Wrap.HInRadius(Entity.GetAbsOrigin(enemy), 620, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY), 310)
					if bestPos ~= nil then
						Ability.CastPosition(Q, bestPos)
						FAIO.lastTick = os.clock() + 0.45
						return
					end
				end

				if W and Ability.IsCastable(W, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(W)) then
					local saving = false
					local savingUnit = nil
						if Entity.GetHealth(myHero) / Entity.GetMaxHealth(myHero) < Menu.GetValue(FAIO.optionHeroUndyingSoulTreshold) / 100 then
							saving = true
							savingUnit = myHero
						elseif #Wrap.HeroesInRadius(myHero, Ability.GetCastRange(W), Enum.TeamType.TEAM_FRIEND) > 0 then
							for _, ally in ipairs(Wrap.HeroesInRadius(myHero, Ability.GetCastRange(W), Enum.TeamType.TEAM_FRIEND)) do
								if ally and Wrap.EIsAlive(ally) and not NPC.IsIllusion(ally) then
									if Entity.GetHealth(ally) / Entity.GetMaxHealth(ally) < Menu.GetValue(FAIO.optionHeroUndyingSoulTreshold) / 100 then
										saving = true
										savingUnit = ally
									end
								end
							end
						end

					if not saving then
						if #Wrap.UnitsInRadius(myHero, 1290, Enum.TeamType.TEAM_BOTH) >= Menu.GetValue(FAIO.optionHeroUndyingSoulCount) then
							Ability.CastTarget(W, enemy)
							FAIO.lastTick = os.clock() + 0.45
							return
						end
					else
						if savingUnit ~= nil then
							Ability.CastTarget(W, savingUnit)
							FAIO.lastTick = os.clock() + 0.45
							return
						end
					end	
				end
				
				if Menu.IsEnabled(FAIO.optionHeroUndyingUlt) then
					if #Wrap.HeroesInRadius(myHero, 700, Enum.TeamType.TEAM_BOTH) >= Menu.GetValue(FAIO.optionHeroUndyingUltCount) then
						if ult and Ability.IsCastable(ult, myMana) and NPC.IsEntityInRange(myHero, enemy, 700) then
							Ability.CastNoTarget(ult)
							FAIO.lastTick = os.clock() + 0.15
							return
						end
					end
				end
			end
		end

		FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
		return
	end

	if Entity.GetHealth(myHero) / Entity.GetMaxHealth(myHero) < Menu.GetValue(FAIO.optionHeroUndyingSoulTreshold) / 100 then
		if W and Ability.IsCastable(W, myMana) then
			Ability.CastTarget(W, myHero)
			FAIO.lastTick = os.clock() + 0.45
			return
		end
	end

	if #Wrap.HeroesInRadius(myHero, Ability.GetCastRange(W), Enum.TeamType.TEAM_FRIEND) > 0 then
		for _, ally in ipairs(Wrap.HeroesInRadius(myHero, Ability.GetCastRange(W), Enum.TeamType.TEAM_FRIEND)) do
			if ally and Wrap.EIsAlive(ally) and not NPC.IsIllusion(ally) then
				if Entity.GetHealth(ally) / Entity.GetMaxHealth(ally) < Menu.GetValue(FAIO.optionHeroUndyingSoulTreshold) / 100 then
					Ability.CastTarget(W, ally)
					FAIO.lastTick = os.clock() + 0.45
					return
				end
			end
		end
	end

	return

end

function FAIO.UndyingSoulKS(myHero, myMana, soulrip)

	if not myHero then return end
	if not soulrip then return end
		if not Ability.IsReady(soulrip) then return end
		if not Ability.IsCastable(soulrip, myMana) then return end

	if FAIO.heroCanCastSpells(myHero, enemy) == false then return end
	if FAIO.isHeroChannelling(myHero) == true then return end
	if FAIO.IsHeroInvisible(myHero) == true then return end

	local damagePerUnit = Ability.GetLevelSpecialValueFor(soulrip, "damage_per_unit")
	local maxUnits = Ability.GetLevelSpecialValueFor(soulrip, "max_units")
	local radius = Ability.GetLevelSpecialValueFor(soulrip, "radius")

	local unitsAround = 0
		for _, v in ipairs(Wrap.UnitsInRadius(myHero, radius - 25, Enum.TeamType.TEAM_BOTH)) do
			if v and Wrap.EIsNPC(v) and Wrap.EIsAlive(v) then
				if Entity.IsSameTeam(myHero, v) then
					unitsAround = unitsAround + 1
				else
					if not NPC.HasState(v, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
						unitsAround = unitsAround + 1
					end
				end
			end
		end

	local adjustedUnitsAround = math.min(unitsAround, maxUnits)

	local damage = adjustedUnitsAround * damagePerUnit

	for _, targets in ipairs(Wrap.HeroesInRadius(myHero, Ability.GetCastRange(soulrip), Enum.TeamType.TEAM_ENEMY)) do
		if targets then
			local target = FAIO.targetChecker(targets)
			if target then
				if not NPC.HasState(target, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and not NPC.HasModifier(target, "modifier_templar_assassin_refraction_absorb") then
					local targetHP = Entity.GetHealth(target) + NPC.GetHealthRegen(target)
					local soulripTrueDamage = (1 - NPC.GetMagicalArmorValue(target)) * (damage + damage * (Hero.GetIntellectTotal(myHero) / 14 / 100))
					if targetHP < soulripTrueDamage then
						Ability.CastTarget(soulrip, target)
						break
						return
					end
				end
			end
		end
	end

	return

end

function FAIO.CKCombo(myHero, enemy)

	if not Menu.IsEnabled(FAIO.optionHeroCK) then return end
	if not  NPC.IsEntityInRange(myHero, enemy, 3000) then return end

  	local Q = NPC.GetAbilityByIndex(myHero, 0)
 	local W = NPC.GetAbilityByIndex(myHero, 1)
	local ult = NPC.GetAbility(myHero, "chaos_knight_phantasm")

	local blink = NPC.GetItem(myHero, "item_blink", true)

	local myMana = NPC.GetMana(myHero)

	FAIO.itemUsage(myHero, enemy)

	if Menu.IsKeyDown(FAIO.optionComboKey) and Wrap.EIsAlive(enemy) then
 		if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and FAIO.heroCanCastSpells(myHero, enemy) == true then
			if not NPC.IsEntityInRange(myHero, enemy, 500) then
				if Menu.IsEnabled(FAIO.optionHeroCKBlink) and blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1150) then
					Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy))
					return
				end
			end	

			if os.clock() > FAIO.lastTick then
		
				if Q and Ability.IsCastable(Q, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(Q)) then
					Ability.CastTarget(Q, enemy)
					FAIO.lastTick = os.clock() + 0.4
					return
				end

				if W and Ability.IsCastable(W, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(W)) then
					Ability.CastTarget(W, enemy)
					FAIO.lastTick = os.clock() + 0.3
					return
				end

				if Menu.IsEnabled(FAIO.optionHeroCKUlt) then
					if ult and Ability.IsCastable(ult, myMana) and NPC.IsEntityInRange(myHero, enemy, Menu.GetValue(FAIO.optionHeroCKUltTrigger)) then
						Ability.CastNoTarget(ult)
						FAIO.lastTick = os.clock() + 0.4
						return
					end
				end
			end
		end

		FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
		FAIO.GenericControllableAttackIssuer("ATTACK_TARGET", enemy, nil)
		return
	end

end

function FAIO.NyxCombo(myHero, enemy)

	if not Menu.IsEnabled(FAIO.optionHeroNyx) then return end
	if not  NPC.IsEntityInRange(myHero, enemy, 3000) then return end

  	local Q = NPC.GetAbilityByIndex(myHero, 0)
 	local W = NPC.GetAbilityByIndex(myHero, 1)

	local blink = NPC.GetItem(myHero, "item_blink", true)

	local myMana = NPC.GetMana(myHero)

	FAIO.itemUsage(myHero, enemy)

	if Menu.IsKeyDown(FAIO.optionComboKey) and Wrap.EIsAlive(enemy) then
 		if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and FAIO.heroCanCastSpells(myHero, enemy) == true and not NPC.HasModifier(myHero, "modifier_nyx_assassin_vendetta") then
			if not NPC.IsEntityInRange(myHero, enemy, 500) then
				if Menu.IsEnabled(FAIO.optionHeroNyxBlink) and blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1150) then
					Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy))
					return
				end
			end	

			if os.clock() > FAIO.lastTick then
		
				if Q and Ability.IsCastable(Q, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(Q) - 50) then
					local pred = 0.4 + (Entity.GetAbsOrigin(enemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1600) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
					local predPos = FAIO.castLinearPrediction(myHero, enemy, pred)
					local predPosAdjusted = Entity.GetAbsOrigin(myHero) + (predPos - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(200)
					Ability.CastPosition(Q, predPosAdjusted)
					FAIO.lastTick = os.clock() + 0.4
					return
				end

				if W and Ability.IsCastable(W, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(W)) then
					Ability.CastTarget(W, enemy)
					FAIO.lastTick = os.clock() + 0.4
					return
				end
			end
		end

		if not NPC.HasModifier(myHero, "modifier_nyx_assassin_burrow") then
			FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
			return
		end
	end

end

function FAIO.LionCombo(myHero, enemy)

	if not Menu.IsEnabled(FAIO.optionHeroLion) then return end
	if not  NPC.IsEntityInRange(myHero, enemy, 3000) then return end

  	local Q = NPC.GetAbilityByIndex(myHero, 0)
 	local W = NPC.GetAbilityByIndex(myHero, 1)

	local blink = NPC.GetItem(myHero, "item_blink", true)

	local myMana = NPC.GetMana(myHero)

	FAIO.itemUsage(myHero, enemy)

	if Menu.IsKeyDown(FAIO.optionComboKey) and Wrap.EIsAlive(enemy) then
 		if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and FAIO.heroCanCastSpells(myHero, enemy) == true then
			if not NPC.IsEntityInRange(myHero, enemy, 800) then
				if Menu.IsEnabled(FAIO.optionHeroLionBlink) and blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1150 + Menu.GetValue(FAIO.optionHeroLionBlinkRange)) then
					Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(Menu.GetValue(FAIO.optionHeroLionBlinkRange))))
					FAIO.lastTick = os.clock() + 0.1 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)
					return
				end
			end	

			if os.clock() > FAIO.lastTick then

				if W and Ability.IsCastable(W, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(W)) and not NPC.IsStunned(enemy) then
					local specialBonus = NPC.GetAbility(myHero, "special_bonus_unique_lion_4")
					local specialCheck = false
						if specialBonus and Ability.GetLevel(specialBonus) > 0 then
							specialCheck = true
						end
					if not specialCheck then
						Ability.CastTarget(W, enemy)
						FAIO.lastTick = os.clock() + 0.1 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)
						return
					else
						local bestPos = FAIO.getBestPosition(Wrap.HInRadius(Entity.GetAbsOrigin(enemy), 620, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY), 310)
						if bestPos ~= nil and NPC.IsPositionInRange(myHero, bestPos, Ability.GetCastRange(W), 0) then
							Ability.CastPosition(W, bestPos)
							FAIO.lastTick = os.clock() + 0.1 + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)
							return
						end
					end
				end
		
				if Q and Ability.IsCastable(Q, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(Q) - 50) then
					local pred = 0.3 + (Entity.GetAbsOrigin(enemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1600) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
					local predPos = FAIO.castLinearPrediction(myHero, enemy, pred)
					local predPosAdjusted = Entity.GetAbsOrigin(myHero) + (predPos - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(200)

					local hexMod = NPC.GetModifier(enemy, "modifier_lion_voodoo")
					local dieTime = 0
						if hexMod then
							dieTime = Modifier.GetDieTime(hexMod)
						end

					if dieTime > 0 then
						local timingOffset = ((Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Length2D() - 125) / 1600
						if dieTime - GameRules.GetGameTime() <= 0.35 + timingOffset then
							Ability.CastPosition(Q, predPosAdjusted)
							FAIO.lastTick = os.clock() + 0.3
							return
						end
					else
						Ability.CastPosition(Q, predPosAdjusted)
						FAIO.lastTick = os.clock() + 0.3
						return
					end
				end	
			end
		end

		FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
		return
	end

end

function FAIO.WDCombo(myHero, enemy)

	if not Menu.IsEnabled(FAIO.optionHeroWD) then return end
	if not  NPC.IsEntityInRange(myHero, enemy, 3000) then return end

  	local Q = NPC.GetAbilityByIndex(myHero, 0)
 	local E = NPC.GetAbilityByIndex(myHero, 2)

	local blink = NPC.GetItem(myHero, "item_blink", true)

	local myMana = NPC.GetMana(myHero)

	FAIO.itemUsage(myHero, enemy)

	if Menu.IsKeyDown(FAIO.optionComboKey) and Wrap.EIsAlive(enemy) then
 		if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and FAIO.heroCanCastSpells(myHero, enemy) == true then
			if not NPC.IsEntityInRange(myHero, enemy, 999) then
				if Menu.IsEnabled(FAIO.optionHeroWDBlink) and blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1150 + Menu.GetValue(FAIO.optionHeroWDBlinkRange)) then
					Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(Menu.GetValue(FAIO.optionHeroWDBlinkRange))))
					return
				end
			end	

			if os.clock() > FAIO.lastTick then
		
				if Q and Ability.IsCastable(Q, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(Q)) then
					Ability.CastTarget(Q, enemy)
					FAIO.lastTick = os.clock() + 0.35
					return
				end

				if E and Ability.IsCastable(E, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(E)) then
					local pred = 0.4 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
					Ability.CastPosition(E, FAIO.castPrediction(myHero, enemy, pred))
					FAIO.lastTick = os.clock() + 0.35
					return
				end
			end
		end

		FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
		return
	end

end

function FAIO.SSCombo(myHero, enemy)

	if not Menu.IsEnabled(FAIO.optionHeroSS) then return end
	if not  NPC.IsEntityInRange(myHero, enemy, 3000) then return end

  	local Q = NPC.GetAbilityByIndex(myHero, 0)
	local W = NPC.GetAbilityByIndex(myHero, 1)
 	local E = NPC.GetAbilityByIndex(myHero, 2)

	local blink = NPC.GetItem(myHero, "item_blink", true)

	local myMana = NPC.GetMana(myHero)

	FAIO.itemUsage(myHero, enemy)

	if Menu.IsKeyDown(FAIO.optionComboKey) and Wrap.EIsAlive(enemy) then
 		if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and FAIO.heroCanCastSpells(myHero, enemy) == true then
			if not NPC.IsEntityInRange(myHero, enemy, 999) then
				if Menu.IsEnabled(FAIO.optionHeroSSBlink) and blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1150 + Menu.GetValue(FAIO.optionHeroSSBlinkRange)) then
					Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(Menu.GetValue(FAIO.optionHeroSSBlinkRange))))
					return
				end
			end	

			if os.clock() > FAIO.lastTick then

				if W and Ability.IsCastable(W, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(W)) then
					Ability.CastTarget(W, enemy)
					FAIO.lastTick = os.clock() + 0.05
					return
				end
		
				if Q and Ability.IsCastable(Q, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(Q)) then
					Ability.CastTarget(Q, enemy)
					FAIO.lastTick = os.clock() + 0.3
					return
				end

				if E and Ability.IsCastable(E, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(E)) then
					local hexMod = NPC.GetModifier(enemy, "modifier_shadow_shaman_voodoo")
					local dieTime = 0
						if hexMod then
							dieTime = Modifier.GetDieTime(hexMod)
						end
					if dieTime > 0 then
						if dieTime - GameRules.GetGameTime() <= 0.45 then
							Ability.CastTarget(E, enemy)
							FAIO.lastTick = os.clock() + 0.3
							return
						end
					else
						Ability.CastTarget(E, enemy)
						FAIO.lastTick = os.clock() + 0.3
						return
					end
				end
			end
		end

		FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
		return
	end

end

function FAIO.clockwerkCombo(myHero, enemy)

	if not Menu.IsEnabled(FAIO.optionHeroClock) then return end
	if not NPC.IsEntityInRange(myHero, enemy, 3000)	then return end
	
	local BatteryAssault = NPC.GetAbilityByIndex(myHero, 0)
	local PowerCogs = NPC.GetAbilityByIndex(myHero, 1)
	local RocketFlair = NPC.GetAbilityByIndex(myHero, 2)
	local HookShot = NPC.GetAbility(myHero, "rattletrap_hookshot")

	local Blademail = NPC.GetItem(myHero, "item_blade_mail", true)
	local myMana = NPC.GetMana(myHero)
	
	FAIO.itemUsage(myHero, enemy)

	local cogsTargeter
	if NPC.IsRunning(enemy) then
		cogsTargeter = 100
	else
		cogsTargeter = 200
	end

	if FAIO.clockwerkHookshotChecker(myHero, myMana, enemy, HookShot) == true then
		FAIO.clockwerkHookUpValue = true
	else
		FAIO.clockwerkHookUpValue = false
	end

	if Menu.IsKeyDown(FAIO.optionComboKey) and Entity.GetHealth(enemy) > 0 and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and FAIO.heroCanCastSpells(myHero, enemy) == true then
		if not NPC.IsEntityInRange(myHero, enemy, cogsTargeter) then
			if HookShot and Ability.IsCastable(HookShot, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(HookShot)) and FAIO.clockwerkHookUpValue == true then
				local hookshotPrediction = Ability.GetCastPoint(HookShot) + (Entity.GetAbsOrigin(enemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / Ability.GetLevelSpecialValueFor(HookShot, "speed")) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
				Ability.CastPosition(HookShot, FAIO.castLinearPrediction(myHero, enemy, hookshotPrediction))
				FAIO.lastTick = os.clock()
				return
			end
		else
			if PowerCogs and Ability.IsCastable(PowerCogs, myMana) then 
				Ability.CastNoTarget(PowerCogs)
				FAIO.lastTick = os.clock()
				return
			end
			if FAIO.SleepReady(0.2) and BatteryAssault and Ability.IsCastable(BatteryAssault, myMana) then 
				Ability.CastNoTarget(BatteryAssault)
				FAIO.lastTick = os.clock()
				return
			end
			if FAIO.SleepReady(0.3) and Blademail and Ability.IsCastable(Blademail, myMana) then 
				Ability.CastNoTarget(Blademail)
				return
			end			
			if FAIO.SleepReady(0.3) and RocketFlair and Ability.IsCastable(RocketFlair, myMana) then 
				Ability.CastPosition(RocketFlair, Entity.GetAbsOrigin(enemy))
				return 
			end
		end
	FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	end
end

function FAIO.clockwerkHookshotChecker(myHero, myMana, enemy, HookShot)

	if not myHero then return false end
	if not enemy then return false end

	if not HookShot then return false end
		if not Ability.IsReady(HookShot) or not Ability.IsCastable(HookShot, myMana) then return false end

	local latchRadius = 135
	local distance = (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Length2D() - 125
		if distance < 75 then return false end
		if distance + 150 > Ability.GetCastRange(HookShot) then return false end

	if #Wrap.UnitsInRadius(myHero, 125, Enum.TeamType.TEAM_BOTH) > 0 then return false end

	for i = 2, math.floor(distance / latchRadius) do
		local checkVec = (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Normalized()
		local checkPos = Entity.GetAbsOrigin(myHero) + checkVec:Scaled(i*latchRadius)
		if #Wrap.NInRadius(checkPos, latchRadius, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_BOTH) > 0 then
			return false
		end
	end

	return true
			
end

function FAIO.clockwerkDrawHookIndicator(myHero)

	if not myHero then return end
	if not Menu.IsEnabled(FAIO.optionHeroClockDrawIndicator) then return end
	
	if FAIO.clockwerkHookUpValue == false then return end

	local enemy = FAIO.targetChecker(Input.GetNearestHeroToCursor(Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY))
		if not enemy then return end
		if not NPC.IsPositionInRange(enemy, Input.GetWorldCursorPos(), 500, 0) then return end

	local pos = Entity.GetAbsOrigin(enemy)
	local posY = NPC.GetHealthBarOffset(enemy)
		pos:SetZ(pos:GetZ() + posY)
			
	local x, y, visible = Renderer.WorldToScreen(pos)

	if visible then
		Renderer.SetDrawColor(50,205,50,255)
		Renderer.DrawText(FAIO.font, x-40, y-80, "hookable", 0)
	end
		
end

function FAIO.huskarCombo(myHero, enemy)

	if not Menu.IsEnabled(FAIO.optionHeroHuskar) then return end

	local burningspear = NPC.GetAbilityByIndex(myHero, 1)
	local innerVitality = NPC.GetAbilityByIndex(myHero, 0)
	local lifeBreak = NPC.GetAbility(myHero, "huskar_life_break")

	local myMana = NPC.GetMana(myHero)

	local Blademail = NPC.GetItem(myHero, "item_blade_mail", true)
	local blink = NPC.GetItem(myHero, "item_blink", true)

	FAIO.itemUsage(myHero, enemy)

	local attackRange = NPC.GetAttackRange(myHero)
	local lifeBreakRange = Ability.GetCastRange(lifeBreak)

	if enemy and Menu.IsKeyDown(FAIO.optionHeroHuskarHarassKey) then
		if burningspear and Ability.GetLevel(burningspear) > 0 then
			FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
			Engine.ExecuteCommand("dota_range_display " .. attackRange)
		end
	else
		Engine.ExecuteCommand("dota_range_display 0")
	end

	if enemy and Menu.IsKeyDown(FAIO.optionComboKey) and Entity.GetHealth(enemy) > 0 and FAIO.heroCanCastSpells(myHero, enemy) == true then
		if not NPC.IsEntityInRange(myHero, enemy, lifeBreakRange) then
			if blink and Ability.IsReady(blink) then
				if NPC.IsEntityInRange(myHero, enemy, 1650) then
					Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(500)))
					return
				end
			end
		else
			if innerVitality and Ability.IsCastable(innerVitality, myMana) then
				if Menu.GetValue(FAIO.optionHeroHuskarInnerVit) > 0 then
					if Menu.GetValue(FAIO.optionHeroHuskarInnerVit) < 2 then
						Ability.CastTarget(innerVitality, myHero)
						FAIO.lastTick = os.clock()
						return 
					else
						if Entity.GetHealth(myHero) <= Entity.GetMaxHealth(myHero) * (Menu.GetValue(FAIO.optionHeroHuskarHPThreshold) / 100) then
							Ability.CastTarget(innerVitality, myHero)
							FAIO.lastTick = os.clock()
							return
						end
					end
				end
			end 
			if FAIO.SleepReady(0.2) and lifeBreak and Ability.IsCastable(lifeBreak, myMana) and Menu.IsEnabled(FAIO.optionHeroHuskarUlt) then 
				Ability.CastTarget(lifeBreak, enemy)
				FAIO.lastTick = os.clock()
				return
			end
			if FAIO.SleepReady(0.2) and Blademail and Ability.IsCastable(Blademail, myMana) then 
				Ability.CastNoTarget(Blademail)
				return
			end
		end
	FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	end

	if Menu.IsEnabled(FAIO.optionHeroHuskarAutoVit) then
		FAIO.huskarAutoBerserkersBlood(myHero, myMana, innerVitality)
	end

end

function FAIO.huskarAutoBerserkersBlood(myHero, myMana, innerVitality)

	if not myHero then return end
	if not innerVitality then return end
		if not Ability.IsCastable(innerVitality, myMana) then return end

	if FAIO.heroCanCastItems(myHero) == false then return end
	if FAIO.isHeroChannelling(myHero) == true then return end
	if FAIO.IsHeroInvisible(myHero) == true then return end

	local myHealth = Entity.GetHealth(myHero)

	if myHealth <= Entity.GetMaxHealth(myHero) * (Menu.GetValue(FAIO.optionHeroHuskarHPThreshold) / 100) then
		Ability.CastTarget(innerVitality, myHero)
		return
	end

	if Menu.IsEnabled(FAIO.optionHeroHuskarAutoVitAlly) then
		local teamMatesAround = Wrap.HeroesInRadius(myHero, 790, Enum.TeamType.TEAM_FRIEND)
		if next(teamMatesAround) ~= nil then
			for _, ally in ipairs(teamMatesAround) do
				if ally and Entity.IsHero(ally) and not NPC.IsIllusion(ally) and Wrap.EIsAlive(ally) then
					if FAIO.IsNPCinDanger(myHero, ally) then
						Ability.CastTarget(innerVitality, ally)
						break
						return
					end
				end
			end
		end
	end

end

function FAIO.skywrathCombo(myHero, enemy)

	if not Menu.IsEnabled(FAIO.optionHeroSky) then return end
	if not NPC.IsEntityInRange(myHero, enemy, 3000)	then return end

	local arcaneBolt = NPC.GetAbilityByIndex(myHero, 0)
    	local concussiveShot = NPC.GetAbilityByIndex(myHero, 1)
    	local ancientSeal = NPC.GetAbilityByIndex(myHero, 2)
    	local mysticFlare = NPC.GetAbility(myHero, "skywrath_mage_mystic_flare")
	local myMana = NPC.GetMana(myHero)

	local blink = NPC.GetItem(myHero, "item_blink", true)
	
	FAIO.itemUsage(myHero, enemy)
	FAIO.skywrathComboTotalDamage(myHero, myMana, enemy, ancientSeal, arcaneBolt, concussiveShot, mysticFlare)
	FAIO.skywrathComboKillableWithoutUlt(myHero, myMana, enemy, ancientSeal, arcaneBolt, concussiveShot)

	if Menu.IsKeyDown(FAIO.optionHeroSkyHarassKey) then
		FAIO.skywrathComboHarass(myHero, myMana, arcaneBolt)
		Engine.ExecuteCommand("dota_range_display 875")
	else
		Engine.ExecuteCommand("dota_range_display 0")
	end

	if Menu.IsKeyDown(FAIO.optionComboKey) and Entity.GetHealth(enemy) > 0 and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and FAIO.heroCanCastSpells(myHero, enemy) == true then
		if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and FAIO.heroCanCastSpells(myHero, enemy) == true then
			if not NPC.IsEntityInRange(myHero, enemy, 999) then
				if Menu.IsEnabled(FAIO.optionHeroSkyBlink) and blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1150 + Menu.GetValue(FAIO.optionHeroSkyBlinkRange)) then
					Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(Menu.GetValue(FAIO.optionHeroSkyBlinkRange))))
					return
				end
			end

			if Menu.GetValue(FAIO.optionHeroSkyStyle) < 1 then
				FAIO.skywrathComboWithUlt(myHero, myMana, enemy, ancientSeal, arcaneBolt, concussiveShot, mysticFlare)
			else
				if FAIO.skywrathComboSelect == true then
					FAIO.skywrathComboWithoutUlt(myHero, myMana, enemy, ancientSeal, arcaneBolt, concussiveShot)
				else
					FAIO.skywrathComboWithUlt(myHero, myMana, enemy, ancientSeal, arcaneBolt, concussiveShot, mysticFlare)
				end
			end
		end
	FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	end

end

function FAIO.skywrathComboWithoutUlt(myHero, myMana, enemy, ancientSeal, arcaneBolt, concussiveShot)

	if not myHero then return end
	if not enemy then return end

	if concussiveShot and Ability.IsCastable(concussiveShot, myMana) and NPC.IsEntityInRange(myHero, enemy, 1550) then
		Ability.CastNoTarget(concussiveShot)
		FAIO.lastTick = os.clock()
		return
	end

	if FAIO.SleepReady(0.15) and arcaneBolt and Ability.IsCastable(arcaneBolt, myMana) and NPC.IsEntityInRange(myHero, enemy, 850) then
		Ability.CastTarget(arcaneBolt, enemy)
		FAIO.lastTick = os.clock()
		return
	end

	if FAIO.SleepReady(0.15) and ancientSeal and Ability.IsCastable(ancientSeal, myMana) and NPC.IsEntityInRange(myHero, enemy, 685) then
		Ability.CastTarget(ancientSeal, enemy)
		FAIO.lastTick = os.clock()
		return
	end

end

function FAIO.skywrathComboWithUlt(myHero, myMana, enemy, ancientSeal, arcaneBolt, concussiveShot, mysticFlare)

	if not myHero then return end
	if not enemy then return end

	local aghanimsBuffed = false
		if NPC.HasItem(myHero, "item_ultimate_scepter", true) or NPC.HasModifier(myHero, "modifier_item_ultimate_scepter_consumed") then
			aghanimsBuffed = true
		end

	if concussiveShot and Ability.IsCastable(concussiveShot, myMana) and NPC.IsEntityInRange(myHero, enemy, 1550) then
		Ability.CastNoTarget(concussiveShot)
		FAIO.lastTick = os.clock()
		return
	end

	if FAIO.SleepReady(0.15) and arcaneBolt and Ability.IsCastable(arcaneBolt, myMana) and NPC.IsEntityInRange(myHero, enemy, 850) then
		Ability.CastTarget(arcaneBolt, enemy)
		FAIO.lastTick = os.clock()
		return
	end

	if FAIO.SleepReady(0.15) and ancientSeal and Ability.IsCastable(ancientSeal, myMana) and NPC.IsEntityInRange(myHero, enemy, 685) then
		Ability.CastTarget(ancientSeal, enemy)
		FAIO.lastTick = os.clock()
		return
	end

	if FAIO.SleepReady(0.15) and mysticFlare and Ability.IsCastable(mysticFlare, myMana) then
		if FAIO.TargetDisableTimer(myHero, enemy) > 1.5 then
			if not aghanimsBuffed then
				Ability.CastPosition(mysticFlare, Entity.GetAbsOrigin(enemy) + Entity.GetRotation(enemy):GetForward():Normalized():Scaled(95))
				return
			else
				Ability.CastPosition(mysticFlare, Entity.GetAbsOrigin(enemy) + Entity.GetRotation(enemy):GetForward():Normalized():Scaled(175))
				return
			end
		elseif NPC.HasItem(myHero, "item_rod_of_atos", true) then
			if Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_rod_of_atos", true)) > ((Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Length2D() / 1500) and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_rod_of_atos", true)) < (((Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Length2D() / 1500) + 2) then
				if not aghanimsBuffed then
					Ability.CastPosition(mysticFlare, Entity.GetAbsOrigin(enemy) + Entity.GetRotation(enemy):GetForward():Normalized():Scaled(95))
					return
				else
					Ability.CastPosition(mysticFlare, Entity.GetAbsOrigin(enemy) + Entity.GetRotation(enemy):GetForward():Normalized():Scaled(175))
					return
				end
			end
		elseif NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_HEXED) then
			if not aghanimsBuffed then
				local flarePrediction = Ability.GetCastPoint(mysticFlare) + 0.2 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
				Ability.CastPosition(mysticFlare, FAIO.castPrediction(myHero, enemy, flarePrediction))
			else
				Ability.CastPosition(mysticFlare, FAIO.skywrathComboPredictDoubleUltWhileHexed(myHero, enemy))
				return
			end
		else
			if not aghanimsBuffed then
				local flarePrediction = Ability.GetCastPoint(mysticFlare) + 0.2 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
				Ability.CastPosition(mysticFlare, FAIO.castPrediction(myHero, enemy, flarePrediction))
			else
				Ability.CastPosition(mysticFlare, FAIO.skywrathComboPredictDoubleUltWhileHexed(myHero, enemy))
				return
			end
		end
	end

end

function FAIO.skywrathComboKillableWithoutUlt(myHero, myMana, enemy, ancientSeal, arcaneBolt, concussiveShot)

	if not myHero then return end
	if not enemy then return end

	if Ability.SecondsSinceLastUse(ancientSeal) > -1 and Ability.SecondsSinceLastUse(ancientSeal) < Ability.GetCooldownLength(arcaneBolt) + 0.5 then return end
	if Ability.SecondsSinceLastUse(concussiveShot) > -1 and Ability.SecondsSinceLastUse(concussiveShot) < Ability.GetCooldownLength(arcaneBolt) + 0.5 then return end
	if Ability.SecondsSinceLastUse(arcaneBolt) > -1 and Ability.SecondsSinceLastUse(arcaneBolt) < Ability.GetCooldownLength(arcaneBolt) + 0.5 then return end

	local totalDamage = 0
	local veilAmp = 0
	local silenceAmp = 0
	local ebladeAmp = 0
	local reqMana = 0

	local veil = NPC.GetItem(myHero, "item_veil_of_discord", true)
	local eBlade = NPC.GetItem(myHero, "item_ethereal_blade", true)
	local dagon = NPC.GetItem(myHero, "item_dagon", true)
		if not dagon then
			for i = 2, 5 do
				dagon = NPC.GetItem(myHero, "item_dagon_" .. i, true)
				if dagon then break end
			end
		end

	if veil and Ability.IsCastable(veil, myMana) then
		veilAmp = 0.25
		reqMana = reqMana + Ability.GetManaCost(veil)
	end	

	if ancientSeal and Ability.IsCastable(ancientSeal, myMana) then
		silenceAmp = (Ability.GetLevel(ancientSeal) * 5 + 30) / 100
		reqMana = reqMana + Ability.GetManaCost(ancientSeal)
	end

	if eBlade and Ability.IsCastable(eBlade, myMana) then
		local ebladedamage = Hero.GetIntellectTotal(myHero) * 2 + 75
		totalDamage = totalDamage + (1 - NPC.GetMagicalArmorValue(enemy)) * (1 + silenceAmp) * (1 + veilAmp) * (ebladedamage + ebladedamage * (Hero.GetIntellectTotal(myHero) / 14 / 100))
		ebladeAmp = 0.4
		reqMana = reqMana + Ability.GetManaCost(eBlade)
	end	

	if dagon and Ability.IsCastable(dagon, Ability.GetManaCost(dagon)) then
		local dagondmg = Ability.GetLevelSpecialValueFor(dagon, "damage")
		totalDamage = totalDamage + (1 - NPC.GetMagicalArmorValue(enemy)) * (1 + silenceAmp) * (1 + veilAmp) * (1 + ebladeAmp) * (dagondmg + dagondmg * (Hero.GetIntellectTotal(myHero) / 14 / 100))
		reqMana = reqMana + Ability.GetManaCost(dagon)
	end
                
	if arcaneBolt and Ability.IsCastable(arcaneBolt, myMana) then
		local boltdamage = Ability.GetLevelSpecialValueFor(arcaneBolt, "bolt_damage") + Hero.GetIntellectTotal(myHero) * 1.6
		if Ability.GetLevel(arcaneBolt) < 3 then
			totalDamage = totalDamage + (1 - NPC.GetMagicalArmorValue(enemy)) * (1 + silenceAmp) * (1 + veilAmp) * (1 + ebladeAmp) * (boltdamage + boltdamage * (Hero.GetIntellectTotal(myHero) / 14 / 100))
			reqMana = reqMana + Ability.GetManaCost(arcaneBolt)                    
		else
			totalDamage = totalDamage + (1 - NPC.GetMagicalArmorValue(enemy)) * (1 + silenceAmp) * (1 + veilAmp) * (1 + ebladeAmp) * (boltdamage + boltdamage * (Hero.GetIntellectTotal(myHero) / 14 / 100)) * 2
			reqMana = reqMana + Ability.GetManaCost(arcaneBolt) * 2
		end
	end

	if concussiveShot and Ability.IsCastable(concussiveShot, myMana) then
		local slowdamage = Ability.GetLevelSpecialValueFor(concussiveShot, "damage")
		totalDamage = totalDamage + (1 - NPC.GetMagicalArmorValue(enemy)) * (1 + silenceAmp) * (1 + veilAmp) * (1 + ebladeAmp) * (slowdamage + slowdamage * (Hero.GetIntellectTotal(myHero) / 14 / 100))
		reqMana = reqMana + Ability.GetManaCost(concussiveShot)
	end

	if reqMana < NPC.GetMana(myHero) and Entity.GetHealth(enemy) < totalDamage and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
		FAIO.skywrathComboSelect = true
	else		
		FAIO.skywrathComboSelect = false
	end

end

function FAIO.skywrathComboTotalDamage(myHero, myMana, enemy, ancientSeal, arcaneBolt, concussiveShot, mysticFlare)

	if not myHero then return end
	if not enemy then return end
	if NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then return end 

	local totalDamage = 0
	local totalDamageUlt = 0
	local veilAmp = 0
	local silenceAmp = 0
	local ebladeAmp = 0
	local reqMana = 0
	local reqManaUlt = 0

	local veil = NPC.GetItem(myHero, "item_veil_of_discord", true)
	local eBlade = NPC.GetItem(myHero, "item_ethereal_blade", true)
	local atos = NPC.GetItem(myHero, "item_rod_of_atos", true)
	local dagon = NPC.GetItem(myHero, "item_dagon", true)
		if not dagon then
			for i = 2, 5 do
				dagon = NPC.GetItem(myHero, "item_dagon_" .. i, true)
				if dagon then break end
			end
		end

	if veil and Ability.IsCastable(veil, myMana) then
		veilAmp = 0.25
		reqMana = reqMana + Ability.GetManaCost(veil)
	end	

	if ancientSeal and Ability.IsCastable(ancientSeal, myMana) then
		silenceAmp = (Ability.GetLevel(ancientSeal) * 5 + 30) / 100
		reqMana = reqMana + Ability.GetManaCost(ancientSeal)
	end

	if eBlade and Ability.IsCastable(eBlade, myMana) then
		local ebladedamage = Hero.GetIntellectTotal(myHero) * 2 + 75
		totalDamage = totalDamage + (1 - NPC.GetMagicalArmorValue(enemy)) * (1 + silenceAmp) * (1 + veilAmp) * (ebladedamage + ebladedamage * (Hero.GetIntellectTotal(myHero) / 14 / 100))
		ebladeAmp = 0.4
		reqMana = reqMana + Ability.GetManaCost(eBlade)
	end	

	if dagon and Ability.IsCastable(dagon, Ability.GetManaCost(dagon)) then
		local dagondmg = Ability.GetLevelSpecialValueFor(dagon, "damage")
		totalDamage = totalDamage + (1 - NPC.GetMagicalArmorValue(enemy)) * (1 + silenceAmp) * (1 + veilAmp) * (1 + ebladeAmp) * (dagondmg + dagondmg * (Hero.GetIntellectTotal(myHero) / 14 / 100))
		reqMana = reqMana + Ability.GetManaCost(dagon)
	end
                
	if arcaneBolt and Ability.IsCastable(arcaneBolt, myMana) then
		local boltdamage = Ability.GetLevelSpecialValueFor(arcaneBolt, "bolt_damage") + Hero.GetIntellectTotal(myHero) * 1.6
		if Ability.GetLevel(arcaneBolt) < 3 then
			totalDamage = totalDamage + (1 - NPC.GetMagicalArmorValue(enemy)) * (1 + silenceAmp) * (1 + veilAmp) * (1 + ebladeAmp) * (boltdamage + boltdamage * (Hero.GetIntellectTotal(myHero) / 14 / 100))
			reqMana = reqMana + Ability.GetManaCost(arcaneBolt)                    
		else
			totalDamage = totalDamage + (1 - NPC.GetMagicalArmorValue(enemy)) * (1 + silenceAmp) * (1 + veilAmp) * (1 + ebladeAmp) * (boltdamage + boltdamage * (Hero.GetIntellectTotal(myHero) / 14 / 100)) * 2
			reqMana = reqMana + Ability.GetManaCost(arcaneBolt) * 2
		end
	end

	if concussiveShot and Ability.IsCastable(concussiveShot, myMana) then
		local slowdamage = Ability.GetLevelSpecialValueFor(concussiveShot, "damage")
		totalDamage = totalDamage + (1 - NPC.GetMagicalArmorValue(enemy)) * (1 + silenceAmp) * (1 + veilAmp) * (1 + ebladeAmp) * (slowdamage + slowdamage * (Hero.GetIntellectTotal(myHero) / 14 / 100))
		reqMana = reqMana + Ability.GetManaCost(concussiveShot)
	end

	if mysticFlare and Ability.IsCastable(mysticFlare, myMana) then
		local mysticDamage
		if atos and Ability.IsCastable(atos, myMana) then
			mysticDamage = Ability.GetLevelSpecialValueFor(mysticFlare, "damage") * 2 / 2.4
		end
		if not atos or (atos and not Ability.IsCastable(atos, myMana)) then
			mysticDamage = Ability.GetLevelSpecialValueFor(mysticFlare, "damage") * 1 / 2.4
		end
		totalDamageUlt = totalDamage + (1 - NPC.GetMagicalArmorValue(enemy)) * (1 + silenceAmp) * (1 + veilAmp) * (1 + ebladeAmp) * (mysticDamage + mysticDamage * (Hero.GetIntellectTotal(myHero) / 14 / 100))
		reqManaUlt = reqMana + Ability.GetManaCost(mysticFlare)
	else
		totalDamageUlt = totalDamage
	end

	if reqManaUlt > NPC.GetMana(myHero) and reqMana < NPC.GetMana(myHero) then
		totalDamageUlt = totalDamage
	end

	if reqMana < NPC.GetMana(myHero) then
		FAIO.skywrathDMGwithoutUlt = totalDamage
		FAIO.skywrathDMGwithUlt = totalDamageUlt
	end

end

function FAIO.skywrathComboDrawDamage(myHero)

	if not myHero then return end
	if not Menu.IsEnabled(FAIO.optionHeroSkyDrawDMG) then return end
	
	if FAIO.skywrathDMGwithoutUlt == 0 then return end
	if FAIO.skywrathDMGwithUlt == 0 then return end

	local enemy = FAIO.targetChecker(Input.GetNearestHeroToCursor(Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY))
		if not enemy then return end
		if not NPC.IsPositionInRange(enemy, Input.GetWorldCursorPos(), 500, 0) then return end

	local pos = Entity.GetAbsOrigin(enemy)
	local posY = NPC.GetHealthBarOffset(enemy)
		pos:SetZ(pos:GetZ() + posY)
			
	local x, y, visible = Renderer.WorldToScreen(pos)

	if FAIO.skywrathDMGwithoutUlt > 0 and FAIO.skywrathDMGwithUlt > 0 then
		if visible then
			if Entity.GetHealth(enemy) > FAIO.skywrathDMGwithoutUlt then
				Renderer.SetDrawColor(255,102,102,255)
			else
				Renderer.SetDrawColor(50,205,50,255)
			end
				Renderer.DrawText(FAIO.skywrathFont, x-50, y-90, "DMG w/o Ult: " .. math.floor(FAIO.skywrathDMGwithoutUlt), 0)
			if Entity.GetHealth(enemy) > FAIO.skywrathDMGwithUlt then
				Renderer.SetDrawColor(255,102,102,255)
			else
				Renderer.SetDrawColor(50,205,50,255)
			end
				Renderer.DrawText(FAIO.skywrathFont, x-50, y-75, "DMG w/ Ult: " .. math.floor(FAIO.skywrathDMGwithUlt), 0)
		end
	end		

end

function FAIO.skywrathComboHarass(myHero, myMana, arcaneBolt)

	if not myHero then return end
	if not Menu.IsEnabled(FAIO.optionHeroSkyHarass) then return end

	if FAIO.heroCanCastSpells(myHero, enemy) == false then return end
	if FAIO.isHeroChannelling(myHero) == true then return end 
	if FAIO.IsHeroInvisible(myHero) == true then return end

	if not arcaneBolt then return end
		if not Ability.IsCastable(arcaneBolt, myMana) then return end

	for _, hero in ipairs(Wrap.HeroesInRadius(myHero, 875, Enum.TeamType.TEAM_ENEMY)) do
		if hero and Entity.IsHero(hero) and not Entity.IsDormant(hero) and not NPC.IsIllusion(hero) then 
			if Wrap.EIsAlive(hero) then
        			Ability.CastTarget(arcaneBolt, hero)
				break
        			return
			end
      		end		
	end	

end

function FAIO.skywrathComboPredictDoubleUltWhileHexed(myHero, enemy)

	if not myHero then return end
	if not enemy then return end

	local enemyRotation = Entity.GetRotation(enemy)
    	local enemyOrigin = Entity.GetAbsOrigin(enemy)
		enemyOrigin:SetZ(0)

	if enemyRotation and enemyOrigin then
			if not NPC.IsRunning(enemy) then
				return enemyOrigin + enemyRotation:GetForward():Normalized():Scaled(175)
			else return enemyOrigin:__add(enemyRotation:GetForward():Normalized():Scaled(FAIO.GetMoveSpeed(enemy) * (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetAvgLatency(Enum.Flow.FLOW_INCOMING) + 0.15) + 175))
			end
	end
end

function FAIO.magnusCombo(myHero, enemy)

	if not Menu.IsEnabled(FAIO.optionHeroMagnus) then return end
	if not NPC.IsEntityInRange(myHero, enemy, 3000)	then return end

	local shockwave = NPC.GetAbilityByIndex(myHero, 0)
    	local empower = NPC.GetAbilityByIndex(myHero, 1)
    	local skewer = NPC.GetAbilityByIndex(myHero, 2)
	local reversePolarity = NPC.GetAbility(myHero, "magnataur_reverse_polarity")

	local myMana = NPC.GetMana(myHero)
	local blink = NPC.GetItem(myHero, "item_blink", true)
	local refresher = NPC.GetItem(myHero, "item_refresher", true)

	FAIO.itemUsage(myHero, enemy)
	FAIO.magnusAutoUlt(myHero, myMana, skewer, reversePolarity, shockwave, blink, refresher)
	FAIO.magnusSkewerCombo(myHero, myMana, enemy, skewer, blink)

	if Menu.IsKeyDown(FAIO.optionComboKey) and Entity.GetHealth(enemy) > 0 and FAIO.heroCanCastSpells(myHero, enemy) == true and not Menu.IsKeyDown(FAIO.optionHeroMagnuscomboKeyAltSkewer) and not Menu.IsKeyDown(FAIO.optionHeroMagnuscomboKeyAltRP) then
		if not NPC.IsEntityInRange(myHero, enemy, 600) then
			if blink and Ability.IsReady(blink) then
				if NPC.IsEntityInRange(myHero, enemy, 1150) then
					Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy))
					return
				end
			end
			if Menu.IsEnabled(FAIO.optionHeroMagnusInitiateSkewer) then
				if not blink or (blink and not Ability.IsReady(blink)) then
					if skewer and Ability.IsCastable(skewer, myMana) then
						if NPC.IsEntityInRange(myHero, enemy, Ability.GetLevelSpecialValueFor(skewer, "range")) then
							Ability.CastPosition(skewer, Entity.GetAbsOrigin(enemy))
							return
						end
					end
				end
			end
		end

		if not NPC.HasModifier(myHero, "modifier_magnataur_empower") then
			FAIO.magnusAutoEmpower(myHero)
			return
		end
		if shockwave and Ability.IsCastable(shockwave, myMana) and Menu.IsEnabled(FAIO.optionHeroMagnusShockwaveInCombo) then
			if NPC.IsEntityInRange(myHero, enemy, 800) and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
				local shockwavePrediction = Ability.GetCastPoint(shockwave) + (Entity.GetAbsOrigin(enemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1050) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
				Ability.CastPosition(shockwave, FAIO.castLinearPrediction(myHero, enemy, shockwavePrediction))
				return
			end
		end
	FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	end

	if Menu.IsKeyDown(FAIO.optionComboKey) and Menu.IsKeyDown(FAIO.optionHeroMagnuscomboKeyAltSkewer) and Entity.GetHealth(enemy) > 0 and FAIO.heroCanCastSpells(myHero, enemy) == true then
		if blink and not NPC.IsEntityInRange(myHero, enemy, 125) then
			if blink and Ability.IsReady(blink) then
				if NPC.IsEntityInRange(myHero, enemy, 1120) then
					if Menu.GetValue(FAIO.optionHeroMagnusJump) == 0 then
						FAIO.magnusLastPos = Entity.GetAbsOrigin(myHero)
						local distance = (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D()
							if distance > 1100 then
								distance = 1100
							end
						Ability.CastPosition(blink, Entity.GetAbsOrigin(myHero) + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(distance + 55))
						return
					else
						FAIO.magnusLastPos = Entity.GetAbsOrigin(myHero)
						local bestPos = FAIO.getBestPosition(Wrap.HInRadius(Entity.GetAbsOrigin(enemy), 280, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY), 140)
						if bestPos ~= nil then
							local distance = (bestPos - Entity.GetAbsOrigin(myHero)):Length2D()
								if distance > 1100 then
									distance = 1100
								end
							Ability.CastPosition(blink, Entity.GetAbsOrigin(myHero) + (bestPos - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(distance + 55))
							return
						end
					end
				end
			end
		else
			if skewer and Ability.IsCastable(skewer, myMana) then
				if Menu.GetValue(FAIO.optionHeroMagnusReturn) == 0 then
					if blink and Ability.SecondsSinceLastUse(blink) > -1 and Ability.SecondsSinceLastUse(blink) < 0.25 then
						Ability.CastPosition(skewer, FAIO.magnusLastPos)
						return
					else
						local pos = Entity.GetAbsOrigin(myHero) + (Input.GetWorldCursorPos() - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(math.floor(Ability.GetLevelSpecialValueFor(skewer, "range")*0.9))
						Ability.CastPosition(skewer, pos)
						return
					end
				else
					local pos = Entity.GetAbsOrigin(myHero) + (Input.GetWorldCursorPos() - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(math.floor(Ability.GetLevelSpecialValueFor(skewer, "range")*0.9))
					Ability.CastPosition(skewer, pos)
					return
				end
			end
		end

		if not NPC.HasModifier(myHero, "modifier_magnataur_empower") then
			FAIO.magnusAutoEmpower(myHero)
			return
		end
		if shockwave and Ability.IsCastable(shockwave, myMana) and Menu.IsEnabled(FAIO.optionHeroMagnusShockwaveInCombo) then
			if NPC.IsEntityInRange(myHero, enemy, 800) and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
				local shockwavePrediction = Ability.GetCastPoint(shockwave) + (Entity.GetAbsOrigin(enemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1050) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
				Ability.CastPosition(shockwave, FAIO.castLinearPrediction(myHero, enemy, shockwavePrediction))
				return
			end
		end

	FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	end
					
	if Menu.IsKeyDown(FAIO.optionComboKey) and Menu.IsKeyDown(FAIO.optionHeroMagnuscomboKeyAltRP) and Entity.GetHealth(enemy) > 0 and FAIO.heroCanCastSpells(myHero, enemy) == true then
		local gapCloser = blink
			if gapCloser and not Ability.IsReady(gapCloser) then
				if Ability.SecondsSinceLastUse(gapCloser) > 1.5 then
					if Menu.IsEnabled(FAIO.optionHeroMagnusInitiateSkewer) then
						gapCloser = skewer
					end
				end
			end
			if not gapCloser then
				if Menu.IsEnabled(FAIO.optionHeroMagnusInitiateSkewer) then
					gapCloser = skewer
				end
			end
		local gapCloserRange = 1150
			if gapCloser then
				if Ability.GetName(gapCloser) == "magnataur_skewer" then
					gapCloserRange = Ability.GetLevelSpecialValueFor(gapCloser, "range") - 25
				end
			end

		if not NPC.IsEntityInRange(myHero, enemy, 400) then
			if gapCloser and Ability.IsCastable(gapCloser, myMana) then
				local bestPos = FAIO.getBestPosition(Wrap.HInRadius(Entity.GetAbsOrigin(enemy), 820, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY), 410)
				if bestPos ~= nil and NPC.IsPositionInRange(myHero, bestPos, gapCloserRange, 0) then
					if Ability.IsCastable(reversePolarity, myMana) and not Ability.IsInAbilityPhase(reversePolarity) then
						if not NPC.HasModifier(myHero, "modifier_magnataur_empower") then
							FAIO.magnusAutoEmpower(myHero)
							return
						end
						if Ability.IsReady(gapCloser) and Ability.IsCastable(gapCloser, myMana) then
							FAIO.magnusLastPos = Entity.GetAbsOrigin(myHero)
							Ability.CastPosition(gapCloser, bestPos)
							return
						end
					end
				end
			end
		else
			if reversePolarity and Ability.IsCastable(reversePolarity, myMana) then
				if Menu.GetValue(FAIO.optionHeroMagnusReturn) == 0 then
					if not FAIO.AmIFacingPos(myHero, FAIO.magnusLastPos, 15) and gapCloser and Ability.GetName(gapCloser) == "item_blink" and Menu.IsEnabled(FAIO.optionHeroMagnusSkewerInCombo) then
						NPC.MoveTo(myHero, Entity.GetAbsOrigin(myHero) + (FAIO.magnusLastPos - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(5), false, false)
						return
					else
						Ability.CastNoTarget(reversePolarity)
						return
					end
				end
				if Menu.GetValue(FAIO.optionHeroMagnusReturn) == 1 then
					if not FAIO.AmIFacingPos(myHero, Input.GetWorldCursorPos(), 15) and gapCloser and Ability.GetName(gapCloser) == "item_blink" and Menu.IsEnabled(FAIO.optionHeroMagnusSkewerInCombo) then
						NPC.MoveTo(myHero, Entity.GetAbsOrigin(myHero) + (Input.GetWorldCursorPos() - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(5), false, false)
						return
					else
						Ability.CastNoTarget(reversePolarity)
						return
					end
				end
			end
			if reversePolarity and not Ability.IsReady(reversePolarity) then
				if gapCloser and Ability.GetName(gapCloser) == "item_blink" and Menu.IsEnabled(FAIO.optionHeroMagnusSkewerInCombo) then
					if Ability.SecondsSinceLastUse(reversePolarity) > -1 and Ability.SecondsSinceLastUse(reversePolarity) < 1.5 then
						if skewer and Ability.IsCastable(skewer, myMana) and not Ability.IsReady(reversePolarity) and (not refresher or (refresher and Ability.IsReady(refresher))) then
							if Menu.GetValue(FAIO.optionHeroMagnusReturn) == 0 then
								Ability.CastPosition(skewer, FAIO.magnusLastPos)
								return
							else
								local pos = Entity.GetAbsOrigin(myHero) + (Input.GetWorldCursorPos() - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(math.floor(Ability.GetLevelSpecialValueFor(skewer, "range")*0.9))
								Ability.CastPosition(skewer, pos)
								return
							end
						end
					end
				end
				if shockwave and Ability.IsCastable(shockwave, myMana) and Menu.IsEnabled(FAIO.optionHeroMagnusShockwaveInCombo) then
					Ability.CastPosition(shockwave, Entity.GetAbsOrigin(enemy))
					return
				end
				if Menu.IsEnabled(FAIO.optionHeroMagnusComboRefresher) then
					if refresher and Ability.IsCastable(refresher, myMana) and myMana > (Ability.GetManaCost(reversePolarity) + Ability.GetManaCost(refresher)) then
						local stunTime = Ability.GetLevelSpecialValueForFloat(reversePolarity, "hero_stun_duration")
						if Ability.SecondsSinceLastUse(reversePolarity) > (stunTime - 0.5) and Ability.SecondsSinceLastUse(reversePolarity) < stunTime then
							Ability.CastNoTarget(refresher)
							Ability.CastNoTarget(reversePolarity)
							return
						end
					end
				end
			end
		end
	FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	end
	

	


end

function FAIO.magnusSkewerCombo(myHero, myMana, enemy, skewer, blink)

	if not myHero then return end
	if not enemy then return end

	if not Menu.IsEnabled(FAIO.optionHeroMagnusSkewerCombo) then return end

	if not blink then return end

	if not skewer then return end
		if not Ability.IsCastable(skewer, myMana) then return end

	if FAIO.heroCanCastSpells(myHero, enemy) == false then return end
	if FAIO.isHeroChannelling(myHero) == true then return end

	if Menu.IsKeyDown(FAIO.optionHeroMagnusSkewerComboKey) and Entity.GetHealth(enemy) > 0 then
		if NPC.IsEntityInRange(myHero, enemy, 1100) then
			if blink and Ability.IsReady(blink) then
				FAIO.magnusLastPos = Entity.GetAbsOrigin(myHero)
				local distance = (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D()
					if distance > 1100 then
						distance = 1100
					end
				Ability.CastPosition(blink, Entity.GetAbsOrigin(myHero) + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(distance + 95))
				return
			end
			if Ability.SecondsSinceLastUse(blink) > -1 and Ability.SecondsSinceLastUse(blink) < 0.25 then
				Ability.CastPosition(skewer, FAIO.magnusLastPos)
				return
			end
		end
	FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	end

end
			
function FAIO.magnusAutoEmpower(myHero)

	if not myHero then return end
	local myMana = NPC.GetMana(myHero)

	local empower = NPC.GetAbilityByIndex(myHero, 1)
		if not empower then return end
		if not Ability.IsCastable(empower, myMana) then return end

	if FAIO.heroCanCastSpells(myHero, enemy) == false then return end
	if FAIO.isHeroChannelling(myHero) == true then return end
	if FAIO.IsHeroInvisible(myHero) == true then return end

	if NPC.HasModifier(myHero, "modifier_magnataur_empower") then return end

	Ability.CastTarget(empower, myHero)
	return
	
end

function FAIO.magnusAutoUlt(myHero, myMana, skewer, reversePolarity, shockwave, blink, refresher)

	if not myHero then return end
	if not Menu.IsEnabled(FAIO.optionHeroMagnusAutoUlt) then return end

	if not reversePolarity then return end

	local shivas = NPC.GetItem(myHero, "item_shivas_guard", true)

	local gapCloser = blink
		if gapCloser and not Ability.IsReady(gapCloser) then
			if Ability.SecondsSinceLastUse(gapCloser) > 1.5 then
				if Menu.IsEnabled(FAIO.optionHeroMagnusAutoUltSkewer) then
					gapCloser = skewer
				end
			end
		end
		if not gapCloser then
			if Menu.IsEnabled(FAIO.optionHeroMagnusAutoUltSkewer) then
				gapCloser = skewer
			end
		end
		
	if not gapCloser then return end

	if FAIO.heroCanCastSpells(myHero, enemy) == false then return end
	if FAIO.isHeroChannelling(myHero) == true then return end

	local reverseRadius = 410

	local gapCloserRange = 1150
		if Ability.GetName(gapCloser) == "magnataur_skewer" then
			gapCloserRange = Ability.GetLevelSpecialValueFor(gapCloser, "range") - 25
		end

	local tempTableHittableTargets = {}
	for _, targets in ipairs(Wrap.HeroesInRadius(myHero, gapCloserRange + reverseRadius, Enum.TeamType.TEAM_ENEMY)) do
		if targets then
			local target = FAIO.targetChecker(targets)
			if target then
				if #Wrap.HeroesInRadius(target, reverseRadius, Enum.TeamType.TEAM_FRIEND) > -1 then
					table.insert(tempTableHittableTargets, target)
				end
			end
		end
	end

	if #tempTableHittableTargets >= 1 then
		local bestPos = FAIO.getBestPosition(tempTableHittableTargets, reverseRadius)
		if bestPos ~= nil and #Wrap.HInRadius(bestPos, reverseRadius, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY) >= Menu.GetValue(FAIO.optionHeroMagnusAutoUltCount) then
			if NPC.IsPositionInRange(myHero, bestPos, gapCloserRange, 0) then
				if Ability.IsCastable(reversePolarity, myMana) and not Ability.IsInAbilityPhase(reversePolarity) then
					if not NPC.HasModifier(myHero, "modifier_magnataur_empower") then
						FAIO.magnusAutoEmpower(myHero)
						return
					end
					if Ability.IsReady(gapCloser) and Ability.IsCastable(gapCloser, myMana) then
						FAIO.magnusLastPos = Entity.GetAbsOrigin(myHero)
						Ability.CastPosition(gapCloser, bestPos)
						return
					end
					if not FAIO.AmIFacingPos(myHero, FAIO.magnusLastPos, 15) and Ability.GetName(gapCloser) == "item_blink" then
						NPC.MoveTo(myHero, Entity.GetAbsOrigin(myHero) + (FAIO.magnusLastPos - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(5), false, false)
						return
					else
						Ability.CastNoTarget(reversePolarity)
						return
					end
				else
					if Ability.GetName(gapCloser) == "item_blink" then
						if Ability.SecondsSinceLastUse(reversePolarity) > -1 and Ability.SecondsSinceLastUse(reversePolarity) < 1.5 then
							if shivas and Ability.IsCastable(shivas, myMana) then
								Ability.CastNoTarget(shivas)
								return
							end
							if skewer and Ability.IsCastable(skewer, myMana) and not Ability.IsReady(reversePolarity) and (not refresher or (refresher and Ability.IsReady(refresher))) then
								Ability.CastPosition(skewer, FAIO.magnusLastPos)
								return
							end
							if shockwave and Ability.IsCastable(shockwave, myMana) then
								Ability.CastPosition(shockwave, Entity.GetAbsOrigin(myHero) + Entity.GetRotation(myHero):GetForward():Normalized():Scaled(50), true)
								return
							end
							FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_MOVE", nil, Entity.GetAbsOrigin(myHero))
							return
						end
					else
						if Ability.SecondsSinceLastUse(reversePolarity) > -1 and Ability.SecondsSinceLastUse(reversePolarity) < 1.5 then
							if shivas and Ability.IsCastable(shivas, myMana) then
								Ability.CastNoTarget(shivas)
								return
							end
							if shockwave and Ability.IsCastable(shockwave, myMana) and not Ability.IsReady(skewer) then
								Ability.CastPosition(shockwave, Entity.GetAbsOrigin(myHero) + Entity.GetRotation(myHero):GetForward():Normalized():Scaled(50), true)
								return
							end
							FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_MOVE", nil, Entity.GetAbsOrigin(myHero))
							return
						end
					end
					if Menu.IsEnabled(FAIO.optionHeroMagnusAutoUltRefresher) then
						if refresher and Ability.IsCastable(refresher, myMana) and myMana > (Ability.GetManaCost(reversePolarity) + Ability.GetManaCost(refresher)) then
							local stunTime = Ability.GetLevelSpecialValueForFloat(reversePolarity, "hero_stun_duration")
							if Ability.SecondsSinceLastUse(reversePolarity) > (stunTime - 0.5) and Ability.SecondsSinceLastUse(reversePolarity) < stunTime then
								Ability.CastNoTarget(refresher)
								Ability.CastNoTarget(reversePolarity)
								return
							end
						end
					end
				end
			end
		end
	end

end

function FAIO.AmIFacingPos(myHero, pos, allowedDeviation)

	if not myHero then return false end

	local myPos = Entity.GetAbsOrigin(myHero)
	local myRotation = Entity.GetRotation(myHero):GetForward():Normalized()

	local baseVec = (pos - myPos):Normalized()

	local tempProcessing = baseVec:Dot2D(myRotation) / (baseVec:Length2D() * myRotation:Length2D())
		if tempProcessing > 1 then
			tempProcessing = 1
		end	

	local checkAngleRad = math.acos(tempProcessing)
	local checkAngle = (180 / math.pi) * checkAngleRad

	if checkAngle < allowedDeviation then
		return true
	end

	return false

end

function FAIO.DazzleHelper(myHero, enemy)

	if not Menu.IsEnabled(FAIO.optionHeroDazzle) then return end
	if not NPC.IsEntityInRange(myHero, enemy, 3000)	then return end

	local poisonTouch = NPC.GetAbilityByIndex(myHero, 0)
    	local grave = NPC.GetAbilityByIndex(myHero, 1)
    	local shadowWave = NPC.GetAbilityByIndex(myHero, 2)
	local weave = NPC.GetAbility(myHero, "dazzle_weave")

	local myMana = NPC.GetMana(myHero)
	local blink = NPC.GetItem(myHero, "item_blink", true)

	FAIO.itemUsage(myHero, enemy)
	FAIO.DazzleHelperAutoGrave(myHero, myMana, grave)
	FAIO.DazzleHelperAutoWeave(myHero, myMana, weave)
	FAIO.DazzleHelperAutoHeal(myHero, myMana, shadowWave)
	FAIO.DazzleHelperHealKillsteal(myHero, myMana, shadowWave)

	if Menu.IsKeyDown(FAIO.optionComboKey) and Entity.GetHealth(enemy) > 0 then

		if not NPC.IsEntityInRange(myHero, enemy, 999) then
			if blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1550) then
				Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(400)))
				return
			end
		end

		if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and FAIO.heroCanCastSpells(myHero, enemy) == true then
			if poisonTouch and Ability.IsCastable(poisonTouch, myMana) then
				Ability.CastTarget(poisonTouch, enemy)
				return
			end
		end

	FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	end

end

function FAIO.DazzleHelperHealKillsteal(myHero, myMana, shadowWave)

	if not myHero then return end
	if not Menu.IsEnabled(FAIO.optionHeroDazzleHealKS) then return end

	if not shadowWave then return end
		if not Ability.IsCastable(shadowWave, myMana) then return end

	if FAIO.heroCanCastSpells(myHero, enemy) == false then return end
	if FAIO.isHeroChannelling(myHero) == true then return end
	if FAIO.IsHeroInvisible(myHero) == true then return end

	local bounces = 2 + Ability.GetLevel(shadowWave)
	local bounceDamage = Ability.GetLevelSpecialValueFor(shadowWave, "damage")
		if NPC.HasAbility(myHero, "special_bonus_unique_dazzle_2") then
			if Ability.GetLevel(NPC.GetAbility(myHero, "special_bonus_unique_dazzle_2")) > 0 then
				bounceDamage = bounceDamage + 60
			end
		end

	local waveRange = Ability.GetCastRange(shadowWave) + NPC.GetCastRangeBonus(myHero) - 10

	for _, targets in ipairs(Wrap.HeroesInRadius(myHero, waveRange, Enum.TeamType.TEAM_ENEMY)) do
		if targets then
			local target = FAIO.targetChecker(targets)
			if target then
				if not NPC.HasState(target, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and not NPC.HasModifier(target, "modifier_templar_assassin_refraction_absorb") then
					local targetHP = Entity.GetHealth(target) + NPC.GetHealthRegen(target)
					local unitsAround = #Wrap.UnitsInRadius(target, 175, Enum.TeamType.TEAM_ENEMY)
						if unitsAround > bounces then
							unitsAround = bounces
						end
					local waveDamage = unitsAround * bounceDamage
					local waveTrueDamage = (1 - NPC.GetMagicalArmorValue(target)) * (waveDamage + waveDamage * (Hero.GetIntellectTotal(myHero) / 14 / 100))
					if targetHP < waveTrueDamage then
						for _, v in ipairs(Wrap.UnitsInRadius(target, 175, Enum.TeamType.TEAM_ENEMY)) do
							if v then
								if NPC.IsEntityInRange(myHero, v, waveRange) then
									Ability.CastTarget(shadowWave, v)
									break
									return
								end
							end
						end
					end
				end
			end
		end
	end
					
end

function FAIO.DazzleHelperAutoHeal(myHero, myMana, shadowWave)

	if not myHero then return end
	if not Menu.IsEnabled(FAIO.optionHeroDazzleAutoHeal) then return end

	if not shadowWave then return end
		if not Ability.IsCastable(shadowWave, myMana) then return end

	if FAIO.heroCanCastSpells(myHero, enemy) == false then return end
	if FAIO.isHeroChannelling(myHero) == true then return end
	if FAIO.IsHeroInvisible(myHero) == true then return end

	local myHPperc = (Entity.GetHealth(myHero) / Entity.GetMaxHealth(myHero)) * 100
	local waveRange = Ability.GetCastRange(shadowWave) + NPC.GetCastRangeBonus(myHero) - 10

	if FAIO.TargetIsInvulnarable(myHero, myHero) <= 0 then
		if myHPperc <= Menu.GetValue(FAIO.optionHeroDazzleAutoHealHP) then
			Ability.CastTarget(shadowWave, myHero)
			return
		end
	end

	for _, ally in ipairs(Wrap.HeroesInRadius(myHero, waveRange, Enum.TeamType.TEAM_FRIEND)) do
		if ally and not NPC.IsIllusion(ally) and Wrap.EIsAlive(ally) and FAIO.TargetIsInvulnarable(myHero, ally) <= 0 and FAIO.TargetIsInvulnarable(myHero, myHero) <= 0 then
			local allyHPperc = (Entity.GetHealth(ally) / Entity.GetMaxHealth(ally)) * 100
			if allyHPperc <= Menu.GetValue(FAIO.optionHeroDazzleAutoHealHP) then
				Ability.CastTarget(shadowWave, ally)
				break
				return
			end
		end
	end

end

function FAIO.DazzleHelperAutoWeave(myHero, myMana, weave)

	if not myHero then return end
	if not Menu.IsEnabled(FAIO.optionHeroDazzleAutoWeave) then return end

	if not weave then return end
		if not Ability.IsCastable(weave, myMana) then return end

	if FAIO.heroCanCastSpells(myHero, enemy) == false then return end
	if FAIO.isHeroChannelling(myHero) == true then return end
	if FAIO.IsHeroInvisible(myHero) == true then return end

	local weaveRange = Ability.GetCastRange(weave) + NPC.GetCastRangeBonus(myHero) - 10
	local weaveRadius = 550

	local tempTableHittableTargets = {}
	for _, targets in ipairs(Wrap.HeroesInRadius(myHero, 2000, Enum.TeamType.TEAM_ENEMY)) do
		if targets then
			local target = FAIO.targetChecker(targets)
			if target then
				if not NPC.HasState(target, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
					if NPC.IsEntityInRange(myHero, target, weaveRange + weaveRadius) then
						if #Wrap.HeroesInRadius(target, weaveRadius, Enum.TeamType.TEAM_FRIEND) > -1 then
							table.insert(tempTableHittableTargets, target)
						end
					end
				end
			end
		end
	end

	if #tempTableHittableTargets >= 1 then
		local bestPos = FAIO.getBestPosition(tempTableHittableTargets, weaveRadius)
		if bestPos ~= nil and #Wrap.HInRadius(bestPos, weaveRadius, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY) >= Menu.GetValue(FAIO.optionHeroDazzleAutoWeaveCount) then
			if NPC.IsPositionInRange(myHero, bestPos, weaveRange, 0) then
				Ability.CastPosition(weave, bestPos)
				return
			end
		end
	end

end

function FAIO.DazzleHelperAutoGrave(myHero, myMana, grave)

	if not myHero then return end
	if not Menu.IsEnabled(FAIO.optionHeroDazzleAutoGrave) then return end

	if not grave then return end
		if not Ability.IsCastable(grave, myMana) then return end

	if FAIO.heroCanCastSpells(myHero, enemy) == false then return end
	if FAIO.isHeroChannelling(myHero) == true then return end

	local myHPperc = (Entity.GetHealth(myHero) / Entity.GetMaxHealth(myHero)) * 100
	local graveRange = Ability.GetCastRange(grave) + NPC.GetCastRangeBonus(myHero) - 10

	if FAIO.TargetIsInvulnarable(myHero, myHero) <= 0 then
		if myHPperc <= Menu.GetValue(FAIO.optionHeroDazzleHP) then
			if FAIO.IsAttackedByDangerousSpell(myHero, myHero, 1000) == true then
				Ability.CastTarget(grave, myHero)
				return
			else
				for _, v in ipairs(Wrap.HeroesInRadius(myHero, 800, Enum.TeamType.TEAM_ENEMY)) do
					if v and Entity.IsHero(v) and not Entity.IsDormant(v) and not NPC.IsIllusion(v) then
						if NPC.IsAttacking(v) then
							if NPC.IsEntityInRange(myHero, v, NPC.GetAttackRange(v) + 140) then
								if NPC.FindFacingNPC(v) == myHero then
									Ability.CastTarget(grave, myHero)
									break
									return
								end
							end
						else
							if myHPperc <= 7 then
								if NPC.IsEntityInRange(myHero, v, NPC.GetAttackRange(v) + 140) then
									if NPC.FindFacingNPC(v) == myHero then
										Ability.CastTarget(grave, myHero)
										break
										return
									end
								end
							end
						end	
					end	
				end
			end	
		end
	end

	for _, ally in ipairs(Wrap.HeroesInRadius(myHero, graveRange, Enum.TeamType.TEAM_FRIEND)) do
		if ally and not NPC.IsIllusion(ally) and Wrap.EIsAlive(ally) and FAIO.TargetIsInvulnarable(myHero, ally) <= 0 and FAIO.TargetIsInvulnarable(myHero, myHero) <= 0 then
			local allyHPperc = (Entity.GetHealth(ally) / Entity.GetMaxHealth(ally)) * 100
			if allyHPperc <= Menu.GetValue(FAIO.optionHeroDazzleHP) then
				if FAIO.IsAttackedByDangerousSpell(myHero, ally, 800) == true then
					Ability.CastTarget(grave, ally)
					break
					return
				else
					for _, v in ipairs(Wrap.HeroesInRadius(ally, 800, Enum.TeamType.TEAM_ENEMY)) do
						if v and Entity.IsHero(v) and not Entity.IsDormant(v) and not NPC.IsIllusion(v) then
							if NPC.IsAttacking(v) then
								if NPC.IsEntityInRange(ally, v, NPC.GetAttackRange(v) + 140) then
									if NPC.FindFacingNPC(v) == ally then
										Ability.CastTarget(grave, ally)
										break
										return
									end
								end
							else
								if allyHPperc <= 7 then
									if NPC.IsEntityInRange(ally, v, NPC.GetAttackRange(v) + 140) then
										if NPC.FindFacingNPC(v) == ally then
											Ability.CastTarget(grave, ally)
											break
											return
										end
									end
								end
							end	
						end
					end
				end
			else
				if NPC.HasModifier(ally, "modifier_necrolyte_reapers_scythe") then
					if allyHPperc < 60 then
						Ability.CastTarget(grave, ally)
						break
						return
					end
				end
			end
		end
	end

end

function FAIO.IsAttackedByDangerousSpell(myHero, target, searchRange)

	if not myHero then return false end
	if not target then return false end
	if FAIO.TargetIsInvulnarable(myHero, target) > 0 then return false end

	for _, enemy in ipairs(Wrap.HeroesInRadius(target, searchRange, Enum.TeamType.TEAM_ENEMY)) do
		if enemy and Entity.IsHero(enemy) and not Entity.IsDormant(enemy) and not NPC.IsIllusion(enemy) then
			if NPC.FindFacingNPC(enemy) == target then
				for _, info in ipairs(FAIO.AbilityList) do
					if info[1] == NPC.GetUnitName(enemy) then
						if info[3] == "nuke" or info[3] == "disable" then
							if NPC.HasAbility(enemy, info[2]) then
								if Ability.IsInAbilityPhase(NPC.GetAbility(enemy, info[2])) then
									local castRange = Ability.GetCastRange(NPC.GetAbility(enemy, info[2])) + NPC.GetCastRangeBonus(enemy) + 25
									if NPC.IsEntityInRange(enemy, target, castRange) then
										return true
									end
								end
							end
						end
					end
				end
			end
		end
	end

	return false

end

function FAIO.SFCombo(myHero, enemy)

	if not Menu.IsEnabled(FAIO.optionHeroSF) then return end

	local razeShort = NPC.GetAbilityByIndex(myHero, 0)
    	local razeMid = NPC.GetAbilityByIndex(myHero, 1)
    	local razeLong = NPC.GetAbilityByIndex(myHero, 2)
	local requiem = NPC.GetAbility(myHero, "nevermore_requiem")
	local myMana = NPC.GetMana(myHero)

	local blink = NPC.GetItem(myHero, "item_blink", true)
	local eul = NPC.GetItem(myHero, "item_cyclone", true)

	FAIO.itemUsage(myHero, enemy)
	FAIO.SFComboDrawRazeCircles(myHero)

	if enemy then
		if eul and requiem and Ability.IsCastable(requiem, myMana) then
			if Menu.IsKeyDown(FAIO.optionHeroSFEulCombo) and Entity.GetHealth(enemy) > 0 then
				if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and FAIO.heroCanCastSpells(myHero, enemy) == true then
					local possibleRange = 0.80 * NPC.GetMoveSpeed(myHero)
					if not NPC.IsEntityInRange(myHero, enemy, possibleRange) then
						if blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1175 + 0.75 * possibleRange) then
							Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(0.75 * possibleRange)))
							return
						else
							FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Entity.GetAbsOrigin(enemy))
							return
						end
					else
						if NPC.IsLinkensProtected(enemy) then
							if FAIO.ItemSleepReady(0.05) and FAIO.LinkensBreakerNew(myHero) ~= nil then
								Ability.CastTarget(NPC.GetItem(myHero, FAIO.LinkensBreakerNew(myHero), true), enemy)
								return
							end
						end

						if Ability.IsCastable(eul, myMana) then
							Ability.CastTarget(eul, enemy)
							return
						end
						if NPC.HasModifier(enemy, "modifier_eul_cyclone") then
							if not NPC.IsEntityInRange(myHero, enemy, 20) then
								FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Entity.GetAbsOrigin(enemy))
								return
							else
								local cycloneDieTime = Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_eul_cyclone"))
								if cycloneDieTime - GameRules.GetGameTime() <= 1.66 then
									Ability.CastNoTarget(requiem)
									return
								end
							end
						end
					end	
				end
			end
		end
	end

	if enemy then
		if Menu.IsKeyDown(FAIO.optionComboKey) and Entity.GetHealth(enemy) > 0 then
			if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and FAIO.heroCanCastSpells(myHero, enemy) == true then
				if not NPC.IsEntityInRange(myHero, enemy, 999) then
					if Menu.IsEnabled(FAIO.optionHeroSFBlink) and blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1150 + Menu.GetValue(FAIO.optionHeroSFBlinkRange)) then
						Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(Menu.GetValue(FAIO.optionHeroSFBlinkRange))))
						return
					end
				end

				if Menu.IsEnabled(FAIO.optionHeroSFComboRaze) then
					if razeShort and Ability.IsCastable(razeShort, myMana) then
						local razePos = Entity.GetAbsOrigin(myHero) + Entity.GetRotation(myHero):GetForward():Normalized():Scaled(200)
						local razePrediction = 0.55 + 0.1 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)			
						local predictedPos = FAIO.castPrediction(myHero, enemy, razePrediction)
						local disRazePOSpredictedPOS = (razePos - predictedPos):Length2D()
						if disRazePOSpredictedPOS <= 200 and not NPC.IsTurning(myHero) then
							if os.clock() - FAIO.lastTick >= 0.55 then
								Ability.CastNoTarget(razeShort)
								FAIO.lastTick = os.clock()
								return
							end
						end
					end
					if razeMid and Ability.IsCastable(razeMid, myMana) then
						local razePos = Entity.GetAbsOrigin(myHero) + Entity.GetRotation(myHero):GetForward():Normalized():Scaled(450)
						local razePrediction = 0.55 + 0.1 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)			
						local predictedPos = FAIO.castPrediction(myHero, enemy, razePrediction)
						local disRazePOSpredictedPOS = (razePos - predictedPos):Length2D()
						if disRazePOSpredictedPOS <= 200 and not NPC.IsTurning(myHero) then
							if os.clock() - FAIO.lastTick >= 0.55 then
								Ability.CastNoTarget(razeMid)
								FAIO.lastTick = os.clock()
								return
							end
						end
					end
					if razeLong and Ability.IsCastable(razeLong, myMana) then
						local razePos = Entity.GetAbsOrigin(myHero) + Entity.GetRotation(myHero):GetForward():Normalized():Scaled(700)
						local razePrediction = 0.55 + 0.1 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)			
						local predictedPos = FAIO.castPrediction(myHero, enemy, razePrediction)
						local disRazePOSpredictedPOS = (razePos - predictedPos):Length2D()
						if disRazePOSpredictedPOS <= 200 and not NPC.IsTurning(myHero) then
							if os.clock() - FAIO.lastTick >= 0.55 then
								Ability.CastNoTarget(razeLong)
								FAIO.lastTick = os.clock()
								return
							end
						end
					end
				end
			end
		FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
		return
		end
	end

end

function FAIO.SFComboDrawRazeCircles(myHero)

	if not myHero then return end

	local curtime = GameRules.GetGameTime()	

	if Menu.IsEnabled(FAIO.optionHeroSFDrawRazeCircle) then
		
		if FAIO.SFcurrentParticle1 == 0 then
			local circle1 = Particle.Create("particles/econ/generic/generic_progress_meter/generic_progress_circle_b.vpcf")
			FAIO.SFcurrentParticle1 = circle1
			Particle.SetControlPoint(circle1, 1, Vector(250, 1, 1))
			Particle.SetControlPoint(circle1, 15, Vector(0, 255, 0))
			Particle.SetControlPoint(circle1, 16, Vector(1, 0, 0))
		end
		if FAIO.SFcurrentParticle2 == 0 then
			local circle2 = Particle.Create("particles/econ/generic/generic_progress_meter/generic_progress_circle_b.vpcf")
			FAIO.SFcurrentParticle2 = circle2
			Particle.SetControlPoint(circle2, 1, Vector(250, 1, 1))
			Particle.SetControlPoint(circle2, 15, Vector(255, 255, 0))
			Particle.SetControlPoint(circle2, 16, Vector(1, 0, 0))
		end
		if FAIO.SFcurrentParticle3 == 0 then
			local circle3 = Particle.Create("particles/econ/generic/generic_progress_meter/generic_progress_circle_b.vpcf")
			FAIO.SFcurrentParticle3 = circle3
			Particle.SetControlPoint(circle3, 1, Vector(250, 1, 1))
			Particle.SetControlPoint(circle3, 15, Vector(255, 100, 0))
			Particle.SetControlPoint(circle3, 16, Vector(1, 0, 0))
		end

		if os.clock() - FAIO.SFParticleUpdateTime >= 0.033 then
			Particle.SetControlPoint(FAIO.SFcurrentParticle1, 0, (Entity.GetAbsOrigin(myHero) + Entity.GetRotation(myHero):GetForward():Normalized():Scaled(200)))
			Particle.SetControlPoint(FAIO.SFcurrentParticle2, 0, (Entity.GetAbsOrigin(myHero) + Entity.GetRotation(myHero):GetForward():Normalized():Scaled(450)))
			Particle.SetControlPoint(FAIO.SFcurrentParticle3, 0, (Entity.GetAbsOrigin(myHero) + Entity.GetRotation(myHero):GetForward():Normalized():Scaled(700)))
			FAIO.SFParticleUpdateTime = os.clock()
		end
			
	else
		if FAIO.SFcurrentParticle1 > 0 then
			Particle.Destroy(FAIO.SFcurrentParticle1)
			Particle.Destroy(FAIO.SFcurrentParticle2)
			Particle.Destroy(FAIO.SFcurrentParticle3)
			FAIO.SFcurrentParticle1 = 0
			FAIO.SFcurrentParticle2 = 0
			FAIO.SFcurrentParticle3 = 0
		end
	end

end

function FAIO.SFComboDrawRequiemDamage(myHero)

	if not myHero then return end
	if not Menu.IsEnabled(FAIO.optionHeroSFDrawReqDMG) then return end

	local enemy = FAIO.targetChecker(Input.GetNearestHeroToCursor(Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY))
		if not enemy then return end
		if not NPC.IsPositionInRange(enemy, Input.GetWorldCursorPos(), 500, 0) then return end

	local pos = Entity.GetAbsOrigin(enemy)
	local posY = NPC.GetHealthBarOffset(enemy)
		pos:SetZ(pos:GetZ() + posY)
			
	local x, y, visible = Renderer.WorldToScreen(pos)

	local requiem = NPC.GetAbility(myHero, "nevermore_requiem")
	local myMana = NPC.GetMana(myHero)

	local stackCounter = 0
		if NPC.HasModifier(myHero, "modifier_nevermore_necromastery") then
			stackCounter = Modifier.GetStackCount(NPC.GetModifier(myHero, "modifier_nevermore_necromastery"))
		end

	local aghanims = NPC.GetItem(myHero, "item_ultimate_scepter", true)

	local requiemDamage = Ability.GetDamage(requiem) * (math.floor(stackCounter/2))
		if aghanims or NPC.HasModifier(myHero, "modifier_item_ultimate_scepter_consumed") then
			requiemDamage = requiemDamage + Ability.GetLevelSpecialValueForFloat(requiem, "requiem_damage_pct_scepter") * (math.floor(stackCounter/2))
		end
	local requiemTrueDamage = (1 - NPC.GetMagicalArmorValue(enemy)) * (requiemDamage + requiemDamage * (Hero.GetIntellectTotal(myHero) / 14 / 100))

	local remainingHP = math.floor(Entity.GetHealth(enemy) - requiemTrueDamage)
		if remainingHP < 0 then
			remainingHP = 0
		end

	if requiem and Ability.IsCastable(requiem, myMana) then
		if visible then
			if Entity.GetHealth(enemy) > requiemTrueDamage then
				Renderer.SetDrawColor(255,102,102,255)
			else
				Renderer.SetDrawColor(50,205,50,255)
			end
			Renderer.DrawText(FAIO.skywrathFont, x-60, y-70, "Full requiem hit:   " .. math.floor(requiemTrueDamage) .. "  (" .. remainingHP .. ")", 0)
		end
	end	

end

function FAIO.WillowCombo(myHero, enemy)

	if not Menu.IsEnabled(FAIO.optionHeroWillow) then return end
	if not NPC.IsEntityInRange(myHero, enemy, 3000)	then return end

	local maze = NPC.GetAbilityByIndex(myHero, 0)
    	local shadowRealm = NPC.GetAbilityByIndex(myHero, 1)
	local cursedCrown = NPC.GetAbilityByIndex(myHero, 2)
    	local bedlam = NPC.GetAbility(myHero, "dark_willow_bedlam")

	local myMana = NPC.GetMana(myHero)

	local blink = NPC.GetItem(myHero, "item_blink", true)
	local euls = NPC.GetItem(myHero, "item_cyclone", true)
	local atos = NPC.GetItem(myHero, "item_rod_of_atos", true)

	FAIO.itemUsage(myHero, enemy)

	local comboRange = 800
		if cursedCrown then
			comboRange = Ability.GetCastRange(cursedCrown)
		end

	if Menu.IsKeyDown(FAIO.optionComboKey) and Entity.GetHealth(enemy) > 0 then
		if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and FAIO.heroCanCastSpells(myHero, enemy) == true then
			if not NPC.IsEntityInRange(myHero, enemy, 900) then
				if Menu.IsEnabled(FAIO.optionHeroWillowBlink) and blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1150 + Menu.GetValue(FAIO.optionHeroWillowBlinkRange)) then
					Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(Menu.GetValue(FAIO.optionHeroWillowBlinkRange))))
					return
				end
			else
				if cursedCrown and Ability.IsCastable(cursedCrown, myMana) then
					Ability.CastTarget(cursedCrown, enemy)
					FAIO.lastTick = os.clock()
					return
				end
				if FAIO.SleepReady(0.1) and shadowRealm and Ability.IsCastable(shadowRealm, myMana) then
					Ability.CastNoTarget(shadowRealm)
					FAIO.lastTick = os.clock()
					return
				end
				if euls then
					if FAIO.SleepReady(0.1) and Ability.IsCastable(euls, myMana) then
						Ability.CastTarget(euls, enemy)
						FAIO.lastTick = os.clock()
						return
					end
					if Ability.SecondsSinceLastUse(euls) > -1 and Ability.SecondsSinceLastUse(euls) < 0.5 then
						if maze and Ability.IsCastable(maze, myMana) then
							local bestPos = FAIO.getBestPosition(Wrap.HInRadius(Entity.GetAbsOrigin(enemy), 850, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY), 425)
							if bestPos ~= nil then
								Ability.CastPosition(maze, bestPos)
								FAIO.lastTick = os.clock()
								return
							end
						end
					end
					if bedlam and Ability.IsCastable(bedlam, myMana) then
						if NPC.IsEntityInRange(myHero, enemy, 150) and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_INVULNERABLE) then
							Ability.CastNoTarget(bedlam)
							FAIO.lastTick = os.clock()
							return
						end
					end
				else
					if atos then
						if FAIO.SleepReady(0.1) and Ability.IsCastable(atos, myMana) then
							Ability.CastTarget(atos, enemy)
							FAIO.lastTick = os.clock()
							return
						end
						if FAIO.SleepReady(0.1) and bedlam and Ability.IsCastable(bedlam, myMana) then
							if NPC.IsEntityInRange(myHero, enemy, 150) and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_INVULNERABLE) then
								Ability.CastNoTarget(bedlam)
								FAIO.lastTick = os.clock()
								return
							end
						end
						if NPC.HasModifier(enemy, "modifier_rod_of_atos_debuff") then
							local dieTime = Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_rod_of_atos_debuff"))
							if dieTime - GameRules.GetGameTime() < 0.1 then
								if FAIO.SleepReady(0.1) and maze and Ability.IsCastable(maze, myMana) then
									local bestPos = FAIO.getBestPosition(Wrap.HInRadius(Entity.GetAbsOrigin(enemy), 850, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY), 425)
									if bestPos ~= nil then
										Ability.CastPosition(maze, bestPos)
										FAIO.lastTick = os.clock()
										return
									end
								end
							end
						else
							if Ability.SecondsSinceLastUse(atos) > ((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1500) + 0.15 then
								if FAIO.SleepReady(0.1) and maze and Ability.IsCastable(maze, myMana) then
									local bestPos = FAIO.getBestPosition(Wrap.HInRadius(Entity.GetAbsOrigin(enemy), 850, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY), 425)
									if bestPos ~= nil then
										Ability.CastPosition(maze, bestPos)
										FAIO.lastTick = os.clock()
										return
									end
								end
							end
						end
					else
						if maze and Ability.IsCastable(maze, myMana) then
							local bestPos = FAIO.getBestPosition(Wrap.HInRadius(Entity.GetAbsOrigin(enemy), 850, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY), 425)
							if bestPos ~= nil then
								Ability.CastPosition(maze, bestPos)
								FAIO.lastTick = os.clock()
								return
							end
						end
						if bedlam and Ability.IsCastable(bedlam, myMana) then
							if NPC.IsEntityInRange(myHero, enemy, 250) and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_INVULNERABLE) then
								Ability.CastNoTarget(bedlam)
								FAIO.lastTick = os.clock()
								return
							end
						end
					end
						
				end
			end
		end
		if NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_INVULNERABLE) or NPC.HasModifier(enemy, "modifier_rod_of_atos_debuff") or NPC.HasModifier(myHero, "modifier_dark_willow_bedlam") then
			if not NPC.HasModifier(myHero, "modifier_dark_willow_shadow_realm_buff") then
				if not NPC.IsEntityInRange(myHero, enemy, 150) then
					FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Entity.GetAbsOrigin(enemy))
					return
				end
			else
				local creaTime = Modifier.GetCreationTime(NPC.GetModifier(myHero, "modifier_dark_willow_shadow_realm_buff"))
				if GameRules.GetGameTime() - creaTime >= 3 then
					FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
					return
				else
					if not NPC.IsEntityInRange(myHero, enemy, 150) then
						FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Entity.GetAbsOrigin(enemy))
						return
					end
				end
			end	
		else
			if NPC.HasModifier(myHero, "modifier_dark_willow_shadow_realm_buff") then
				local creaTime = Modifier.GetCreationTime(NPC.GetModifier(myHero, "modifier_dark_willow_shadow_realm_buff"))
				if GameRules.GetGameTime() - creaTime >= 3 then
					FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
					return
				else
					if not NPC.IsEntityInRange(myHero, enemy, 150) then
						FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Entity.GetAbsOrigin(enemy))
						return
					end
				end
			else	
				FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
				return
			end
		end
	end

end

function FAIO.SilencerCombo(myHero, enemy)

	if not Menu.IsEnabled(FAIO.optionHeroSilencer) then return end
	if not NPC.IsEntityInRange(myHero, enemy, 3000)	then return end

	local arcaneCurse = NPC.GetAbilityByIndex(myHero, 0)
    	local glaives = NPC.GetAbilityByIndex(myHero, 1)
	local lastWord = NPC.GetAbilityByIndex(myHero, 2)
    	local globalSilence = NPC.GetAbility(myHero, "silencer_global_silence")

	local myMana = NPC.GetMana(myHero)

	local blink = NPC.GetItem(myHero, "item_blink", true)
	local hurricanePike = NPC.GetItem(myHero, "item_hurricane_pike", true)

	local myAttackRange = NPC.GetAttackRange(myHero)

	FAIO.SilencerAutoInterruptChan(myHero, myMana, globalSilence)
	FAIO.itemUsage(myHero, enemy)
	
	if Menu.IsKeyDown(FAIO.optionHeroSilencerHarassKey) then
		FAIO.SilencerAutoHarass(myHero, myMana, myAttackRange, glaives)
		Engine.ExecuteCommand("dota_range_display " .. myAttackRange)
	else
		Engine.ExecuteCommand("dota_range_display 0")
	end

	if Menu.IsKeyDown(FAIO.optionComboKey) and Entity.GetHealth(enemy) > 0 then
		if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and FAIO.heroCanCastSpells(myHero, enemy) == true then
			if not NPC.IsEntityInRange(myHero, enemy, 900) then
				if Menu.IsEnabled(FAIO.optionHeroSilencerBlink) and blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1150 + Menu.GetValue(FAIO.optionHeroSilencerBlinkRange)) then
					Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(Menu.GetValue(FAIO.optionHeroSilencerBlinkRange))))
					return
				end
			else
				if lastWord and Ability.IsCastable(lastWord, myMana) then
					Ability.CastTarget(lastWord, enemy)
					FAIO.lastTick = os.clock()
					return
				end
				if FAIO.SleepReady(0.1) and arcaneCurse and Ability.IsCastable(arcaneCurse, myMana) then
					local bestPos = FAIO.getBestPosition(Wrap.HInRadius(Entity.GetAbsOrigin(enemy), 840, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY), 420)
					if bestPos ~= nil and NPC.IsPositionInRange(myHero, bestPos, 999, 0) then
						Ability.CastPosition(arcaneCurse, bestPos)
						FAIO.lastTick = os.clock()
						return
					else
						Ability.CastPosition(arcaneCurse, Entity.GetAbsOrigin(enemy))
						FAIO.lastTick = os.clock()
						return
					end
				end
			end				
		end
	FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	return
	end
		
end

function FAIO.SilencerAutoHarass(myHero, myMana, myAttackRange, glaives)

	if not myHero then return end
	if not Menu.IsEnabled(FAIO.optionHeroSilencerHarass) then return end

	if not glaives then return end
		if Ability.GetLevel(glaives) < 1 then return end

	if FAIO.heroCanCastSpells(myHero, enemy) == false then return end
	if FAIO.isHeroChannelling(myHero) == true then return end 
	if FAIO.IsHeroInvisible(myHero) == true then return end

	for _, hero in ipairs(Wrap.HeroesInRadius(myHero, myAttackRange, Enum.TeamType.TEAM_ENEMY)) do
		if hero and Entity.IsHero(hero) and not Entity.IsDormant(hero) and not NPC.IsIllusion(hero) then 
			if Wrap.EIsAlive(hero) then
        			Ability.CastTarget(glaives, hero)
				break
        			return
			end
      		end		
	end

end

function FAIO.SilencerAutoHurricane(myHero, myMana, enemy, hurricanePike)

	if not myHero then return end
	if not enemy then return end

	if not Menu.IsEnabled(FAIO.optionHeroSilencerHurricane) then return end

	if not hurricanePike then return end
		if not Ability.IsCastable(hurricanePike, myMana) then return end

	if FAIO.heroCanCastItems(myHero) == false then return end
	if FAIO.isHeroChannelling(myHero) == true then return end 
	if FAIO.IsHeroInvisible(myHero) == true then return end

	local myHPperc = (Entity.GetHealth(myHero) / Entity.GetMaxHealth(myHero)) * 100

	if myHPperc <= Menu.GetValue(FAIO.optionHeroSilencerHurricaneHP) then
		for _, v in ipairs(Wrap.HeroesInRadius(myHero, 800, Enum.TeamType.TEAM_ENEMY)) do
			if v and Entity.IsHero(v) and not Entity.IsDormant(v) and not NPC.IsIllusion(v) then
				if NPC.FindFacingNPC(v) == myHero then
					if NPC.IsEntityInRange(myHero, v, NPC.GetAttackRange(v) + 140) then
						if NPC.IsAttacking(v) then
							Ability.CastTarget(hurricanePike, enemy)
							break
							return
						end
					end
				end
			end	
		end
	end

end

function FAIO.SilencerAutoInterruptChan(myHero, myMana, globalSilence)

	if not myHero then return end

	if not Menu.IsEnabled(FAIO.optionHeroSilencerGlobal) then return end

	if not globalSilence then return end
		if not Ability.IsCastable(globalSilence, myMana) then return end

	if FAIO.heroCanCastItems(myHero) == false then return end
	if FAIO.isHeroChannelling(myHero) == true then return end 
	if FAIO.IsHeroInvisible(myHero) == true then return end

	for i = 1, Heroes.Count() do
		local enemy = Heroes.Get(i)
		if enemy and Entity.IsHero(enemy) and not Entity.IsSameTeam(myHero, enemy) and not Entity.IsDormant(enemy) and NPC.GetUnitName(enemy) == "npc_dota_hero_enigma" and not NPC.IsIllusion(enemy) then
			if Wrap.EIsAlive(enemy) then
				local blackHole = NPC.GetAbility(enemy, "enigma_black_hole")
				if blackHole and Ability.IsChannelling(blackHole) then
					Ability.CastNoTarget(globalSilence)
					return
				end
			end
		end
	end

end

function FAIO.ODCombo(myHero, enemy)

	if not Menu.IsEnabled(FAIO.optionHeroOD) then return end
	if not NPC.IsEntityInRange(myHero, enemy, 3000)	then return end

	local arcaneOrb = NPC.GetAbilityByIndex(myHero, 0)
    	local astralPrison = NPC.GetAbilityByIndex(myHero, 1)
    	local sanityEclipse = NPC.GetAbility(myHero, "obsidian_destroyer_sanity_eclipse")
	local myMana = NPC.GetMana(myHero)

	local blink = NPC.GetItem(myHero, "item_blink", true)
	local hurricanePike = NPC.GetItem(myHero, "item_hurricane_pike", true)

	local myAttackRange = NPC.GetAttackRange(myHero)

	FAIO.itemUsage(myHero, enemy)
	FAIO.ODKillsteal(myHero, myMana, myAttackRange, arcaneOrb, astralPrison, sanityEclipse)
	FAIO.ODAutoPrisonAutoDisable(myHero, myMana, astralPrison)
	FAIO.ODAutoPrisonSave(myHero, myMana, astralPrison)

	if Menu.IsKeyDown(FAIO.optionComboKey) and Entity.GetHealth(enemy) > 0 then
		if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and FAIO.heroCanCastSpells(myHero, enemy) == true then
			if not NPC.IsEntityInRange(myHero, enemy, 999) then
				if Menu.IsEnabled(FAIO.optionHeroODBlink) and blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1150 + Menu.GetValue(FAIO.optionHeroODBlinkRange)) then
					Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(Menu.GetValue(FAIO.optionHeroODBlinkRange))))
					return
				end
			end
		end
	FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	return
	end

end

function FAIO.ODAutoPrisonSave(myHero, myMana, astralPrison)

	if not myHero then return end
	if not Menu.IsEnabled(FAIO.optionHeroODAutoPrisonSave) then return end

	if FAIO.heroCanCastSpells(myHero, enemy) == false then return end
	if FAIO.isHeroChannelling(myHero) == true then return end 
	if FAIO.IsHeroInvisible(myHero) == true then return end

	if not astralPrison then return end
		if not Ability.IsCastable(astralPrison, myMana) then return end

	local prisonCastRange = Ability.GetCastRange(astralPrison) - 25

	local myHPperc = (Entity.GetHealth(myHero) / Entity.GetMaxHealth(myHero)) * 100

	if Menu.IsEnabled(FAIO.optionHeroODAutoPrisonSaveSelf) then
		if myHPperc <= Menu.GetValue(FAIO.optionHeroODAutoPrisonHP) then
			for _, v in ipairs(Wrap.HeroesInRadius(myHero, 800, Enum.TeamType.TEAM_ENEMY)) do
				if v and Entity.IsHero(v) and not Entity.IsDormant(v) and not NPC.IsIllusion(v) then
					if NPC.FindFacingNPC(v) == myHero then
						if NPC.IsEntityInRange(myHero, v, NPC.GetAttackRange(v) + 140) then
							if NPC.IsAttacking(v) then
								Ability.CastTarget(astralPrison, myHero)
								break
								return
							end
						end
					end
				end	
			end
		end
	end
	
	if Menu.IsEnabled(FAIO.optionHeroODAutoPrisonSaveAlly) then
		local teamMatesAround = Wrap.HeroesInRadius(myHero, prisonCastRange, Enum.TeamType.TEAM_FRIEND)
		if next(teamMatesAround) ~= nil then
			for _, ally in ipairs(teamMatesAround) do
				if ally and not NPC.IsIllusion(ally) and Wrap.EIsAlive(ally) then
					if not FAIO.isHeroChannelling(ally) and not FAIO.IsHeroInvisible(ally) then
						if FAIO.IsNPCinDanger(myHero, ally) or (((Entity.GetHealth(ally) / Entity.GetMaxHealth(ally)) * 100) < Menu.GetValue(FAIO.optionHeroODAutoPrisonHP)) then
							Ability.CastTarget(astralPrison, ally)
							break
							return
						end
					end
				end
			end
		end
	end

end

function FAIO.ODAutoPrisonAutoDisable(myHero, myMana, astralPrison)

	if not myHero then return end
	if not Menu.IsEnabled(FAIO.optionHeroODAutoPrisonDefend) then return end

	if FAIO.heroCanCastSpells(myHero, enemy) == false then return end
	if FAIO.isHeroChannelling(myHero) == true then return end 
	if FAIO.IsHeroInvisible(myHero) == true then return end

	if not astralPrison then return end
		if not Ability.IsCastable(astralPrison, myMana) then return end

	local prisonCastRange = Ability.GetCastRange(astralPrison) - 25

	for _, heroes in ipairs(Wrap.HeroesInRadius(myHero, prisonCastRange, Enum.TeamType.TEAM_ENEMY)) do
		if heroes and not Entity.IsDormant(heroes) and Wrap.EIsAlive(heroes) then
			local enemyDagger = NPC.GetItem(heroes, "item_blink", true)
			if enemyDagger and Ability.GetCooldownTimeLeft(enemyDagger) >= 9 and Ability.SecondsSinceLastUse(enemyDagger) > -1 and Ability.SecondsSinceLastUse(enemyDagger) <= 1 then
				if not NPC.HasState(heroes, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and not NPC.IsLinkensProtected(heroes) then
					Ability.CastTarget(astralPrison, heroes)
					break
					return
				end
			end
		end
	end

end

function FAIO.ODAutoHurricane(myHero, myMana, enemy, hurricanePike)

	if not myHero then return end
	if not enemy then return end

	if not Menu.IsEnabled(FAIO.optionHeroODHurricane) then return end

	if not hurricanePike then return end
		if not Ability.IsCastable(hurricanePike, myMana) then return end

	if FAIO.heroCanCastItems(myHero) == false then return end
	if FAIO.isHeroChannelling(myHero) == true then return end 
	if FAIO.IsHeroInvisible(myHero) == true then return end

	local myHPperc = (Entity.GetHealth(myHero) / Entity.GetMaxHealth(myHero)) * 100

	if myHPperc <= Menu.GetValue(FAIO.optionHeroODHurricaneHP) then
		for _, v in ipairs(Wrap.HeroesInRadius(myHero, 800, Enum.TeamType.TEAM_ENEMY)) do
			if v and Entity.IsHero(v) and not Entity.IsDormant(v) and not NPC.IsIllusion(v) then
				if NPC.FindFacingNPC(v) == myHero then
					if NPC.IsEntityInRange(myHero, v, NPC.GetAttackRange(v) + 140) then
						if NPC.IsAttacking(v) then
							Ability.CastTarget(hurricanePike, enemy)
							break
							return
						end
					end
				end
			end	
		end
	end

end

function FAIO.ODKillsteal(myHero, myMana, myAttackRange, arcaneOrb, astralPrison, sanityEclipse)

	if not myHero then return end
	if not Menu.IsEnabled(FAIO.optionHeroODKillsteal) then return end

	if FAIO.heroCanCastSpells(myHero, enemy) == false then return end
	if FAIO.isHeroChannelling(myHero) == true then return end 
	if FAIO.IsHeroInvisible(myHero) == true then return end

	if not (arcaneOrb and astralPrison and sanityEclipse) then return end

	if Menu.IsEnabled(FAIO.optionHeroODKillstealEclipse) then
		if sanityEclipse and Ability.IsCastable(sanityEclipse, myMana) then
			local tempTableHittableTargets = {}
			local tempTableKillableTargets = {}
			local sanityEclipseRadius = Ability.GetLevelSpecialValueFor(sanityEclipse, "radius")
			for _, targets in ipairs(Wrap.HeroesInRadius(myHero, 1200, Enum.TeamType.TEAM_ENEMY)) do
				if targets then
					local target = FAIO.targetChecker(targets)
					if target then
						if not NPC.HasState(target, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
							if NPC.IsEntityInRange(myHero, target, 690 + sanityEclipseRadius - 25) then
								if #Wrap.HeroesInRadius(target, sanityEclipseRadius - 25, Enum.TeamType.TEAM_FRIEND) > -1 then
									table.insert(tempTableHittableTargets, target)
								end
							end
						end
					end
				end
			end

			if #tempTableHittableTargets >= 1 then
				local bestPos = FAIO.getBestPosition(tempTableHittableTargets, (sanityEclipseRadius - 25))
				if bestPos ~= nil and #Wrap.HInRadius(bestPos, (sanityEclipseRadius - 25), Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY) >= Menu.GetValue(FAIO.optionHeroODKillstealEclipseHittable) then
					for _, v in ipairs(Wrap.HInRadius(bestPos, (sanityEclipseRadius - 25), Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY)) do
						local targetHP = Entity.GetHealth(v) + NPC.GetHealthRegen(v)
						local sanityEclipseDamage = (Hero.GetIntellectTotal(myHero) - Hero.GetIntellectTotal(v)) * Ability.GetLevelSpecialValueFor(sanityEclipse, "damage_multiplier")
						local sanityEclipseTrueDamage = (1 - NPC.GetMagicalArmorValue(v)) * (sanityEclipseDamage + sanityEclipseDamage * (Hero.GetIntellectTotal(myHero) / 14 / 100))		
						if targetHP < sanityEclipseTrueDamage then
							table.insert(tempTableKillableTargets, v)
						end
					end
				end
			end

			if #tempTableKillableTargets >= Menu.GetValue(FAIO.optionHeroODKillstealEclipseKillable) then
				local bestPos = FAIO.getBestPosition(tempTableHittableTargets, (sanityEclipseRadius - 25))
				if bestPos ~= nil and NPC.IsPositionInRange(myHero, bestPos, 690, 0) then
					Ability.CastPosition(sanityEclipse, bestPos)
					return
				end
			end
		end
	end

	if Menu.IsEnabled(FAIO.optionHeroODKillstealPrison) then
		if astralPrison and Ability.IsCastable(astralPrison, myMana) then
			local prisonCastRange = Ability.GetCastRange(astralPrison)
			for _, targets in ipairs(Wrap.HeroesInRadius(myHero, prisonCastRange, Enum.TeamType.TEAM_ENEMY)) do
				if targets then
					local target = FAIO.targetChecker(targets)
					if target then
						if not NPC.HasState(target, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and not NPC.IsLinkensProtected(target) and not NPC.HasModifier(target, "modifier_templar_assassin_refraction_absorb") then
							local targetHP = Entity.GetHealth(target) + 5 * math.ceil(NPC.GetHealthRegen(target))
							local prisonDamage = Ability.GetLevelSpecialValueFor(astralPrison, "damage")
							local prisonTrueDamage = (1 - NPC.GetMagicalArmorValue(target)) * (prisonDamage + prisonDamage * (Hero.GetIntellectTotal(myHero) / 14 / 100)) - 5
							if targetHP < prisonTrueDamage then
								Ability.CastTarget(astralPrison, target)
								break
								return
							end
						end
					end
				end
			end
		end
	end

	if Menu.IsEnabled(FAIO.optionHeroODKillstealOrb) then
		if arcaneOrb and Ability.IsCastable(arcaneOrb, myMana) and Ability.GetLevel(arcaneOrb) > 0 then
			for _, targets in ipairs(Wrap.HeroesInRadius(myHero, myAttackRange, Enum.TeamType.TEAM_ENEMY)) do
				if targets then
					local target = FAIO.targetChecker(targets)
					if target then
						if not NPC.HasState(target, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and not NPC.IsLinkensProtected(target) and not NPC.HasModifier(target, "modifier_templar_assassin_refraction_absorb") and not NPC.HasState(target, Enum.ModifierState.MODIFIER_STATE_INVULNERABLE) then
							local targetHP = Entity.GetHealth(target) + NPC.GetHealthRegen(target)
							local orbExtraDamage = (0.05 + (0.01 * Ability.GetLevel(arcaneOrb))) * NPC.GetMana(myHero)
							local rightClickDamage = NPC.GetDamageMultiplierVersus(myHero, target) * ((NPC.GetMinDamage(myHero) + NPC.GetBonusDamage(myHero)) * NPC.GetArmorDamageMultiplier(target))
							local overallDamage = rightClickDamage + orbExtraDamage
							if targetHP < overallDamage then
								Ability.CastTarget(arcaneOrb, target)
								break
								return
							end
						end
					end
				end
			end
		end
	end

end

function FAIO.NecroCombo(myHero, enemy)

	if not Menu.IsEnabled(FAIO.optionHeroNecro) then return end

	local deathPulse = NPC.GetAbilityByIndex(myHero, 0)
    	local ghostShroud = NPC.GetAbilityByIndex(myHero, 1)
    	local reapersScythe = NPC.GetAbility(myHero, "necrolyte_reapers_scythe")
	local myMana = NPC.GetMana(myHero)

	local blink = NPC.GetItem(myHero, "item_blink", true)
	
	FAIO.itemUsage(myHero, enemy)
	FAIO.necroComboTotalDamage(myHero, myMana, enemy, deathPulse, reapersScythe)
	FAIO.necroComboSelector(myHero, myMana, enemy, deathPulse, reapersScythe)
	FAIO.necroAutoScythe(myHero, myMana, reapersScythe)
	FAIO.necroAutoPulse(myHero, myMana, deathPulse)
	FAIO.necroAutoFarmShroud(myHero, myMana, deathPulse, ghostShroud)
	FAIO.necroAutoPulseShroudPanic(myHero, myMana, deathPulse, ghostShroud)

	if enemy then
		if Menu.IsKeyDown(FAIO.optionComboKey) and Entity.GetHealth(enemy) > 0 then
			if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and FAIO.heroCanCastSpells(myHero, enemy) == true then
				if not NPC.IsEntityInRange(myHero, enemy, 999) then
					if Menu.IsEnabled(FAIO.optionHeroNecroBlink) and blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1150 + Menu.GetValue(FAIO.optionHeroNecroBlinkRange)) then
						Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(Menu.GetValue(FAIO.optionHeroNecroBlinkRange))))
						return
					end
				end

				if not FAIO.necroComboSelect then
					FAIO.necroComboWithoutUlt(myHero, myMana, enemy, deathPulse)
				else
					FAIO.necroComboWithUlt(myHero, myMana, enemy, deathPulse, reapersScythe)
				end

			end
			FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
		end
	end

end

function FAIO.necroAutoPulseShroudPanic(myHero, myMana, deathPulse, ghostShroud)

	if not Menu.IsEnabled(FAIO.optionHeroNecroShroudPanic) then return end
	if not myHero then return end

	if FAIO.heroCanCastSpells(myHero, enemy) == false then return end
	if FAIO.isHeroChannelling(myHero) == true then return end 
	if FAIO.IsHeroInvisible(myHero) == true then return end

	local myHP = Entity.GetHealth(myHero)
	local myHPperc = (myHP / Entity.GetMaxHealth(myHero)) * 100

	if myHPperc <= Menu.GetValue(FAIO.optionHeroNecroShroudPanicHP) then
		if ghostShroud and Ability.IsCastable(ghostShroud, myMana) then
			Ability.CastNoTarget(ghostShroud)
			return
		end
		if deathPulse and Ability.IsCastable(deathPulse, myMana) then
			Ability.CastNoTarget(deathPulse)
			return
		end
	end

end

function FAIO.necroAutoFarmShroud(myHero, myMana, deathPulse, ghostShroud)

	if not Menu.IsEnabled(FAIO.optionHeroNecroShroudFarm) then return end
	if not myHero then return end
	if not deathPulse then return end
		if Ability.GetLevel(deathPulse) < 1 then return end

	if not ghostShroud then return end
		if Ability.GetLevel(ghostShroud) < 1 then return end
		if not Ability.IsCastable(ghostShroud, myMana) then return end

	if FAIO.heroCanCastSpells(myHero, enemy) == false then return end
	if FAIO.isHeroChannelling(myHero) == true then return end 
	if FAIO.IsHeroInvisible(myHero) == true then return end

	local deathPulseModifier = NPC.GetModifier(myHero, "modifier_necrolyte_death_pulse_counter")
	local deathPulseCounter = 0
		if deathPulseModifier then
			deathPulseCounter = Modifier.GetStackCount(deathPulseModifier)
		end

	if deathPulseCounter <= Menu.GetValue(FAIO.optionHeroNecroShroudFarmCount) then return end
	if Menu.IsEnabled(FAIO.optionHeroNecroShroudFarmSave) then
		if #Wrap.HeroesInRadius(myHero, 600, Enum.TeamType.TEAM_ENEMY) > 0 then
			return
		end
	end
	local manaPerc = (NPC.GetMana(myHero) / NPC.GetMaxMana(myHero)) * 100
	local healthPerc = (Entity.GetHealth(myHero) / Entity.GetMaxHealth(myHero)) * 100
	local treshold = Menu.GetValue(FAIO.optionHeroNecroShroudFarmTreshold)
	if manaPerc <= treshold or healthPerc <= treshold then
		Ability.CastNoTarget(ghostShroud)
		return
	end

end

function FAIO.necroAutoPulse(myHero, myMana, deathPulse)

	if not Menu.IsEnabled(FAIO.optionHeroNecroPulse) then return end
	if not myHero then return end
	if not deathPulse then return end
		if Ability.GetLevel(deathPulse) < 1 then return end
		if not Ability.IsCastable(deathPulse, myMana) then return end

	if FAIO.heroCanCastSpells(myHero, enemy) == false then return end
	if FAIO.isHeroChannelling(myHero) == true then return end 
	if FAIO.IsHeroInvisible(myHero) == true then return end

	if Menu.IsKeyDown(FAIO.optionComboKey) then return end

	if Menu.IsEnabled(FAIO.optionHeroNecroPulseCreeps) then
		local tempTable = {}
		for _, creep in ipairs(Wrap.UnitsInRadius(myHero, 450, Enum.TeamType.TEAM_ENEMY)) do
			if creep and Wrap.EIsNPC(creep) and not Entity.IsDormant(creep) and not NPC.IsWaitingToSpawn(creep) and NPC.GetUnitName(creep) ~= "npc_dota_neutral_caster" then
				local pulseDamage = Ability.GetDamage(deathPulse)
				local pulseTrueDamage = (1 - NPC.GetMagicalArmorValue(creep)) * (pulseDamage + pulseDamage * (Hero.GetIntellectTotal(myHero) / 14 / 100))
				local creepHP = Entity.GetHealth(creep)
				if NPC.IsLaneCreep(creep) then
					local attackerCount = 0
						if FAIO.lastHitGetAttackerCount(myHero, creep) ~= nil and FAIO.lastHitGetAttackerCount(myHero, creep) > 0 then
							attackerCount = FAIO.lastHitGetAttackerCount(myHero, creep)
						end
					if creepHP + (attackerCount * 15) < pulseTrueDamage then
						table.insert(tempTable, creep)
					end
				else
					if creepHP < pulseTrueDamage then
						table.insert(tempTable, creep)
					end
				end
			end
		end

		if #tempTable >= Menu.GetValue(FAIO.optionHeroNecroPulseCreepsCount) then
			if (myMana / NPC.GetMaxMana(myHero)) >= (Menu.GetValue(FAIO.optionHeroNecroPulseCreepsMana) / 100) then
				Ability.CastNoTarget(deathPulse)
				return
			end
		end
	end

	if Menu.IsEnabled(FAIO.optionHeroNecroPulseHeroes) then
		for _, hero in ipairs(Wrap.HeroesInRadius(myHero, 450, Enum.TeamType.TEAM_ENEMY)) do
			local target = FAIO.targetChecker(hero)
			if target then
				if not NPC.HasState(target, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
					if (myMana / NPC.GetMaxMana(myHero)) >= (Menu.GetValue(FAIO.optionHeroNecroPulseHeroesMana) / 100) then
						Ability.CastNoTarget(deathPulse)
						break
						return
					end
				end
			end
		end
	end
					
end

function FAIO.necroAutoScythe(myHero, myMana, reapersScythe)

	if not Menu.IsEnabled(FAIO.optionHeroNecroScythe) then return end
	if not myHero then return end
	if not reapersScythe then return end
		if Ability.GetLevel(reapersScythe) < 1 then return end
		if not Ability.IsCastable(reapersScythe, myMana) then return end

	if FAIO.heroCanCastSpells(myHero, enemy) == false then return end
	if FAIO.isHeroChannelling(myHero) == true then return end 
	if FAIO.IsHeroInvisible(myHero) == true then return end

	if Menu.IsKeyDown(FAIO.optionComboKey) then return end

	for _, hero in ipairs(Wrap.HeroesInRadius(myHero, 575, Enum.TeamType.TEAM_ENEMY)) do
		if hero and Entity.IsHero(hero) and not Entity.IsDormant(hero) and not NPC.IsIllusion(hero) then 
			if Wrap.EIsAlive(hero) and not NPC.HasModifier(hero, "modifier_templar_assassin_refraction_absorb") then
				local scytheDamage = (Entity.GetMaxHealth(hero) - Entity.GetHealth(hero)) * Ability.GetLevelSpecialValueForFloat(reapersScythe, "damage_per_health")
        			local scytheTrueDamage = (1 - NPC.GetMagicalArmorValue(hero)) * (scytheDamage + scytheDamage * (Hero.GetIntellectTotal(myHero) / 14 / 100))
				if Entity.GetHealth(hero) < scytheTrueDamage then
					Ability.CastTarget(reapersScythe, hero)
					break
        				return
				end
			end
      		end		
	end

end

function FAIO.necroComboSelector(myHero, myMana, enemy, deathPulse, reapersScythe)

	if not myHero then return end
	if not enemy then return end
	if os.clock() - FAIO.lastTick < 0.55 + ((Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Length2D() / 400) then return end


	if not deathPulse then return end

	if Ability.SecondsSinceLastUse(deathPulse) > -1 and Ability.SecondsSinceLastUse(deathPulse) < 0.55 + ((Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Length2D() / 400) then return end

	if not reapersScythe then
		FAIO.necroComboSelect = false
		return
	end

	if Ability.GetLevel(reapersScythe) < 1 then
		FAIO.necroComboSelect = false
		return
	end

	if not Ability.IsCastable(reapersScythe, myMana) then
		FAIO.necroComboSelect = false
		return
	end

	if Menu.GetValue(FAIO.optionHeroNecroComboScythe) == 0 then
		FAIO.necroComboSelect = false
		return
	else
		if Entity.GetHealth(enemy) > FAIO.necroDMGwithoutUlt then
			FAIO.necroComboSelect = true
			return
		else
			FAIO.necroComboSelect = false
			return
		end
	end	

end

function FAIO.necroComboWithoutUlt(myHero, myMana, enemy, deathPulse)

	if not myHero then return end
	if not enemy then return end

	if deathPulse and Ability.IsCastable(deathPulse, myMana) and NPC.IsEntityInRange(myHero, enemy, 450) then
		Ability.CastNoTarget(deathPulse)
		FAIO.lastTick = os.clock()
		return
	end

end

function FAIO.necroComboWithUlt(myHero, myMana, enemy, deathPulse, reapersScythe)

	if not myHero then return end
	if not enemy then return end

	if deathPulse and Ability.IsCastable(deathPulse, myMana) and NPC.IsEntityInRange(myHero, enemy, 450) then
		Ability.CastNoTarget(deathPulse)
		FAIO.lastTick = os.clock()
		return
	end

	if reapersScythe and Ability.IsCastable(reapersScythe, myMana) and NPC.IsEntityInRange(myHero, enemy, 550) then
		if Menu.GetValue(FAIO.optionHeroNecroComboScythe) == 1 then
			if not Ability.IsReady(deathPulse) then
				Ability.CastTarget(reapersScythe, enemy)
				FAIO.lastTick = os.clock()
				return
			end
		elseif Menu.GetValue(FAIO.optionHeroNecroComboScythe) == 2 then
			local scytheDamage = (Entity.GetMaxHealth(enemy) - Entity.GetHealth(enemy)) * Ability.GetLevelSpecialValueForFloat(reapersScythe, "damage_per_health")
        		local scytheTrueDamage = (1 - NPC.GetMagicalArmorValue(enemy)) * (scytheDamage + scytheDamage * (Hero.GetIntellectTotal(myHero) / 14 / 100))
			local rightClickDamage = NPC.GetDamageMultiplierVersus(myHero, enemy) * ((NPC.GetMinDamage(myHero) + NPC.GetBonusDamage(myHero)) * NPC.GetArmorDamageMultiplier(enemy))
			local pulseExtraDamage = 0
				if deathPulse and Ability.SecondsSinceLastUse(deathPulse) > -1 and Ability.SecondsSinceLastUse(deathPulse) < (((Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Length2D() / 400) + 0.05) then
					pulseExtraDamage = (1 - NPC.GetMagicalArmorValue(enemy)) * (Ability.GetDamage(deathPulse) + Ability.GetDamage(deathPulse) * (Hero.GetIntellectTotal(myHero) / 14 / 100))
				end
			if Entity.GetHealth(enemy) < (scytheTrueDamage + rightClickDamage + pulseExtraDamage) then
				Ability.CastTarget(reapersScythe, enemy)
				FAIO.lastTick = os.clock()
				return
			end
		end
	end

end

function FAIO.necroComboTotalDamage(myHero, myMana, enemy, deathPulse, reapersScythe)

	if not myHero then return end
	if not enemy then return end
	if NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then return end 

	local totalDamage = 0
	local totalDamageUlt = 0
	local veilAmp = 0
	local ebladeAmp = 0
	local reqMana = 0
	local reqManaUlt = 0

	local veil = NPC.GetItem(myHero, "item_veil_of_discord", true)
	local eBlade = NPC.GetItem(myHero, "item_ethereal_blade", true)
	local dagon = NPC.GetItem(myHero, "item_dagon", true)
		if not dagon then
			for i = 2, 5 do
				dagon = NPC.GetItem(myHero, "item_dagon_" .. i, true)
				if dagon then break end
			end
		end

	if veil and Ability.IsCastable(veil, myMana) then
		veilAmp = 0.25
		reqMana = reqMana + Ability.GetManaCost(veil)
	end

	if eBlade and Ability.IsCastable(eBlade, myMana) then
		local ebladedamage = Hero.GetIntellectTotal(myHero) * 2 + 75
		totalDamage = totalDamage + (1 - NPC.GetMagicalArmorValue(enemy)) * (1 + veilAmp) * (ebladedamage + ebladedamage * (Hero.GetIntellectTotal(myHero) / 14 / 100))
		ebladeAmp = 0.4
		reqMana = reqMana + Ability.GetManaCost(eBlade)
	end	

	if dagon and Ability.IsCastable(dagon, Ability.GetManaCost(dagon)) then
		local dagondmg = Ability.GetLevelSpecialValueFor(dagon, "damage")
		totalDamage = totalDamage + (1 - NPC.GetMagicalArmorValue(enemy)) * (1 + veilAmp) * (1 + ebladeAmp) * (dagondmg + dagondmg * (Hero.GetIntellectTotal(myHero) / 14 / 100))
		reqMana = reqMana + Ability.GetManaCost(dagon)
	end

	if deathPulse and Ability.IsCastable(deathPulse, myMana) then
		if NPC.HasItem(myHero, "item_blink", true) and Ability.IsReady(NPC.GetItem(myHero, "item_blink", true)) then
			local pulseDamage = Ability.GetDamage(deathPulse)
			totalDamage = totalDamage + (1 - NPC.GetMagicalArmorValue(enemy)) * (1 + veilAmp) * (1 + ebladeAmp) * (pulseDamage + pulseDamage * (Hero.GetIntellectTotal(myHero) / 14 / 100))
			reqMana = reqMana + Ability.GetManaCost(deathPulse)
		else
			if NPC.IsEntityInRange(myHero, enemy, 475) then
				local pulseDamage = Ability.GetDamage(deathPulse)
				totalDamage = totalDamage + (1 - NPC.GetMagicalArmorValue(enemy)) * (1 + veilAmp) * (1 + ebladeAmp) * (pulseDamage + pulseDamage * (Hero.GetIntellectTotal(myHero) / 14 / 100))
				reqMana = reqMana + Ability.GetManaCost(deathPulse)
			end
		end
	end

	local rightClickDamage = 0
		if not NPC.HasItem(myHero, "item_ethereal_blade", true) then
			rightClickDamage = NPC.GetDamageMultiplierVersus(myHero, enemy) * ((NPC.GetMinDamage(myHero) + NPC.GetBonusDamage(myHero)) * NPC.GetArmorDamageMultiplier(enemy))
		end

	totalDamage = totalDamage + rightClickDamage

	local scytheOverallTrueDamage = 0
	local totalDamageUlt = totalDamage
	local reqManaUlt = reqMana
	if reapersScythe and Ability.IsCastable(reapersScythe, myMana) then
		local scytheDamage = (Entity.GetMaxHealth(enemy) - (Entity.GetHealth(enemy) - totalDamage)) * Ability.GetLevelSpecialValueForFloat(reapersScythe, "damage_per_health")
		local scytheTrueDamage = (1 - NPC.GetMagicalArmorValue(enemy)) * (1 + veilAmp) * (1 + ebladeAmp) * (scytheDamage + scytheDamage * (Hero.GetIntellectTotal(myHero) / 14 / 100))
		scytheOverallTrueDamage = scytheTrueDamage + rightClickDamage
		totalDamageUlt = totalDamage + scytheOverallTrueDamage
		reqManaUlt = reqManaUlt + Ability.GetManaCost(reapersScythe)
	end

	if reqManaUlt > NPC.GetMana(myHero) and reqMana < NPC.GetMana(myHero) then
		totalDamageUlt = totalDamage
	end

	if reqMana < NPC.GetMana(myHero) then
		FAIO.necroDMGwithoutUlt = totalDamage
		FAIO.necroDMGwithUlt = totalDamageUlt
	end

end

function FAIO.necroComboDrawDamage(myHero)

	if not myHero then return end
	if not Menu.IsEnabled(FAIO.optionHeroNecroDrawDMG) then return end
	
	if FAIO.necroDMGwithoutUlt == 0 then return end
	if FAIO.necroDMGwithUlt == 0 then return end

	local enemy = FAIO.targetChecker(Input.GetNearestHeroToCursor(Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY))
		if not enemy then return end
		if not NPC.IsPositionInRange(enemy, Input.GetWorldCursorPos(), 500, 0) then return end

	local pos = Entity.GetAbsOrigin(enemy)
	local posY = NPC.GetHealthBarOffset(enemy)
		pos:SetZ(pos:GetZ() + posY)
			
	local x, y, visible = Renderer.WorldToScreen(pos)

	if FAIO.necroDMGwithoutUlt > 0 and FAIO.necroDMGwithUlt > 0 then
		if visible then
			if Entity.GetHealth(enemy) > FAIO.necroDMGwithoutUlt then
				Renderer.SetDrawColor(255,102,102,255)
			else
				Renderer.SetDrawColor(50,205,50,255)
			end
				Renderer.DrawText(FAIO.skywrathFont, x-50, y-90, "DMG w/o Ult: " .. math.floor(FAIO.necroDMGwithoutUlt), 0)
			if Entity.GetHealth(enemy) > FAIO.necroDMGwithUlt then
				Renderer.SetDrawColor(255,102,102,255)
			else
				Renderer.SetDrawColor(50,205,50,255)
			end
				Renderer.DrawText(FAIO.skywrathFont, x-50, y-75, "DMG w/ Ult: " .. math.floor(FAIO.necroDMGwithUlt), 0)
		end
	end
		

end

function FAIO.PACombo(myHero, enemy)

	if not Menu.IsEnabled(FAIO.optionHeroPA) then return end
	if not NPC.IsEntityInRange(myHero, enemy, 3000)	then return end

	local dagger = NPC.GetAbilityByIndex(myHero, 0)
	local phantomStrike = NPC.GetAbilityByIndex(myHero, 1)

	local myMana = NPC.GetMana(myHero)

	local daggerRange = Ability.GetCastRange(dagger)

	if Menu.IsKeyDown(FAIO.optionComboKey) and Entity.GetHealth(enemy) > 0 and FAIO.heroCanCastSpells(myHero, enemy) == true then
		if not NPC.IsEntityInRange(myHero, enemy, NPC.GetAttackRange(myHero)) then
			if FAIO.SleepReady(0.1) and dagger and Ability.IsCastable(dagger, myMana) then
				if NPC.IsEntityInRange(myHero, enemy, daggerRange - 5) and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
					Ability.CastTarget(dagger, enemy)
					FAIO.lastTick = os.clock()
					return
				end
			end
			if FAIO.SleepReady(0.1) and phantomStrike and Ability.IsCastable(phantomStrike, myMana) then
				if NPC.IsEntityInRange(myHero, enemy, 999) then
					Ability.CastTarget(phantomStrike, enemy)
					FAIO.lastTick = os.clock()
					return
				end
			end
		end

	FAIO.itemUsage(myHero, enemy)
	FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)

	end
	
	local minHP = 99999
	local minHPenemy

	if Menu.IsEnabled(FAIO.optionHeroPADagger) and FAIO.isHeroChannelling(myHero) == false and FAIO.IsHeroInvisible(myHero) == false then
		if FAIO.Toggler then
			if NPC.GetMana(myHero) > (NPC.GetMaxMana(myHero) * (Menu.GetValue(FAIO.optionHeroPADaggerThreshold) / 100)) then
				if dagger and Ability.IsCastable(dagger, myMana) then
					local daggerEnemies = Wrap.HeroesInRadius(myHero, daggerRange - 1, Enum.TeamType.TEAM_ENEMY)
					for _, daggerEnemy in ipairs(daggerEnemies) do
						if daggerEnemy and FAIO.targetChecker(daggerEnemy) ~= nil and not NPC.HasState(daggerEnemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
							local enemyHP = Entity.GetHealth(daggerEnemy)
							if enemyHP < minHP then
								minHP = enemyHP
								minHPenemy = daggerEnemy
							end
						end
					end
				end
			end
		end
	end

	if minHPenemy and FAIO.isHeroChannelling(myHero) == false and FAIO.IsHeroInvisible(myHero) == false then
		if Menu.IsEnabled(FAIO.optionHeroPADagger) then
			if FAIO.Toggler then
				if not NPC.IsChannellingAbility(myHero) and not NPC.HasState(myHero, Enum.ModifierState.MODIFIER_STATE_INVISIBLE) and not NPC.HasModifier(myHero, "modifier_teleporting") then
					if FAIO.SleepReady(0.3) and dagger and Ability.IsCastable(dagger, myMana) then
						Ability.CastTarget(dagger, minHPenemy)
						FAIO.lastTick = os.clock()
						minHP = 99999
						minHPenemy = nil
						return
					end
				end
			end
		end
	end

end

function FAIO.DrawPADaggerSwitch()

	local w, h = Renderer.GetScreenSize()
	Renderer.SetDrawColor(255, 0, 255)

	if Menu.IsKeyDownOnce(FAIO.optionHeroPADaggerToggleKey) then
		FAIO.Toggler = not FAIO.Toggler
		FAIO.TogglerTime = os.clock()
	end

	if Menu.IsEnabled(FAIO.optionHeroPADaggerDraw) then
		if os.clock() - FAIO.TogglerTime < 3 then
			if FAIO.Toggler then
				Wrap.DrawTextCentered(FAIO.font, w / 2, h / 2 + 300, "AUTO DAGGER ON", 1)
			else 
				Wrap.DrawTextCentered(FAIO.font, w / 2, h / 2 + 300, "AUTO DAGGER OFF", 1)
			end
		end
	end

end

function FAIO.AntiMageCombo(myHero, enemy)

	if not Menu.IsEnabled(FAIO.optionHeroAntiMage) then return end
	if not NPC.IsEntityInRange(myHero, enemy, 3000)	then return end

	local AMblink = NPC.GetAbilityByIndex(myHero, 1)
    	local manaVoid = NPC.GetAbility(myHero, "antimage_mana_void")
    	
	local myMana = NPC.GetMana(myHero)

	local blinkRange = Ability.GetLevelSpecialValueFor(AMblink, "blink_range")

	if Menu.IsKeyDown(FAIO.optionComboKey) and Entity.GetHealth(enemy) > 0 and FAIO.heroCanCastSpells(myHero, enemy) == true then
		if not NPC.IsEntityInRange(myHero, enemy, 250) then
			if AMblink and Ability.IsCastable(AMblink, myMana) and Menu.IsEnabled(FAIO.optionHeroAntiMageBlink) then
				if NPC.IsEntityInRange(myHero, enemy, blinkRange - 105) then
					if NPC.GetTimeToFace(enemy, myHero) <= 0.05 then
						Ability.CastPosition(AMblink, Entity.GetAbsOrigin(enemy))
						return
					else
						Ability.CastPosition(AMblink, Entity.GetAbsOrigin(enemy) + Entity.GetRotation(enemy):GetForward():Normalized():Scaled(100))
						return
					end
				end
			end
		end

	FAIO.itemUsage(myHero, enemy)
	FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	FAIO.MantaIlluController(enemy, nil, myHero, myHero)

	end

	local maxManaDiff = 0
	local maxDMGTarget

	if manaVoid and Ability.IsCastable(manaVoid, myMana) and FAIO.isHeroChannelling(myHero) == false and FAIO.IsHeroInvisible(myHero) == false then
		if Menu.IsEnabled(FAIO.optionHeroAntiMageVoid) then
			local voidEnemies = Wrap.HeroesInRadius(myHero, 599, Enum.TeamType.TEAM_ENEMY)
			for _, voidEnemy in ipairs(voidEnemies) do
				if voidEnemy and not NPC.IsLinkensProtected(voidEnemy) then
					local enemyManaDiff = NPC.GetMaxMana(voidEnemy) - NPC.GetMana(voidEnemy)
					if #voidEnemies <= 1 then
						if not NPC.HasState(voidEnemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
							maxManaDiff = 0
							maxDMGTarget = voidEnemy
							break
							return
						end
					else
						if enemyManaDiff > maxManaDiff and not NPC.HasState(voidEnemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
							maxManaDiff = enemyManaDiff
							maxDMGTarget = voidEnemy
						end
					end
				end
			end
		end
	end

	if maxDMGTarget ~= nil then
		if FAIO.isHeroChannelling(myHero) == false and FAIO.IsHeroInvisible(myHero) == false then
			local enemyHP = Entity.GetHealth(maxDMGTarget) + NPC.GetHealthRegen(maxDMGTarget)
			local enemiesInVoidRadius = Wrap.HeroesInRadius(maxDMGTarget, 450, Enum.TeamType.TEAM_FRIEND)
			local enemyManaDiff = NPC.GetMaxMana(maxDMGTarget) - NPC.GetMana(maxDMGTarget)
			local voidDamage = enemyManaDiff * Ability.GetLevelSpecialValueForFloat(manaVoid, "mana_void_damage_per_mana")
			local totalVoidDamage = ((1 - NPC.GetMagicalArmorValue(maxDMGTarget)) * voidDamage) + (voidDamage * (Hero.GetIntellectTotal(myHero) / 14 / 100))
			if manaVoid and Ability.IsCastable(manaVoid, myMana) then
				if NPC.IsEntityInRange(myHero, maxDMGTarget, 599) then
					if totalVoidDamage > enemyHP then
						Ability.CastTarget(manaVoid, maxDMGTarget)
						maxManaDiff = 0
						maxDMGTarget = nil
						return
					end
					if #enemiesInVoidRadius >= 1 then
						for _, radiusTargets in ipairs(enemiesInVoidRadius) do
							if radiusTargets then
								local voidDamageRadius = enemyManaDiff * Ability.GetLevelSpecialValueForFloat(manaVoid, "mana_void_damage_per_mana")
								local totalVoidDamageRadius = ((1 - NPC.GetMagicalArmorValue(radiusTargets)) * voidDamageRadius) + (voidDamageRadius * (Hero.GetIntellectTotal(myHero) / 14 / 100))
								if totalVoidDamageRadius > Entity.GetHealth(radiusTargets) + NPC.GetHealthRegen(radiusTargets) and not NPC.HasState(radiusTargets, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
									Ability.CastTarget(manaVoid, maxDMGTarget)
									maxManaDiff = 0
									maxDMGTarget = nil
									break
									return
								end
							end
						end
					end
				end	
			end
		end
	end
				
end		

function FAIO.tinyCombo(myHero, enemy)

	if not Menu.IsEnabled(FAIO.optionHeroTiny) then return end
	if not NPC.IsEntityInRange(myHero, enemy, 3000)	then return end
    
    	local avalanche = NPC.GetAbilityByIndex(myHero, 0)
    	local toss = NPC.GetAbilityByIndex(myHero, 1)
    	local myMana = NPC.GetMana(myHero)

	local blink = NPC.GetItem(myHero, "item_blink", true)

	if Menu.IsKeyDown(FAIO.optionComboKey) and Entity.GetHealth(enemy) > 0 and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and FAIO.heroCanCastSpells(myHero, enemy) == true then
		if not NPC.IsEntityInRange(myHero, enemy, 275) then
			if blink and Ability.IsReady(blink) then
				if NPC.IsEntityInRange(myHero, enemy, 1150) then
					Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy))
					return
				end
			end
		else
			FAIO.itemUsage(myHero, enemy)
			if avalanche and Ability.IsCastable(avalanche, myMana) then 
				Ability.CastPosition(avalanche, Entity.GetAbsOrigin(enemy))
				FAIO.lastTick = os.clock()
			end
    			if FAIO.SleepReady(0.2) and toss and Ability.IsCastable(toss, myMana) then 
				Ability.CastTarget(toss, enemy)
				return 
			end
		end
	FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	end
end

function FAIO.WindRunnerCombo(myHero, enemy)

	if not Menu.IsEnabled(FAIO.optionHeroWindrunner) then return end
	if not NPC.IsEntityInRange(myHero, enemy, 3000)	then return end

	local shackleShot = NPC.GetAbilityByIndex(myHero, 0)
	local windRun = NPC.GetAbilityByIndex(myHero, 2)
	local focusFire = NPC.GetAbility(myHero, "windrunner_focusfire")
	local myMana = NPC.GetMana(myHero)
	
	local branch = NPC.GetItem(myHero, "item_branches", true)
	local blink = NPC.GetItem(myHero, "item_blink", true)

	FAIO.itemUsage(myHero, enemy)

	if FAIO.canEnemyBeShackledWithTree(myHero, enemy) == true or FAIO.getEnemyBeShackledWithNPC(myHero, enemy) ~= nil then
		FAIO.enemyCanBeShackled = true
	else
		FAIO.enemyCanBeShackled = false
	end

	if Menu.IsKeyDown(FAIO.optionComboKey) and Entity.GetHealth(enemy) > 0 and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and FAIO.heroCanCastSpells(myHero, enemy) == true then
		if FAIO.getEnemyBeShackledWithNPC(myHero, enemy) ~= nil then
			if shackleShot and Ability.IsCastable(shackleShot, myMana) then
				Ability.CastTarget(shackleShot, FAIO.getEnemyBeShackledWithNPC(myHero, enemy))
				return
			end
		elseif FAIO.canEnemyBeShackledWithTree(myHero, enemy) == true then
			if shackleShot and Ability.IsCastable(shackleShot, myMana) then
				Ability.CastTarget(shackleShot, enemy)
				return
			end
		else
			if FAIO.getEnemyShackledBestPosition(myHero, enemy, 1150):__tostring() ~= Vector():__tostring() then
				if blink and Ability.IsReady(blink) and Menu.IsEnabled(FAIO.optionHeroWindrunnerBlinkShackle) then
					Ability.CastPosition(blink, FAIO.getEnemyShackledBestPosition(myHero, enemy, 1150))
					return
				end

			else
				if Menu.IsEnabled(FAIO.optionHeroWindrunnerBranchShackle) then
					if branch and NPC.IsEntityInRange(myHero, enemy, 750) then
						if blink and Ability.IsReady(blink) then	
							if shackleShot and Ability.IsCastable(shackleShot, myMana) then
								Ability.CastTarget(shackleShot, enemy)
								return
							end
							if blink and Ability.IsReady(blink) and not Ability.IsReady(shackleShot) then
								Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Rotated(45):Normalized():Scaled(200))
								Ability.CastPosition(branch, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(150))
								return
							end
						end
					end
				end
			end
		end
	FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	end

	if NPC.IsEntityInRange(myHero, enemy, NPC.GetAttackRange(myHero)) and Entity.GetHealth(enemy) > 0 and FAIO.heroCanCastSpells(myHero, enemy) == true then
		if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then

			local shackleMod = NPC.GetModifier(enemy, "modifier_windrunner_shackle_shot")
				if not shackleMod then return end
			local shackleTime = Modifier.GetCreationTime(shackleMod) + Modifier.GetDuration(shackleMod)

			if NPC.HasModifier(enemy, "modifier_windrunner_shackle_shot") and Modifier.GetDuration(shackleMod) >= 1.5 and Menu.IsEnabled(FAIO.optionHeroWindrunnerUlt) then
				if focusFire and Ability.IsCastable(focusFire, myMana) then
					Ability.CastTarget(focusFire, enemy)
					return
				end
				if Menu.GetValue(FAIO.optionHeroWindrunnerWind) > 0 then
					if windRun and Ability.IsCastable(windRun, myMana) and #Wrap.HeroesInRadius(myHero, 600, Enum.TeamType.TEAM_ENEMY) >= Menu.GetValue(FAIO.optionHeroWindrunnerWind) then
						Ability.CastNoTarget(windRun)
						return
					end
				end
			end
		end
	end
	
end

function FAIO.windrunnerDrawShackleIndicator(myHero)

	if not myHero then return end
	if not Menu.IsEnabled(FAIO.optionWindrunnerDrawIndicator) then return end
	
	if FAIO.enemyCanBeShackled == false then return end

	local enemy = FAIO.targetChecker(Input.GetNearestHeroToCursor(Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY))
		if not enemy then return end
		if not NPC.IsPositionInRange(enemy, Input.GetWorldCursorPos(), 500, 0) then return end

	local pos = Entity.GetAbsOrigin(enemy)
	local posY = NPC.GetHealthBarOffset(enemy)
		pos:SetZ(pos:GetZ() + posY)
			
	local x, y, visible = Renderer.WorldToScreen(pos)

	if visible then
		Renderer.SetDrawColor(50,205,50,255)
		Renderer.DrawText(FAIO.font, x-30, y-80, "shackle", 0)
	end
		
end

function FAIO.TimberCombo(myHero, enemy)

	if not Menu.IsEnabled(FAIO.optionHeroTimber) then return end
	
	if (os.clock() - FAIO.lastTick) < FAIO.delay then return end

	local whirlingDeath = NPC.GetAbilityByIndex(myHero, 0)
	local timberChain = NPC.GetAbilityByIndex(myHero, 1)
	local chakram = NPC.GetAbility(myHero, "shredder_chakram")
	local chakramReturn = NPC.GetAbility(myHero, "shredder_return_chakram")
	local chakramAgha = NPC.GetAbility(myHero, "shredder_chakram_2")
	local chakramAghaReturn = NPC.GetAbility(myHero, "shredder_return_chakram_2")

	local aghanims = NPC.GetItem(myHero, "item_ultimate_scepter", true)
	local blink = NPC.GetItem(myHero, "item_blink", true)
	
	local myMana = NPC.GetMana(myHero)

	local rangeChecker = 500
	if blink and Ability.IsReady(blink) then
		rangeChecker = 1150
	end

	if Menu.GetValue(FAIO.optionHeroTimberWhirling) > 0 and FAIO.isHeroChannelling(myHero) == false and FAIO.IsHeroInvisible(myHero) == false then
		if enemy and NPC.IsEntityInRange(myHero, enemy, 270) then
			if whirlingDeath and Ability.IsCastable(whirlingDeath, myMana) then
				if (NPC.HasModifier(myHero, "modifier_shredder_timer_chain") and #Wrap.TInRadius(enemy, 270, true) > 0) then
					if #Wrap.TInRadius(myHero, 270, true) > 0 then
						Ability.CastNoTarget(whirlingDeath)
						FAIO.makeDelay(0.1)
						return
					end
				else
					if Menu.GetValue(FAIO.optionHeroTimberWhirling) == 2 then
						Ability.CastNoTarget(whirlingDeath)
						FAIO.makeDelay(0.1)
						return
					else
						if Menu.IsKeyDown(FAIO.optionComboKey) then
							Ability.CastNoTarget(whirlingDeath)
							FAIO.makeDelay(0.1)
							return
						end
					end
				end
			end
		end
	end

	FAIO.itemUsage(myHero, enemy)
	
	if enemy and Menu.IsKeyDown(FAIO.optionComboKey) and Entity.GetHealth(enemy) > 0 and FAIO.heroCanCastSpells(myHero, enemy) == true then
		if FAIO.TimberIsTreeInRangeForChain(myHero, enemy) ~= nil or FAIO.TimberGetBestChainPos(myHero, enemy, rangeChecker):__tostring() ~= Vector():__tostring() then
			if FAIO.TimberIsTreeInRangeForChain(myHero, enemy) ~= nil then
				if timberChain and Ability.IsCastable(timberChain, myMana) then
					Ability.CastPosition(timberChain, Entity.GetAbsOrigin(FAIO.TimberIsTreeInRangeForChain(myHero, enemy)))
					FAIO.lastCastTime3 = GameRules.GetGameTime() + (((Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Length2D() + 275) / (1200 + Ability.GetLevel(timberChain) * 400))
					FAIO.makeDelay(0.1)
					return
				end
			else
				if blink and Ability.IsReady(blink) and Menu.IsEnabled(FAIO.optionHeroTimberBlink) then
					if FAIO.TimberGetBestChainPos(myHero, enemy, rangeChecker):__tostring() ~= Vector():__tostring() then
						Ability.CastPosition(blink, FAIO.TimberGetBestChainPos(myHero, enemy, 1150))
						return
					end
				elseif (not blink or (blink and not Ability.IsReady(blink)) or not Menu.IsEnabled(FAIO.optionHeroTimberBlink)) and Ability.IsReady(timberChain) then
					if FAIO.TimberGetBestChainPos(myHero, enemy, rangeChecker):__tostring() ~= Vector():__tostring() then
						FAIO.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, FAIO.TimberGetBestChainPos(myHero, enemy, 500), myHero)
						return
					else
						if Ability.IsReady(timberChain) then
							FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
							return
						end
					end
				end
			end
		else
			if Menu.IsEnabled(FAIO.optionHeroTimberUlt) and NPC.IsEntityInRange(myHero, enemy, 700) then
				if GameRules.GetGameTime() < FAIO.lastCastTime3 then
					return
				else
					if not Ability.IsHidden(chakram) and not Ability.IsInAbilityPhase(timberChain) then
						if chakram and Ability.IsCastable(chakram, myMana) then
							local chakramPrediction = Ability.GetCastPoint(chakram) + (Entity.GetAbsOrigin(enemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 900) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
							Ability.CastPosition(chakram, FAIO.castLinearPrediction(myHero, enemy, chakramPrediction))
							FAIO.lastCastTime = 1
							FAIO.makeDelay(0.3)
							return
						end
					elseif not Ability.IsHidden(chakramAgha) and Ability.IsHidden(chakram) and not Ability.IsInAbilityPhase(timberChain) then
						if chakramAgha and Ability.IsCastable(chakramAgha, myMana) then
							local chakramPrediction = Ability.GetCastPoint(chakram) + (Entity.GetAbsOrigin(enemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 900) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
							Ability.CastPosition(chakramAgha, FAIO.castLinearPrediction(myHero, enemy, chakramPrediction))
							FAIO.lastCastTime2 = 1
							FAIO.makeDelay(0.3)
							return
						end
					end
				end
			end
		FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
		end
	end

	if enemy then
		if not Ability.IsHidden(chakramReturn) and FAIO.lastCastTime == 1 and FAIO.heroCanCastSpells(myHero, enemy) == true then
			if chakramReturn and Ability.IsCastable(chakramReturn, myMana) and (Ability.SecondsSinceLastUse(chakram) >= 1 and not NPC.HasModifier(enemy, "modifier_shredder_chakram_debuff")) or (NPC.HasModifier(enemy, "modifier_shredder_chakram_debuff") and Ability.SecondsSinceLastUse(chakram) >= (Menu.GetValue(FAIO.optionHeroTimberUltTiming) * 0.5)) then
				Ability.CastNoTarget(chakramReturn)
				FAIO.lastCastTime = 0
				FAIO.makeDelay(0.3)
				return
			end
		end
		if not Ability.IsHidden(chakramAghaReturn) and FAIO.lastCastTime2 == 1 and FAIO.heroCanCastSpells(myHero, enemy) == true then
			if chakramAghaReturn and Ability.IsCastable(chakramAghaReturn, myMana) and (Ability.SecondsSinceLastUse(chakramAgha) >= 1 and not NPC.HasModifier(enemy, "modifier_shredder_chakram_debuff")) or (NPC.HasModifier(enemy, "modifier_shredder_chakram_debuff") and Ability.SecondsSinceLastUse(chakramAgha) >= (Menu.GetValue(FAIO.optionHeroTimberUltTiming) * 0.5)) then
				Ability.CastNoTarget(chakramAghaReturn)
				FAIO.lastCastTime2 = 0
				FAIO.makeDelay(0.3)
				return
			end
		end
	else
		if not Ability.IsHidden(chakramReturn) and FAIO.lastCastTime == 1 and FAIO.heroCanCastSpells(myHero, enemy) == true then
			if chakramReturn and Ability.IsCastable(chakramReturn, myMana) and Ability.SecondsSinceLastUse(chakram) >= 1 then
				Ability.CastNoTarget(chakramReturn)
				FAIO.lastCastTime = 0
				FAIO.makeDelay(0.1)
				return
			end
		end
		if not Ability.IsHidden(chakramAghaReturn) and FAIO.lastCastTime2 == 1 and FAIO.heroCanCastSpells(myHero, enemy) == true then
			if chakramAghaReturn and Ability.IsCastable(chakramAghaReturn, myMana) and Ability.SecondsSinceLastUse(chakramAgha) >= 1 then
				Ability.CastNoTarget(chakramAghaReturn)
				FAIO.lastCastTime2 = 0
				FAIO.makeDelay(0.1)
				return
			end
		end
	end

	if Menu.IsKeyDown(FAIO.optionHeroTimberPanicKey) and FAIO.heroCanCastSpells(myHero, enemy) == true then
		if FAIO.TimberPanic(myHero) ~= nil then
			Ability.CastPosition(timberChain, Entity.GetAbsOrigin(FAIO.TimberPanic(myHero)))
			return
		end
	end

	if Menu.IsKeyDown(FAIO.optionHeroTimberFastMoveKey) and FAIO.heroCanCastSpells(myHero, enemy) == true then
		if FAIO.TimberFastMove(myHero) ~= nil then
			Ability.CastPosition(timberChain, Entity.GetAbsOrigin(FAIO.TimberFastMove(myHero)))
			return
		else
			FAIO.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Input.GetWorldCursorPos(), myHero)
			return
		end
	end		

end

function FAIO.TimberFastMove(myHero)

	if not myHero then return end

	local myMana = NPC.GetMana(myHero)
	local timberChain = NPC.GetAbilityByIndex(myHero, 1)
		if not timberChain then return end
		if not Ability.IsCastable(timberChain, myMana) then return end

	local chainCastRange = Ability.GetCastRange(timberChain)

	local cursorPos = Input.GetWorldCursorPos()

	local chainTree
	local minDis = 99999

	if next(FAIO.TimberGetTreesFastMoveCursor(myHero)) ~= nil then
		chainTree = FAIO.TimberGetTreesFastMoveCursor(myHero)[1][2]
	end

	if chainTree ~= nil then
		return chainTree
	end
	return

end

function FAIO.TimberPanic(myHero)

	if not myHero then return end

	local myMana = NPC.GetMana(myHero)

	local timberChain = NPC.GetAbilityByIndex(myHero, 1)
		if not timberChain then return end
		if not Ability.IsCastable(timberChain, myMana) then return end

	local chainCastRange = Ability.GetCastRange(timberChain)

	local chainTree
	local minDis = 99999
	local maxDis = 0

	if Menu.GetValue(FAIO.optionHeroTimberPanicDir) < 2 then
		if Menu.GetValue(FAIO.optionHeroTimberPanicDir) == 0 then
			if next(FAIO.TimberGetEscapeChainTreesFountain(myHero)) ~= nil then
				chainTree = FAIO.TimberGetEscapeChainTreesFountain(myHero)[1][2]
			end
		else
			if next(FAIO.TimberGetEscapeChainTrees(myHero)) ~= nil then
				chainTree = FAIO.TimberGetEscapeChainTrees(myHero)[1][2]
			end
		end
	else
		local tree = Input.GetNearestTreeToCursor(true)
		if tree ~= nil then
			local dismyHeroToTree = (Entity.GetAbsOrigin(tree) - Entity.GetAbsOrigin(myHero)):Length2D()
			if dismyHeroToTree < chainCastRange then
				chainTree = tree
			else
				if FAIO.TimberFastMove(myHero) ~= nil then
					chainTree = FAIO.TimberFastMove(myHero)
				end
			end
		end
	end

	if chainTree ~= nil then
		return chainTree
	end
	return

end

function FAIO.EmberCombo(myHero, enemy)

	if not Menu.IsEnabled(FAIO.optionHeroEmber) then return end
	if not NPC.IsEntityInRange(myHero, enemy, 3000)	then return end

	local chains = NPC.GetAbility(myHero, "ember_spirit_searing_chains")
	local fist = NPC.GetAbility(myHero, "ember_spirit_sleight_of_fist")
	local flameGuard = NPC.GetAbility(myHero, "ember_spirit_flame_guard")
	local activeRemnant = NPC.GetAbility(myHero, "ember_spirit_activate_fire_remnant")
	local remnant = NPC.GetAbility(myHero, "ember_spirit_fire_remnant")
	local blink = NPC.GetItem(myHero, "item_blink", true)

	local myMana = NPC.GetMana(myHero)
	local remnantModifier = NPC.GetModifier(myHero, "modifier_ember_spirit_fire_remnant_charge_counter")

	local fistRange = 650
		if fist then
			fistRange = fistRange + Ability.GetLevelSpecialValueFor(fist, "radius")
		end
		
	FAIO.itemUsage(myHero, enemy)

	local myPos = Entity.GetAbsOrigin(myHero)
	if NPC.HasModifier(myHero, "modifier_ember_spirit_sleight_of_fist_caster_invulnerability") then
		if chains and Ability.IsCastable(chains, myMana) then
			if NPC.IsEntityInRange(myHero, enemy, 85) then
				Ability.CastNoTarget(chains)
			end
		end
	end

	if Menu.IsKeyDown(FAIO.optionComboKey) and Entity.GetHealth(enemy) > 0 and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and FAIO.heroCanCastSpells(myHero, enemy) == true then
		if not NPC.IsEntityInRange(myHero, enemy, fistRange) then
			if blink and Ability.IsReady(blink) and not NPC.HasModifier(myHero, "modifier_ember_spirit_sleight_of_fist_caster_invulnerability") and NPC.IsEntityInRange(myHero, enemy, 1150 + fistRange) then
				Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(math.abs((Entity.GetAbs(Origin(myHero) - Entity.GetAbsOrigin(enemy)):Length2D() - 1150)))))
				return
			end
		else
			
			if fist and Ability.IsCastable(fist, myMana) then
				FAIO.noItemCastFor(0.5)
				if NPC.IsEntityInRange(myHero, enemy, 650) then
					Ability.CastPosition(fist, Entity.GetAbsOrigin(enemy))
				else
					Ability.CastPosition(fist, (Entity.GetAbsOrigin(myHero) + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(690)))
				end
			end

			if flameGuard and Ability.IsCastable(flameGuard, myMana) and not NPC.HasModifier(myHero, "modifier_ember_spirit_sleight_of_fist_caster_invulnerability") and NPC.HasModifier(enemy, "modifier_ember_spirit_searing_chains") then
				Ability.CastNoTarget(flameGuard)
			end
	
			if remnant and Ability.IsReady(remnant) and not NPC.HasModifier(myHero, "modifier_ember_spirit_sleight_of_fist_caster_invulnerability") and NPC.GetMana(myHero) >= Ability.GetManaCost(activeRemnant) and NPC.HasModifier(enemy, "modifier_ember_spirit_searing_chains") then
				local remnantCharges = Modifier.GetStackCount(remnantModifier)
				if Menu.GetValue(FAIO.optionHeroEmberUlt) == 0 then
					if remnantCharges == 3 then
						Ability.CastPosition(remnant, Entity.GetAbsOrigin(enemy))
						Ability.CastPosition(remnant, Entity.GetAbsOrigin(enemy))
						Ability.CastPosition(remnant, Entity.GetAbsOrigin(enemy))
						FAIO.lastTick = os.clock()			
					end
					if remnantCharges == 2 then
						Ability.CastPosition(remnant, Entity.GetAbsOrigin(enemy))
						Ability.CastPosition(remnant, Entity.GetAbsOrigin(enemy))
						FAIO.lastTick = os.clock()
					end
					if remnantCharges == 1 then
						Ability.CastPosition(remnant, Entity.GetAbsOrigin(enemy))
						FAIO.lastTick = os.clock()
					end
				end
				if Menu.GetValue(FAIO.optionHeroEmberUlt) == 1 then
					if remnantCharges > 2 and FAIO.SleepReady(3) then
						Ability.CastPosition(remnant, Entity.GetAbsOrigin(enemy))
						FAIO.lastTick = os.clock()
					end
					if remnantCharges >= 2 and FAIO.SleepReady(3) then
						Ability.CastPosition(remnant, Entity.GetAbsOrigin(enemy))
						FAIO.lastTick = os.clock()
					end
				end
			end
			if activeRemnant and Ability.IsCastable(activeRemnant, myMana) and NPC.HasModifier(myHero, "modifier_ember_spirit_fire_remnant_timer") and NPC.HasModifier(enemy, "modifier_ember_spirit_searing_chains") then
				for i = 1, NPCs.Count() do 
				local npc = NPCs.Get(i)
					if npc and npc ~= myHero and Entity.IsSameTeam(myHero, npc) then
						if Entity.GetOwner(myHero) == Entity.GetOwner(npc) or Entity.OwnedBy(npc, myHero) then
							if NPC.GetUnitName(npc) == "npc_dota_ember_spirit_remnant" then
								if NPC.IsEntityInRange(npc, enemy, 350) then
									Ability.CastPosition(activeRemnant, Entity.GetAbsOrigin(npc))
									break
								end
							end
						end
					end
				end
			end
		end
	FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	end	
end

function FAIO.UrsaCombo(myHero, enemy)

	if not Menu.IsEnabled(FAIO.optionHeroUrsa) then return end
	if not NPC.IsEntityInRange(myHero, enemy, 3000)	then return end

	local earthShock = NPC.GetAbilityByIndex(myHero, 0)
	local overPower = NPC.GetAbilityByIndex(myHero, 1)
	local enrage = NPC.GetAbility(myHero, "ursa_enrage")

	local blink = NPC.GetItem(myHero, "item_blink", true)

	local myMana = NPC.GetMana(myHero)
	FAIO.itemUsage(myHero, enemy)

	local earthShockOffset = 315
		if NPC.IsRunning(enemy) then
			earthShockOffset = 200
		end

	if Menu.IsKeyDown(FAIO.optionComboKey) and Entity.GetHealth(enemy) > 0 then
		if FAIO.heroCanCastSpells(myHero, enemy) == true then
			if overPower and Ability.IsCastable(overPower, myMana) and NPC.IsEntityInRange(myHero, enemy, 1200) and not NPC.HasModifier(myHero, "modifier_ursa_overpower") then
				Ability.CastNoTarget(overPower)
				FAIO.lastTick = os.clock()
				return
			end
			if FAIO.SleepReady(0.2) then
				if not NPC.IsEntityInRange(myHero, enemy, earthShockOffset) then
					if blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1150) then
						Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy))
						return
					end
				else
					if earthShock and Ability.IsCastable(earthShock, myMana) then
						Ability.CastNoTarget(earthShock)
						FAIO.lastTick = os.clock()
						return
					end
					if Menu.IsEnabled(FAIO.optionHeroUrsaEnrageCombo) then
						if enrage and Ability.IsCastable(enrage, myMana) then
							Ability.CastNoTarget(enrage)
							FAIO.lastTick = os.clock()
							return
						end
					end
				end
			end
		end
		FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
		return
	end

	if Menu.IsEnabled(FAIO.optionHeroUrsaEnrage) then
		if enrage and Ability.IsCastable(enrage, myMana) then
			if FAIO.isHeroChannelling(myHero) == false and FAIO.IsHeroInvisible(myHero) == false then		
				if (Entity.GetHealth(myHero) / Entity.GetMaxHealth(myHero)) <= (Menu.GetValue(FAIO.optionHeroUrsaEnrageHP) / 100) and #Wrap.HeroesInRadius(myHero, 650, Enum.TeamType.TEAM_ENEMY) >= Menu.GetValue(FAIO.optionHeroUrsaEnrageEnemies) then
					if FAIO.SleepReady(0.25) then
						Ability.CastNoTarget(enrage)
						return
					end
				end
			end
		end
	end
end

function FAIO.TACombo(myHero, enemy)

	if not Menu.IsEnabled(FAIO.optionHeroTA) then return end
	if not NPC.IsEntityInRange(myHero, enemy, 3000)	then return end

	local refraction = NPC.GetAbilityByIndex(myHero, 0)
	local meld = NPC.GetAbilityByIndex(myHero, 1)
	local psionicTrap = NPC.GetAbility(myHero, "templar_assassin_psionic_trap")
	local trap = NPC.GetAbility(myHero, "templar_assassin_trap")

	local blink = NPC.GetItem(myHero, "item_blink", true)

	local myMana = NPC.GetMana(myHero)
	FAIO.itemUsage(myHero, enemy)

	local myAttackRange = NPC.GetAttackRange(myHero)
		if NPC.HasItem(myHero, "item_dragon_lance", true) or NPC.HasItem(myHero, "item_hurricane_pike", true) then
			myAttackRange = myAttackRange + 140
		end

	local refractionModifier = NPC.GetModifier(myHero, "modifier_templar_assassin_refraction_damage")
	local meldModifier = NPC.GetModifier(myHero, "modifier_templar_assassin_meld")

	if Menu.IsEnabled(FAIO.optionHeroTAHarass) then
		if Menu.IsKeyDown(FAIO.optionHeroTAHarassKey) then
			if FAIO.TApsiBladesSpill(myHero, enemy, myAttackRange) ~= nil then
				local spillNPC = FAIO.TApsiBladesSpill(myHero, enemy, myAttackRange)
				FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", spillNPC, nil)
				return
			else
				if FAIO.TApsiBladesSpillBestPos(myHero, enemy, myAttackRange, Menu.GetValue(FAIO.optionHeroTAHarassRange)):__tostring() ~= Vector():__tostring() then
					local movePos = FAIO.TApsiBladesSpillBestPos(myHero, enemy, myAttackRange, Menu.GetValue(FAIO.optionHeroTAHarassRange))
					FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, movePos)
					return
				end
			end
		end
	end		

	if Menu.IsKeyDown(FAIO.optionComboKey) and Entity.GetHealth(enemy) > 0 and FAIO.heroCanCastSpells(myHero, enemy) == true then
		if NPC.IsEntityInRange(myHero, enemy, (1200 + myAttackRange/2)) then
			if refraction and Ability.IsCastable(refraction, myMana) then
				Ability.CastNoTarget(refraction)
			end
			if psionicTrap and Ability.IsCastable(psionicTrap, myMana) then
				Ability.CastPosition(psionicTrap, FAIO.castPrediction(myHero, enemy, Ability.GetCastPoint(psionicTrap) + 0.25 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)))
				FAIO.lastTick = os.clock()
				return
			end
			if FAIO.SleepReady(0.3) and trap and Ability.IsReady(trap) and Ability.SecondsSinceLastUse(psionicTrap) > 0 and Ability.SecondsSinceLastUse(psionicTrap) < 1 then
				Ability.CastNoTarget(trap)
				FAIO.lastTick = os.clock()
				return
			end
		end
		if not NPC.IsEntityInRange(myHero, enemy, myAttackRange) then
			if FAIO.SleepReady(0.3) then
				if FAIO.SleepReady(0.1) and blink and Ability.IsReady(blink) and Menu.IsEnabled(FAIO.optionHeroTABlink) and NPC.IsEntityInRange(myHero, enemy, (1150 + myAttackRange/2)) then
					Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(myAttackRange/2)))
					return
				end
			end
		else
			if FAIO.SleepReady(0.3) and meld and Ability.IsCastable(meld, myMana) then
				FAIO.noItemCastFor(0.1)
				Ability.CastNoTarget(meld)
				FAIO.lastTick = os.clock()
				return
			end
			if FAIO.SleepReady(0.1) and NPC.HasModifier(myHero, "modifier_templar_assassin_meld") then
				Player.AttackTarget(Players.GetLocal(), myHero, enemy, false)
				FAIO.lastTick = os.clock()
				return
			end
		end
	FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	end
		
end

function FAIO.isEnemyInSpillRange(myHero, spillNPC, enemy, spillRange)

	if not spillNPC then return false end
	if not enemy then return false end

	if Entity.IsSameTeam(myHero, spillNPC) then
		if Entity.GetHealth(spillNPC) > 0.5 * Entity.GetMaxHealth(spillNPC) then
			return false 
		end
	end

	if NPC.IsRunning(spillNPC) then return false end

	local enemyPos = FAIO.castPrediction(myHero, enemy, 0.75 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2))
		enemyPos:SetZ(0)

	local spillNPCpos = Entity.GetAbsOrigin(spillNPC)
		spillNPCpos:SetZ(0)

	local myPos = 	Entity.GetAbsOrigin(myHero)
		myPos:SetZ(0)

	if (spillNPCpos - enemyPos):Length2D() > spillRange then
		return false
	end

	local vecmyHeroTospillNPC = spillNPCpos - myPos
	local vecspillNPCToEnemy = enemyPos - spillNPCpos

	local searchPoint = spillNPCpos + vecmyHeroTospillNPC:Normalized():Scaled(vecspillNPCToEnemy:Length2D())

	if math.floor((enemyPos - searchPoint):Length2D()) <= 37 then
		return true
	end

	return false

end

function FAIO.TApsiBladesSpillBestPos(myHero, enemy, myAttackRange, searchRange)

	if not myHero then return Vector() end
	if not enemy then return Vector() end

	local myMana = NPC.GetMana(myHero)
	local psiBlades = NPC.GetAbility(myHero, "templar_assassin_psi_blades")
		if not psiBlades then return Vector() end
		if Ability.GetLevel(psiBlades) < 1 then return Vector() end

	local spillRange = Ability.GetLevelSpecialValueFor(psiBlades, "attack_spill_range")

	local enemyPos = FAIO.castPrediction(myHero, enemy, 0.75 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2))

	local npcs = Wrap.UnitsInRadius(myHero, myAttackRange+searchRange, Enum.TeamType.TEAM_BOTH)
		if next(npcs) == nil then return Vector() end

		local spillPos = Vector()
		local minRange = 99999
			
		for _, targetNPC in ipairs(npcs) do
			if targetNPC then
				if Wrap.EIsNPC(targetNPC) and not Entity.IsDormant(targetNPC) and (NPC.IsCreep(targetNPC) or NPC.IsLaneCreep(targetNPC) or NPC.IsNeutral(targetNPC)) and Wrap.EIsAlive(targetNPC) and not NPC.IsRunning(targetNPC) then
					local myDisToNPC = (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(targetNPC)):Length()
					local myDisToEnemy = (Entity.GetAbsOrigin(myHero) - enemyPos):Length()
					local disEnemyToNPC = (enemyPos - Entity.GetAbsOrigin(targetNPC)):Length()
					if disEnemyToNPC < spillRange - 50 and myDisToNPC < myDisToEnemy then
						if ((Entity.IsSameTeam(myHero, targetNPC) and Entity.GetHealth(targetNPC) < 0.5 * Entity.GetMaxHealth(targetNPC)) or not Entity.IsSameTeam(myHero, targetNPC)) then
							local vecEnemyTospillNPC = Entity.GetAbsOrigin(targetNPC) - enemyPos
							local adjustedNPCPos = Entity.GetAbsOrigin(targetNPC) + vecEnemyTospillNPC:Normalized():Scaled(100)
							local searchPos = adjustedNPCPos + vecEnemyTospillNPC:Normalized():Scaled(myAttackRange - 105)
							local closestPoint = FAIO.GetClosestPoint(adjustedNPCPos, searchPos, Entity.GetAbsOrigin(myHero), true)
							local myDisToClostestPoint = (Entity.GetAbsOrigin(myHero) - closestPoint):Length()
							if myDisToClostestPoint < searchRange then
								if myDisToClostestPoint < minRange then
									spillPos = closestPoint
									minRange = myDisToClostestPoint
								end
							end
						end
					end
				end
			end
		end

		if spillPos:__tostring() ~= Vector():__tostring() and minRange > 25 then
			return spillPos
		end

	return Vector()

end

function FAIO.TApsiBladesSpill(myHero, enemy, myAttackRange)

	if not myHero then return end
	if not enemy then return end

	local myMana = NPC.GetMana(myHero)
	local psiBlades = NPC.GetAbility(myHero, "templar_assassin_psi_blades")
		if not psiBlades then return end
		if Ability.GetLevel(psiBlades) < 1 then return end

	local spillRange = Ability.GetLevelSpecialValueFor(psiBlades, "attack_spill_range")

	local npcs = Wrap.UnitsInRadius(myHero, myAttackRange, Enum.TeamType.TEAM_BOTH)
		if next(npcs) == nil then return end

		local spillNPC
			
		for _, targetNPC in ipairs(npcs) do
			if targetNPC then
				if Wrap.EIsNPC(targetNPC) and not Entity.IsDormant(targetNPC) and (NPC.IsCreep(targetNPC) or NPC.IsLaneCreep(targetNPC) or NPC.IsNeutral(targetNPC)) and Wrap.EIsAlive(targetNPC) then
					if FAIO.isEnemyInSpillRange(myHero, targetNPC, enemy, spillRange) == true then
						spillNPC = targetNPC
					end
				end
			end
		end

		if spillNPC then
			return spillNPC
		end
	
	return

end

function FAIO.LegionCombo(myHero, enemy)

	if not Menu.IsEnabled(FAIO.optionHeroLegion) then return end

	local odds = NPC.GetAbilityByIndex(myHero, 0)
	local pressTheAttack = NPC.GetAbilityByIndex(myHero, 1)
    	local duel = NPC.GetAbility(myHero, "legion_commander_duel")

	local Blademail = NPC.GetItem(myHero, "item_blade_mail", true)
	local blink = NPC.GetItem(myHero, "item_blink", true)

	local myMana = NPC.GetMana(myHero)

	FAIO.itemUsage(myHero, enemy)

	if Menu.IsEnabled(FAIO.optionHeroLegionAutoSave) then
		FAIO.LegionSaveAlly(myHero, myMana, pressTheAttack)
	end

	if enemy and Wrap.EIsAlive(enemy) then
		if Menu.IsKeyDown(FAIO.optionComboKey) then
			if FAIO.heroCanCastSpells(myHero, enemy) == true then 
				if not (NPC.HasModifier(myHero, "modifier_item_invisibility_edge_windwalk") or NPC.HasModifier(myHero, "modifier_item_silver_edge_windwalk")) then
					if not NPC.IsEntityInRange(myHero, enemy, Menu.GetValue(FAIO.optionHeroLegionBlinkRange)) then
						if blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1199) then
							if Blademail and Ability.IsCastable(Blademail, myMana) and Ability.IsCastable(duel, myMana) then
								Ability.CastNoTarget(Blademail)
								return
							end
							if pressTheAttack and Ability.IsCastable(pressTheAttack, myMana) then
								Ability.CastTarget(pressTheAttack, myHero)
								FAIO.lastTick = os.clock()
								return
							end
							if FAIO.SleepReady(0.2) then
								Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy))
								return
							end
						end
					end

					if NPC.IsEntityInRange(myHero, enemy, 200) then
						if Blademail and Ability.IsCastable(Blademail, myMana) and Ability.IsCastable(duel, myMana) then
							Ability.CastNoTarget(Blademail)
							return
						end
						if NPC.IsLinkensProtected(enemy) then
							if FAIO.LinkensBreakerNew(myHero) ~= nil then
								Ability.CastTarget(NPC.GetItem(myHero, FAIO.LinkensBreakerNew(myHero), true), enemy)
								return
							end
						end
						if NPC.IsStunned(enemy) then
							if pressTheAttack and Ability.IsCastable(pressTheAttack, myMana) then
								Ability.CastTarget(pressTheAttack, myHero)
								FAIO.lastTick = os.clock()
								return
							end
						end
					end
					if NPC.IsEntityInRange(myHero, enemy, 150) then
						if duel and Ability.IsCastable(duel, myMana) then
							if NPC.HasItem(myHero, "item_armlet", true) and Menu.IsEnabled(FAIO.optionItemArmlet) and Menu.IsEnabled(FAIO.optionItemArmletCombo) then
								if FAIO.armletCurrentHPGain > 0 then
									Ability.CastTarget(duel, enemy)
									return
								end
							else
								Ability.CastTarget(duel, enemy)
								return
							end
						end
					end
				end
			end
			if duel and Ability.IsReady(duel) and Ability.IsCastable(duel, myMana) and FAIO.heroCanCastSpells(myHero, enemy) == true and not NPC.IsEntityInRange(myHero, enemy, 150) then
				local rotationVec = Entity.GetRotation(enemy):GetForward():Normalized()
				local pos = Entity.GetAbsOrigin(enemy) + rotationVec:Scaled(100)
				FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, pos)
			else	
				FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
			end
		end
	end

		

end

function FAIO.LegionSaveAlly(myHero, myMana, pressTheAttack)

	if not myHero then return end
	if not pressTheAttack then return end
		if not Ability.IsCastable(pressTheAttack, myMana) then return end

	if FAIO.heroCanCastItems(myHero) == false then return end
	if FAIO.isHeroChannelling(myHero) == true then return end
	if FAIO.IsHeroInvisible(myHero) == true then return end

	local teamMatesAround = Wrap.HeroesInRadius(myHero, 690, Enum.TeamType.TEAM_FRIEND)
	if next(teamMatesAround) ~= nil then
		for _, ally in ipairs(teamMatesAround) do
			if ally and Entity.IsHero(ally) and not NPC.IsIllusion(ally) and Wrap.EIsAlive(ally) then
				if FAIO.IsNPCinDanger(myHero, ally) then
					Ability.CastTarget(pressTheAttack, ally)
					break
					return
				end
			end
		end
	end

end

function FAIO.SlardarCombo(myHero, enemy)

	if not Menu.IsEnabled(FAIO.optionHeroSlardar) then return end
	if not NPC.IsEntityInRange(myHero, enemy, 3000)	then return end

	local sprint = NPC.GetAbilityByIndex(myHero, 0)
	local crush = NPC.GetAbilityByIndex(myHero, 1)
	local haze = NPC.GetAbility(myHero, "slardar_amplify_damage")

	local blink = NPC.GetItem(myHero, "item_blink", true)

	local myMana = NPC.GetMana(myHero)
	FAIO.itemUsage(myHero, enemy)

	local crushRadius = 300
		if NPC.IsRunning(enemy) then
			crushRadius = 200
		end

	if Menu.IsKeyDown(FAIO.optionComboKey) and Entity.GetHealth(enemy) > 0 and FAIO.heroCanCastSpells(myHero, enemy) == true then
		if not NPC.IsEntityInRange(myHero, enemy, crushRadius) then
			if not (NPC.HasModifier(myHero, "modifier_item_invisibility_edge_windwalk") or NPC.HasModifier(myHero, "modifier_item_silver_edge_windwalk")) then
				if blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1150) then
					if Menu.GetValue(FAIO.optionHeroSlardarStyle) == 0 then
						Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy))
						return
					else
						local bestPos = FAIO.getBestPosition(Wrap.HInRadius(Entity.GetAbsOrigin(enemy), 660, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY), 330)
						if bestPos ~= nil then
							Ability.CastPosition(blink, bestPos)
							return
						end
					end
				end
			end
			if NPC.HasModifier(myHero, "modifier_item_invisibility_edge_windwalk") or NPC.HasModifier(myHero, "modifier_item_silver_edge_windwalk") then
				if FAIO.SleepReady(0.1) then
					Player.AttackTarget(Players.GetLocal(), myHero, enemy, false)
					FAIO.lastTick = os.clock()
					return
				end
			end
		else
			
			if NPC.HasModifier(myHero, "modifier_item_invisibility_edge_windwalk") or NPC.HasModifier(myHero, "modifier_item_silver_edge_windwalk") then
				if FAIO.SleepReady(0.1) then
					Player.AttackTarget(Players.GetLocal(), myHero, enemy, false)
					FAIO.lastTick = os.clock()
					return
				end
			else
				
				if crush and Ability.IsCastable(crush, myMana) and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
					Ability.CastNoTarget(crush)
					FAIO.lastTick = os.clock()
					return
				end
				if FAIO.SleepReady(0.3) and NPC.IsLinkensProtected(enemy) then
					if FAIO.LinkensBreakerNew(myHero) ~= nil then
						Ability.CastTarget(NPC.GetItem(myHero, FAIO.LinkensBreakerNew(myHero), true), enemy)
						return
					end
				end
				if FAIO.SleepReady(0.3) and haze and Ability.IsCastable(haze, myMana) and NPC.HasModifier(enemy, "modifier_stunned") then
					Ability.CastTarget(haze, enemy)
					return
				end
				if not NPC.IsStunned(enemy) and not Ability.IsReady(crush) then
					if NPC.GetMoveSpeed(enemy) + 20 > NPC.GetMoveSpeed(myHero) then
						if sprint and Ability.IsCastable(sprint, myMana) then
							Ability.CastNoTarget(sprint)
							return
						end
					end
				end
			end
		end
	FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	end
end

function FAIO.ClinkzCombo(myHero, enemy)

	if not Menu.IsEnabled(FAIO.optionHeroClinkz) then return end

	local strafe = NPC.GetAbilityByIndex(myHero, 0)
	local searingArrows = NPC.GetAbilityByIndex(myHero, 1)
	local skeletonWalk = NPC.GetAbilityByIndex(myHero, 2)
	local deathPact = NPC.GetAbility(myHero, "clinkz_death_pact")

	local myMana = NPC.GetMana(myHero)
	local hurricanePike = NPC.GetItem(myHero, "item_hurricane_pike", true)

	FAIO.itemUsage(myHero, enemy)

	if Menu.IsEnabled(FAIO.optionHeroClinkzHarass) then
		if Menu.IsKeyDown(FAIO.optionHeroClinkzHarassKey) then
			FAIO.ClinkzAutoHarass(myHero, myMana, searingArrows)
		end
	end
	
	if enemy then
		if Menu.IsKeyDown(FAIO.optionComboKey) and Entity.GetHealth(enemy) > 0 then
			if NPC.IsEntityInRange(myHero, enemy, NPC.GetAttackRange(myHero)) then
				if strafe and Ability.IsCastable(strafe, myMana) and FAIO.heroCanCastSpells(myHero, enemy) == true then
					Ability.CastNoTarget(strafe)
					return
				end
			end
		FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
		end
	end					
end



function FAIO.ClinkzAutoHarass(myHero, myMana, searingArrows)

	if not myHero then return end

	if not searingArrows then return end
		if Ability.GetLevel(searingArrows) < 1 then return end
		if not Ability.IsCastable(searingArrows, myMana) then return end

	if FAIO.heroCanCastSpells(myHero, enemy) == false then return end
	if FAIO.isHeroChannelling(myHero) == true then return end 
	if FAIO.IsHeroInvisible(myHero) == true then return end

	local harassTarget = nil
		for _, hero in ipairs(Wrap.HeroesInRadius(myHero, NPC.GetAttackRange(myHero), Enum.TeamType.TEAM_ENEMY)) do
			if hero and Entity.IsHero(hero) and not Entity.IsDormant(hero) and not NPC.IsIllusion(hero) then 
				if Wrap.EIsAlive(hero) and not NPC.HasState(hero, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
        				harassTarget = hero
					break
				end
      			end			
		end

	local mousePos = Input.GetWorldCursorPos()
	if harassTarget ~= nil then
		if not FAIO.lastHitBackswingChecker(myHero) then
			Ability.CastTarget(searingArrows, harassTarget)
			return
		else
			if not NPC.IsPositionInRange(myHero, mousePos, 50, 0) then
				FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, mousePos)
				return
			end
		end
	else
		if not NPC.IsPositionInRange(myHero, mousePos, 50, 0) then
			FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, mousePos)
			return
		end
	end

	return

end

function FAIO.ClinkzAutoUlt(myHero)

	if not myHero then return end

	if not Menu.IsEnabled(FAIO.optionHeroClinkz) then return end
	if (os.clock() - FAIO.lastTick) < FAIO.delay then return end

	if FAIO.isHeroChannelling(myHero) == true then return end 
	if FAIO.IsHeroInvisible(myHero) == true then return end
	if FAIO.heroCanCastSpells(myHero, enemy) == false then return end
	
	local myMana = NPC.GetMana(myHero)

	local deathPact = NPC.GetAbility(myHero, "clinkz_death_pact")
		if not deathPact then return end
		if not Ability.IsCastable(deathPact, myMana) then return end

	local maxHPcreep
	local maxHP = 0
	for _, creeps in ipairs(Wrap.UnitsInRadius(myHero, 380, Enum.TeamType.TEAM_ENEMY)) do
		if creeps then
			if Entity.IsHero(creeps) then 
				return 
			end
      			if FAIO.IsCreepAncient(creeps) == false and (NPC.IsCreep(creeps) or NPC.IsLaneCreep(creeps)) and Entity.GetMaxHealth(creeps) >= 550 and Entity.GetHealth(creeps) >= maxHP then
           			maxHPcreep = creeps
            			maxHP = Entity.GetMaxHealth(creeps)
        		end
   		end
	end

	if next(Wrap.UnitsInRadius(myHero, 380, Enum.TeamType.TEAM_ENEMY)) == nil then
		maxHP = 0
	end

	if maxHPcreep then
		if not NPC.HasModifier(myHero, "modifier_clinkz_death_pact") then
			Ability.CastTarget(deathPact, maxHPcreep)
			FAIO.makeDelay(Ability.GetCastPoint(deathPact))
			return
		end
	end

end

function FAIO.QoPCombo(myHero, enemy)

	if not Menu.IsEnabled(FAIO.optionHeroQoP) then return end
	if not NPC.IsEntityInRange(myHero, enemy, 3000)	then return end

	local shadowStrike = NPC.GetAbilityByIndex(myHero, 0)
	local qopBlink = NPC.GetAbilityByIndex(myHero, 1)
	local screamOfPain = NPC.GetAbilityByIndex(myHero, 2)
	local sonicWave = NPC.GetAbility(myHero, "queenofpain_sonic_wave")

	local aghanims = NPC.GetItem(myHero, "item_ultimate_scepter", true)

	local myMana = NPC.GetMana(myHero)

	FAIO.itemUsage(myHero, enemy)

	if Menu.GetValue(FAIO.optionHeroQoPAutoUlt) > 0 then
		FAIO.QoPComboUltKS(myHero, sonicWave, aghanims, myMana)
	end

	if Menu.IsKeyDown(FAIO.optionComboKey) and Entity.GetHealth(enemy) > 0 and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and FAIO.heroCanCastSpells(myHero, enemy) == true then
		if not NPC.IsEntityInRange(myHero, enemy, 425) then
			if Menu.IsEnabled(FAIO.optionHeroQoPblink) then
				if qopBlink and Ability.IsCastable(qopBlink, myMana) and NPC.IsEntityInRange(myHero, enemy, 1500) then
					Ability.CastPosition(qopBlink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(350)))
					FAIO.lastTick = os.clock()
					return
				end
			end		
		else
			if NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(shadowStrike) + NPC.GetCastRangeBonus(myHero)) then
				if FAIO.SleepReady(0.1) and shadowStrike and Ability.IsCastable(shadowStrike, myMana) then
					Ability.CastTarget(shadowStrike, enemy)
					FAIO.lastTick = os.clock()
					return
				end
			end
			if FAIO.SleepReady(0.1) and screamOfPain and Ability.IsCastable(screamOfPain, myMana) then
				Ability.CastNoTarget(screamOfPain)
				return
			end
		end
	FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	end

end

function FAIO.QoPComboUltKS(myHero, sonicWave, aghanims, myMana)

	if not myHero then return end

	if not sonicWave then return end
		if not Ability.IsCastable(sonicWave, myMana) then return end

	if Menu.GetValue(FAIO.optionHeroQoPAutoUlt) == 0	then return end

	if FAIO.isHeroChannelling(myHero) == true then return end 
	if FAIO.IsHeroInvisible(myHero) == true then return end
	if FAIO.heroCanCastSpells(myHero, enemy) == false then return end

	for _, hero in ipairs(Wrap.HeroesInRadius(myHero, 1000, Enum.TeamType.TEAM_ENEMY)) do
		local target = FAIO.targetChecker(hero)
		if target and not NPC.HasModifier(target, "modifier_templar_assassin_refraction_absorb") then
			if NPC.GetUnitName(target) == "npc_dota_hero_skeleton_king" then
				local reincarnation = NPC.GetAbility(target, "skeleton_king_reincarnation")
				if reincarnation and Ability.IsReady(reincarnation) then
					break
					return
				end
			end

			local sonicDamage
			if aghanims or NPC.HasModifier(myHero, "modifier_item_ultimate_scepter_consumed") then
				sonicDamage = Ability.GetLevelSpecialValueFor(sonicWave, "damage_scepter")
			else
				sonicDamage = Ability.GetLevelSpecialValueFor(sonicWave, "damage")
			end
			if Menu.GetValue(FAIO.optionHeroQoPAutoUlt) == 1 then
				if aghanims or NPC.HasModifier(myHero, "modifier_item_ultimate_scepter_consumed") then
					if Entity.GetHealth(target) <= sonicDamage then
						Ability.CastPosition(sonicWave, (Entity.GetAbsOrigin(myHero) + (Entity.GetAbsOrigin(target) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(600)))
						break
						return
					end
				end
			elseif Menu.GetValue(FAIO.optionHeroQoPAutoUlt) == 2 then
				if Entity.GetHealth(target) <= sonicDamage then
					Ability.CastPosition(sonicWave, (Entity.GetAbsOrigin(myHero) + (Entity.GetAbsOrigin(target) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(600)))
					break
					return
				end
			end
		end
	end

end

function FAIO.SvenCombo(myHero, enemy)

	if not Menu.IsEnabled(FAIO.optionHeroSven) then return end
	if not NPC.IsEntityInRange(myHero, enemy, 3000)	then return end

	local stormHammer = NPC.GetAbilityByIndex(myHero, 0)
	local warCry = NPC.GetAbilityByIndex(myHero, 2)
	local godsStrength = NPC.GetAbility(myHero, "sven_gods_strength")

	local blink = NPC.GetItem(myHero, "item_blink", true)
	local maskOfMadness = NPC.GetItem(myHero, "item_mask_of_madness", true)

	local myMana = NPC.GetMana(myHero)

	FAIO.itemUsage(myHero, enemy)

	if Menu.IsKeyDown(FAIO.optionComboKey) and Entity.GetHealth(enemy) > 0 then
		if not NPC.IsEntityInRange(myHero, enemy, 450) then
			if not (NPC.HasModifier(myHero, "modifier_item_invisibility_edge_windwalk") or NPC.HasModifier(myHero, "modifier_item_silver_edge_windwalk")) then
				if blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1150) and FAIO.heroCanCastSpells(myHero, enemy) == true then
					if warCry and Ability.IsCastable(warCry, myMana) then
						Ability.CastNoTarget(warCry)
						return
					end
					if godsStrength and Ability.IsCastable(godsStrength, myMana) then
						Ability.CastNoTarget(godsStrength)
						FAIO.lastTick = os.clock()
						return
					end
					if FAIO.SleepReady(0.05) then
						Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy))
						return
					end
				end
			end
			if NPC.HasModifier(myHero, "modifier_item_invisibility_edge_windwalk") or NPC.HasModifier(myHero, "modifier_item_silver_edge_windwalk") and FAIO.heroCanCastSpells(myHero, enemy) == true then
				if FAIO.SleepReady(0.1) then
					Player.AttackTarget(Players.GetLocal(), myHero, enemy, false)
					FAIO.lastTick = os.clock()
					return
				end
			end
		else
			if not (NPC.HasModifier(myHero, "modifier_item_invisibility_edge_windwalk") or NPC.HasModifier(myHero, "modifier_item_silver_edge_windwalk")) then
				
				if NPC.IsLinkensProtected(enemy) then
					if FAIO.LinkensBreakerNew(myHero) ~= nil then
						Ability.CastTarget(NPC.GetItem(myHero, FAIO.LinkensBreakerNew(myHero), true), enemy)
						return
					end
				end
				if stormHammer and Ability.IsCastable(stormHammer, myMana) and not (NPC.IsLinkensProtected(enemy) or NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE)) and FAIO.heroCanCastSpells(myHero, enemy) == true then
					Ability.CastTarget(stormHammer, enemy)
					FAIO.lastTick = os.clock()
					return
				end
				if FAIO.SleepReady(0.3) and warCry and Ability.IsCastable(warCry, myMana) and FAIO.heroCanCastSpells(myHero, enemy) == true then
					Ability.CastNoTarget(warCry)
					return
				end
				if FAIO.SleepReady(0.3) and godsStrength and Ability.IsCastable(godsStrength, myMana) and FAIO.heroCanCastSpells(myHero, enemy) == true then
					Ability.CastNoTarget(godsStrength)
					FAIO.lastTick = os.clock()
					return
				end
				if not (Ability.IsCastable(stormHammer, myMana) and Ability.IsCastable(warCry, myMana) and Ability.IsCastable(godsStrength, myMana)) then
					if FAIO.SleepReady(0.4) and maskOfMadness and Ability.IsCastable(maskOfMadness, myMana) then
						Ability.CastNoTarget(maskOfMadness)
						return
					end
				end
			end
		end
	FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	end

end

function FAIO.VisageCombo(myHero, enemy)

	if not Menu.IsEnabled(FAIO.optionHeroVisage) then return end
	if not NPC.IsEntityInRange(myHero, enemy, 3000)	then return end

	local graveChill = NPC.GetAbilityByIndex(myHero, 0)
	local soulAssumption = NPC.GetAbilityByIndex(myHero, 1)
	local soulMaxStacks = Ability.GetLevelSpecialValueFor(soulAssumption, "stack_limit")
	local myMana = NPC.GetMana(myHero)

	local graveChillRange = 650
		if graveChill and Ability.GetCastRange(graveChill) > graveChillRange then
			graveChillRange = Ability.GetCastRange(graveChill)
		end

	local soulModifier = NPC.GetModifier(myHero, "modifier_visage_soul_assumption")
	local soulStackCounter 
		if soulModifier then
			soulStackCounter = Modifier.GetStackCount(soulModifier)
		end
	
	local familiars = NPC.GetAbility(myHero, "visage_summon_familiars")
	
	local familiarsLevel = Ability.GetLevel(familiars)

	if Menu.IsKeyDown(FAIO.optionHeroVisageInstStunKey) then
		if FAIO.VisageInstStunLockTarget == nil then
			if enemy and NPC.IsPositionInRange(enemy, Input.GetWorldCursorPos(), 500, 0) then
				FAIO.VisageInstStunLockTarget = enemy
			else
				FAIO.VisageInstStunLockTarget = nil
			end
		end
	else
		FAIO.VisageInstStunLockTarget = nil
	end

	local familiarEntityTable = {}
	for i = 1, NPCs.Count() do
	local npc = NPCs.Get(i)
		if familiars then
			if npc and npc ~= myHero and Entity.IsSameTeam(myHero, npc) then
				if (Entity.GetOwner(myHero) == Entity.GetOwner(npc) or Entity.OwnedBy(npc, myHero)) then
					if NPC.GetUnitName(npc) == "npc_dota_visage_familiar" .. familiarsLevel then
						if not (NPC.HasModifier(npc, "modifier_visage_summonfamiliars_timer") or NPC.HasModifier(npc, "modifier_rooted")) then
							if Wrap.EIsAlive(npc) then
								if npc ~= nil then
									table.insert(familiarEntityTable, npc)
								end
							end
						end
					end
				end
			end
		end
	end

	if Menu.IsEnabled(FAIO.optionHeroVisageKS) then
		FAIO.VisageSoulAssumptionKS(myHero, myMana, soulAssumption, soulStackCounter)
	end

	if not Menu.IsKeyDown(FAIO.optionHeroVisagePanicKey) then
		FAIO.VisagePanicTarget = nil
	end

	if next(familiarEntityTable) ~= nil then

		for _, familiarAttack in ipairs(familiarEntityTable) do
			if Menu.IsKeyDown(FAIO.optionComboKey) then
				if familiarAttack and not NPC.IsEntityInRange(familiarAttack, enemy, NPC.GetAttackRange(familiarAttack)) then
					FAIO.GenericAttackIssuer2("Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil, familiarAttack)
				end
			end
			if Menu.IsKeyDown(FAIO.optionHeroVisageInstStunKey) then
				if familiarAttack and not NPC.IsEntityInRange(familiarAttack, enemy, NPC.GetAttackRange(familiarAttack)) then
					FAIO.GenericAttackIssuer2("Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", FAIO.VisageInstStunLockTarget, nil, familiarAttack)
				end
			end
		end

		for _, familiarStun in ipairs(familiarEntityTable) do
			if Menu.IsKeyDown(FAIO.optionComboKey) then
				if familiarStun and (os.clock() - FAIO.ControlledUnitCastTime) >= (Ability.GetLevelSpecialValueForFloat(NPC.GetAbilityByIndex(familiarStun, 0), "stun_duration") * (1 - (Hero.GetStrengthTotal(enemy) * 0.0015)) - 0.1 - NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)) then
					FAIO.VisageFamiliarControl(myHero, enemy, familiarStun, soulAssumption, soulMaxStacks, soulStackCounter, NPC.GetAbilityByIndex(familiarStun, 0), myMana)
					break
				end
			end
			if Menu.IsKeyDown(FAIO.optionHeroVisageInstStunKey) then
				if familiarStun and (os.clock() - FAIO.ControlledUnitCastTime) >= (Ability.GetLevelSpecialValueForFloat(NPC.GetAbilityByIndex(familiarStun, 0), "stun_duration") * (1 - (Hero.GetStrengthTotal(enemy) * 0.0015)) - 0.1 - NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING)) then
					FAIO.VisageFamiliarInstantStun(myHero, FAIO.VisageInstStunLockTarget, familiarStun, NPC.GetAbilityByIndex(familiarStun, 0), myMana)
					break
				end
			end

		end

		for _, familiarSave in ipairs(familiarEntityTable) do
			if Menu.IsEnabled(FAIO.optionHeroVisageFamiliarSave) then
				if familiarSave and Entity.GetHealth(familiarSave) < 0.5 * Entity.GetMaxHealth(familiarSave) then
					FAIO.VisageFamiliarAutoSaver(myHero, familiarSave, NPC.GetAbilityByIndex(familiarSave, 0))
					break
					return
				end
			end
		end	

		for _, familiarCancel in ipairs(familiarEntityTable) do
			if Menu.IsEnabled(FAIO.optionHeroVisageFamiliarCancel) then
				if familiarCancel and (os.clock() - FAIO.ControlledUnitCastTime) >= (Ability.GetLevelSpecialValueForFloat(NPC.GetAbilityByIndex(familiarCancel, 0), "stun_duration")) then
					FAIO.VisageFamiliarCancelChannelling(myHero, familiarCancel, NPC.GetAbilityByIndex(familiarCancel, 0))
					break
					return
				end
			end
		end	
		
		for _, familiarPanic in pairs(familiarEntityTable) do
			if Menu.IsKeyDown(FAIO.optionHeroVisagePanicKey) then
				if familiarPanic then
					FAIO.VisageFamiliarPanicStun(myHero, familiarPanic, NPC.GetAbilityByIndex(familiarPanic, 0))
				end
			end
		end

	end
	

	FAIO.itemUsage(myHero, enemy)

	if Menu.IsKeyDown(FAIO.optionComboKey) and Entity.GetHealth(enemy) > 0 then
		if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and FAIO.heroCanCastSpells(myHero, enemy) == true then
			if NPC.IsEntityInRange(myHero, enemy, graveChillRange) then
				if graveChill and Ability.IsCastable(graveChill, myMana) then
					Ability.CastTarget(graveChill, enemy)
					FAIO.lastTick = os.clock()
					return
				end
				if FAIO.SleepReady(0.2) and soulAssumption and Ability.IsCastable(soulAssumption, myMana) then
					if soulMaxStacks <= soulStackCounter then
						Ability.CastTarget(soulAssumption, enemy)
						return
					end
				end
			end	
		end
	FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	end
end

function FAIO.VisageFamiliarControl(myHero, enemy, familiarEntity, soulAssumption, soulMaxStacks, soulStackCounter, stoneForm, myMana)

	if not familiarEntity then return end
	if not Wrap.EIsAlive(familiarEntity) then return end

	local familiarAttackCount = 0
		for i, v in pairs(FAIO.VisageFamiliarAttackCounter) do
			if v then
				if i == Entity.GetIndex(familiarEntity) then
					if GameRules.GetGameTime() > v[1] + 1 then
						FAIO.VisageFamiliarAttackCounter[i] = nil
						familiarAttackCount = 0
					else
						familiarAttackCount = v[2]
					end
				end
			end
		end

	local stunRange = 250
		if NPC.IsRunning(enemy) then
			stunRange = 75
		end

	if Menu.IsKeyDown(FAIO.optionComboKey) and Entity.GetHealth(enemy) > 0 and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
			if stoneForm and Ability.IsReady(stoneForm) then
				if familiarAttackCount >= Menu.GetValue(FAIO.optionHeroVisageDMGStacks) then
					if not NPC.HasModifier(enemy, "modifier_rooted") or not NPC.HasModifier(enemy, "modifier_sheepstick_debuff") then
						if NPC.IsEntityInRange(familiarEntity, enemy, stunRange) then
							FAIO.ControlledUnitCastTime = os.clock()
							Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_NO_TARGET, enemy, Vector(0,0,0), stoneForm, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, familiarEntity)
							return
						else
							if os.clock() - FAIO.lastCastTime2 > 0.1 then
								Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION, target, Entity.GetAbsOrigin(enemy) + Entity.GetRotation(enemy):GetForward():Normalized():Scaled(75), ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, familiarEntity)
								FAIO.lastCastTime2 = os.clock()
								return
							end
						end
					end
				end
			end
		if soulAssumption and Ability.IsCastable(soulAssumption, myMana) and NPC.IsEntityInRange(myHero, enemy, NPC.GetAttackRange(myHero)-50) then
			if soulMaxStacks <= soulStackCounter then
				Ability.CastTarget(soulAssumption, enemy)
			end
		end
	end
end

function FAIO.VisageFamiliarInstantStun(myHero, enemy, familiarEntity, stoneForm, myMana)

	if not myHero then return end
	if not enemy then return end

	if not familiarEntity then return end
	if not Wrap.EIsAlive(familiarEntity) then return end

	if not stoneForm then return end
		if not Ability.IsReady(stoneForm) then return end

	local stunRange = 250
		if NPC.IsRunning(enemy) then
			stunRange = 75
		end

	if Entity.GetHealth(enemy) > 0 and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
		if stoneForm and Ability.IsReady(stoneForm) then
			if not NPC.HasModifier(enemy, "modifier_rooted") or not NPC.HasModifier(enemy, "modifier_sheepstick_debuff") then
				if not NPC.IsEntityInRange(familiarEntity, enemy, stunRange) then
					if os.clock() - FAIO.lastCastTime2 > 0.1 then
						NPC.MoveTo(familiarEntity, Entity.GetAbsOrigin(enemy) + Entity.GetRotation(enemy):GetForward():Normalized():Scaled(75), false, false)
						FAIO.lastCastTime2 = os.clock()
						return
					end
				else
					FAIO.ControlledUnitCastTime = os.clock()
					Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_NO_TARGET, enemy, Vector(0,0,0), stoneForm, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, familiarEntity)
					return
				end
			end
		end
	end

end

function FAIO.VisageFamiliarPanicStun(myHero, familiarEntity, stoneForm)

	if not myHero then return end
	if not familiarEntity then return end

	if not stoneForm then return end

	for _, hero in ipairs(Wrap.HeroesInRadius(myHero, 1000, Enum.TeamType.TEAM_ENEMY)) do
		local target = FAIO.targetChecker(hero)
		if target and Wrap.EIsAlive(target) and not NPC.HasState(target, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
			if FAIO.VisagePanicTarget == nil or (FAIO.VisagePanicTarget ~= nil and NPC.GetUnitName(target) ~= FAIO.VisagePanicTarget) and not NPC.IsStunned(target) then

				if stoneForm and Ability.IsReady(stoneForm) then
					if not NPC.HasModifier(target, "modifier_rooted") or not NPC.HasModifier(target, "modifier_sheepstick_debuff") then
					local stunRange = 250
						if NPC.IsRunning(target) then
							stunRange = 75
						end
						if not NPC.IsEntityInRange(familiarEntity, target, stunRange) then
							FAIO.GenericAttackIssuer2("Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", target, Entity.GetAbsOrigin(target) + Entity.GetRotation(target):GetForward():Normalized():Scaled(75), familiarEntity)
							return
						else
							Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_NO_TARGET, target, Vector(0,0,0), stoneForm, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, familiarEntity)
							Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_TARGET, myHero, Vector(0,0,0), ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, familiarEntity)
							FAIO.VisagePanicTarget = NPC.GetUnitName(target)
							return
						end
					end
				end
			end
		end
	end

	if not Ability.IsReady(stoneForm) and not NPC.HasModifier(familiarEntity, "modifier_rooted") then
		Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_TARGET, myHero, Vector(0,0,0), ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, familiarEntity)
	end
	
end

function FAIO.VisageSoulAssumptionKS(myHero, myMana, soulAssumption, soulStackCounter)

	if not myHero then return end

	if not soulAssumption then return end
		if not Ability.IsCastable(soulAssumption, myMana) then return end

	if not soulStackCounter then return end
	if soulStackCounter <= 1 then return end

	local soulAssumptionDMG = (20 + soulStackCounter * 65) * (1 + (Hero.GetIntellectTotal(myHero) / 14 / 100))

	if FAIO.isHeroChannelling(myHero) == true then return end 
	if FAIO.IsHeroInvisible(myHero) == true then return end
	if FAIO.heroCanCastSpells(myHero, enemy) == false then return end

	for _, hero in ipairs(Wrap.HeroesInRadius(myHero, Ability.GetCastRange(soulAssumption) - 15, Enum.TeamType.TEAM_ENEMY)) do
		local target = FAIO.targetChecker(hero)
		if target and Wrap.EIsAlive(target) and not NPC.IsLinkensProtected(target) and not NPC.HasState(target, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and not NPC.HasModifier(target, "modifier_templar_assassin_refraction_absorb") then
			if Entity.GetHealth(target) <= soulAssumptionDMG * (1 - NPC.GetMagicalArmorValue(target)) then
				Ability.CastTarget(soulAssumption, target)
				break
				return
			end
		end
	end

end

function FAIO.VisageFamiliarAutoSaver(myHero, familiarEntity, stoneForm)

	if not myHero then return end
	if not familiarEntity then return end
	if not Wrap.EIsAlive(familiarEntity) then return end

	if not stoneForm then return end
		if not Ability.IsReady(stoneForm) then return end

	 if Entity.GetHealth(familiarEntity) < Entity.GetMaxHealth(familiarEntity) * 0.33 then
	 	if stoneForm and Ability.IsReady(stoneForm) and not Ability.IsInAbilityPhase(stoneForm) and not NPC.IsStunned(familiarEntity) and not NPC.IsSilenced(familiarEntity) then
			Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_NO_TARGET, target, Vector(0,0,0), stoneForm, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, familiarEntity)
			Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_TARGET, myHero, Vector(0,0,0), ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, familiarEntity, true)
			return
		end
	end	

end

function FAIO.VisageFamiliarCancelChannelling(myHero, familiarEntity, stoneForm)

	if not myHero then return end
	if not familiarEntity then return end
	if not Wrap.EIsAlive(familiarEntity) then return end

	if not stoneForm then return end
		if not Ability.IsReady(stoneForm) then return end

	local channellingTable = {
		npc_dota_hero_bane = { "bane_fiends_grip", { 5, 5, 5 } },
		npc_dota_hero_crystal_maiden = { "crystal_maiden_freezing_field", { 10, 10, 10} },
		npc_dota_hero_enigma = { "enigma_black_hole", { 4, 4, 4 } },
		npc_dota_hero_oracle = { "oracle_fortunes_end", { 2.5, 2.5, 2.5, 2.5 } },
		npc_dota_hero_pudge = { "pudge_dismember", { 3, 3, 3 } },
		npc_dota_hero_pugna = { "pugna_life_drain", { 10, 10, 10 } },
		npc_dota_hero_sand_king = { "sandking_epicenter", { 2, 2, 2} },
		npc_dota_hero_shadow_shaman = { "shadow_shaman_shackles", { 2.75, 3.5, 4.25, 5 } },
		npc_dota_hero_tinker = { "tinker_rearm", { 3, 1.5, 0.75 } },
		npc_dota_hero_warlock = { "warlock_upheaval", { 16, 16, 16, 16 } },
		npc_dota_hero_witch_doctor = { "witch_doctor_death_ward", { 8, 8, 8} }
				}
	
	local stunRange = 300

	local cancelEnemies = Wrap.HeroesInRadius(myHero, 1000, Enum.TeamType.TEAM_ENEMY)
	for _, cancelEnemy in ipairs(cancelEnemies) do
		if cancelEnemy and not Entity.IsDormant(cancelEnemy) and not NPC.IsIllusion(cancelEnemy) and Wrap.EIsAlive(cancelEnemy) then
			if not NPC.HasState(cancelEnemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
				for i, v in pairs(channellingTable) do
					if (NPC.GetUnitName(cancelEnemy) == i and Ability.IsChannelling(NPC.GetAbility(cancelEnemy, v[1]))) then
						local channellingStartTime = Ability.GetChannelStartTime(NPC.GetAbility(cancelEnemy, v[1]))
						local channellingEndTime = channellingStartTime + v[2][Ability.GetLevel(NPC.GetAbility(cancelEnemy, v[1]))]
						local disToEnemy = (Entity.GetAbsOrigin(familiarEntity) - Entity.GetAbsOrigin(cancelEnemy)):Length2D() - 250
						local timeToStun = (disToEnemy / 430) + 0.6
						if stoneForm and Ability.IsReady(stoneForm) then
							if GameRules.GetGameTime() < channellingEndTime - timeToStun then
								if not NPC.IsEntityInRange(familiarEntity, cancelEnemy, stunRange) then
									if os.clock() - FAIO.lastCastTime2 > 0.1 then
										NPC.MoveTo(familiarEntity, Entity.GetAbsOrigin(cancelEnemy), false, false)
										FAIO.lastCastTime2 = os.clock()
										return
									end
								else
									FAIO.ControlledUnitCastTime = os.clock()
									Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_NO_TARGET, target, Vector(0,0,0), stoneForm, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, familiarEntity)
									break
									return
								end
							end
						end
					elseif NPC.HasModifier(cancelEnemy, "modifier_teleporting") then
						local teleportCreationTime = Modifier.GetCreationTime(NPC.GetModifier(cancelEnemy, "modifier_teleporting"))
						local teleportEndTime = teleportCreationTime + 3
						local disToEnemy = (Entity.GetAbsOrigin(familiarEntity) - Entity.GetAbsOrigin(cancelEnemy)):Length2D() - 250
						local timeToStun = (disToEnemy / 430) + 0.6
						if stoneForm and Ability.IsReady(stoneForm) then
							if GameRules.GetGameTime() < teleportEndTime - timeToStun then
								if not NPC.IsEntityInRange(familiarEntity, cancelEnemy, stunRange) then
									if os.clock() - FAIO.lastCastTime2 > 0.1 then
										NPC.MoveTo(familiarEntity, Entity.GetAbsOrigin(cancelEnemy), false, false)
										FAIO.lastCastTime2 = os.clock()
										return
									end
								else
									FAIO.ControlledUnitCastTime = os.clock()
									Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_NO_TARGET, target, Vector(0,0,0), stoneForm, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, familiarEntity)
									break
									return
								end
							end
						end
					end
				end
			end
		end
	end

end

function FAIO.ArcTempestTargetIndicator(myHero)

	if not myHero then return end

	if FAIO.ArcTempestLockedTarget ~= nil then
		local target = FAIO.ArcTempestLockedTarget
		
		if FAIO.ArcTempestLockedTargetParticle == 0 then
			local tempestParticle = Particle.Create("particles/units/heroes/hero_sniper/sniper_crosshair.vpcf", Enum.ParticleAttachment.PATTACH_OVERHEAD_FOLLOW, target)
			FAIO.ArcTempestLockedTargetParticle = tempestParticle
			FAIO.ArcTempestLockedTargetParticleHero = target
		else
			if FAIO.ArcTempestLockedTargetParticleHero ~= target then
				Particle.Destroy(FAIO.ArcTempestLockedTargetParticle)
				FAIO.ArcTempestLockedTargetParticle = 0
			end
		end
	else
		if FAIO.ArcTempestLockedTargetParticle > 0 then
			Particle.Destroy(FAIO.ArcTempestLockedTargetParticle)
			FAIO.ArcTempestLockedTargetParticle = 0
		end			
	end

end

function FAIO.ArcWardenCombo(myHero, enemy)

	if not Menu.IsEnabled(FAIO.optionHeroArcWarden) then return end

	local flux = NPC.GetAbilityByIndex(myHero, 0)
	local magneticField = NPC.GetAbilityByIndex(myHero, 1)
	local sparkWraith = NPC.GetAbilityByIndex(myHero, 2)
	local tempestDouble = NPC.GetAbility(myHero, "arc_warden_tempest_double")

	local arcWardenAttackRange = NPC.GetAttackRange(myHero)
	local blink = NPC.GetItem(myHero, "item_blink", true)

	local myMana = NPC.GetMana(myHero)
	
	for i = 1, NPCs.Count() do
		npc = NPCs.Get(i)
		if tempestDouble then
			if npc and npc ~= myHero then

				if NPC.GetUnitName(npc) == "npc_dota_hero_arc_warden" then
					if NPC.HasModifier(npc, "modifier_arc_warden_tempest_double") then
						if npc ~= nil then
							if Wrap.EIsAlive(npc) then
								FAIO.ArcWardenEntity = npc
								FAIO.TempestDoubleHandler(myHero, enemy, npc, tempestDouble, myMana, arcWardenAttackRange)
							end
						end
					end
				end
			end
		end
	end

	local necronomicon = NPC.GetItem(myHero, "item_necronomicon", true)
	if not necronomicon then
		for i = 2, 3 do
			necronomicon = NPC.GetItem(myHero, "item_necronomicon_" .. i, true)
			if necronomicon then 
				break 
			end
		end
	end

	FAIO.itemUsage(myHero, enemy)

	if tempestDouble then
		if Ability.IsCastable(tempestDouble, myMana) then				
			if Menu.IsKeyDownOnce(FAIO.optionArcWardenTempestKey) and FAIO.heroCanCastSpells(myHero, enemy) == true then
				local tempestEnemy = FAIO.targetChecker(Input.GetNearestHeroToCursor(Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY))
				if tempestEnemy and NPC.IsPositionInRange(tempestEnemy, Input.GetWorldCursorPos(), 700, 0) then
					FAIO.ArcTempestLockedTarget = tempestEnemy
					FAIO.arcWardenPusher = false
				else
					FAIO.ArcTempestLockedTarget = nil
					FAIO.arcWardenStatus = 0
				end
				Ability.CastNoTarget(tempestDouble)
				return
			end
		end
		--Log.Write(tostring(Wrap.EIsAlive(FAIO.ArcWardenEntity)))
		if FAIO.ArcWardenEntity ~= nil and Wrap.EIsAlive(FAIO.ArcWardenEntity) then
			local tempestEnemy = FAIO.targetChecker(Input.GetNearestHeroToCursor(Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY))
			if Menu.IsKeyDownOnce(FAIO.optionArcWardenTempestKey) then
				Log.Write('2')
				if FAIO.ArcTempestLockedTarget == nil then
					if tempestEnemy and NPC.IsPositionInRange(tempestEnemy, Input.GetWorldCursorPos(), 700, 0) then
						FAIO.ArcTempestLockedTarget = tempestEnemy
						FAIO.arcWardenPusher = false
					else
						FAIO.ArcTempestLockedTarget = nil
						FAIO.arcWardenStatus = 0
					end
				else
					if tempestEnemy ~= FAIO.ArcTempestLockedTarget and NPC.IsPositionInRange(tempestEnemy, Input.GetWorldCursorPos(), 700, 0) then
						FAIO.ArcTempestLockedTarget = tempestEnemy
						FAIO.arcWardenPusher = false
					else
						FAIO.ArcTempestLockedTarget = nil
						FAIO.arcWardenStatus = 0
					end
				end	
			end
	
			if FAIO.ArcTempestLockedTarget ~= nil then
				if not Wrap.EIsAlive(FAIO.ArcTempestLockedTarget) then
					FAIO.ArcTempestLockedTarget = nil
					FAIO.arcWardenStatus = 0
			--	elseif Entity.IsDormant(FAIO.ArcTempestLockedTarget) then
			--		FAIO.ArcTempestLockedTarget = nil
			--		FAIO.arcWardenStatus = 0
			--	elseif not NPC.IsEntityInRange(myHero, FAIO.ArcTempestLockedTarget, 3000) then
			--		FAIO.ArcTempestLockedTarget = nil
			--		FAIO.arcWardenStatus = 0
				end
			end
		else
			if not Ability.IsReady(tempestDouble) then
				FAIO.ArcTempestLockedTarget = nil
				FAIO.arcWardenStatus = 0
			end
		end

		if Menu.IsEnabled(FAIO.optionArcWardenTempestParticle) then
			FAIO.ArcTempestTargetIndicator(myHero)
		end
	end

	if Menu.IsKeyDownOnce(FAIO.optionArcWardenPushKey) then
		if FAIO.ArcTempestLockedTarget == nil then
			FAIO.arcWardenPusher = not FAIO.arcWardenPusher
		else
			FAIO.ArcTempestLockedTarget = nil
			FAIO.arcWardenPusher = not FAIO.arcWardenPusher
		end
	end

	if not tempestDouble then
		FAIO.arcWardenPusher = false
		FAIO.arcWardenStatus = 0
	else
		if not Ability.IsReady(tempestDouble) then
			if not FAIO.ArcWardenEntity or (FAIO.ArcWardenEntity and not Wrap.EIsAlive(FAIO.ArcWardenEntity)) then
				FAIO.arcWardenPusher = false
				FAIO.arcWardenStatus = 0
			end
		end
	end

	if not FAIO.arcWardenPusher and FAIO.ArcTempestLockedTarget == nil then
		if FAIO.arcWardenStatus > 1 then
			FAIO.arcWardenStatus = 0
		end
	end

	if FAIO.arcWardenPusher then
		if FAIO.heroCanCastSpells(myHero, enemy) == true then
			if tempestDouble and Ability.IsCastable(tempestDouble, myMana) then
				Ability.CastNoTarget(tempestDouble)
				return
			end
		end
	end

	if enemy and NPC.IsEntityInRange(myHero, enemy, 1600) then
		if Menu.IsKeyDown(FAIO.optionComboKey) and Wrap.EIsAlive(enemy) then
			if FAIO.heroCanCastSpells(myHero, enemy) == true then
				if not (NPC.HasModifier(myHero, "modifier_item_invisibility_edge_windwalk") or NPC.HasModifier(myHero, "modifier_item_silver_edge_windwalk")) then
					if not NPC.IsEntityInRange(myHero, enemy, arcWardenAttackRange + Menu.GetValue(FAIO.optionArcWardenBlinkTrigger)) then
						if Menu.IsEnabled(FAIO.optionArcWardenMainBlink) and blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1150 + Menu.GetValue(FAIO.optionArcWardenBlinkRange)) then
							Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(Menu.GetValue(FAIO.optionArcWardenBlinkRange))))
							return
						end
					end

					if os.clock() > FAIO.lastTick then 
						if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
							if NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(flux)) then
								if Menu.IsEnabled(FAIO.optionHeroArcWardenFlux) and flux and Ability.IsCastable(flux, myMana) and #Wrap.HeroesInRadius(enemy, 225, Enum.TeamType.TEAM_FRIEND) < 1 then
									Ability.CastTarget(flux, enemy)
									FAIO.lastTick = os.clock() + 0.2
									return
								end
							end

							if Menu.IsEnabled(FAIO.optionHeroArcWardenSpark) and sparkWraith and Ability.IsCastable(sparkWraith, myMana) then
								local sparkPrediction = 2.3 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
								local sparkPos = FAIO.castPrediction(myHero, enemy, sparkPrediction)
								if NPC.IsPositionInRange(myHero, sparkPos, 1999) then
									Ability.CastPosition(sparkWraith, sparkPos)
									FAIO.lastTick = os.clock() + 0.2
									return
								end
							end
						end
						
						if NPC.IsEntityInRange(myHero, enemy, arcWardenAttackRange) then
							if Menu.IsEnabled(FAIO.optionHeroArcWardenMagnetic) and magneticField and Ability.IsCastable(magneticField, myMana) and not NPC.HasModifier(myHero, "modifier_arc_warden_magnetic_field_attack_speed") then
								if os.clock() > FAIO.arcWardenMagneticCastTime then
									local pos = Entity.GetAbsOrigin(myHero) + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(150)
									Ability.CastPosition(magneticField, pos)
									FAIO.lastTick = os.clock() + 0.2
									FAIO.arcWardenMagneticCastTime = os.clock() + 0.55
									return
								end
							end

							if necronomicon and Ability.IsCastable(necronomicon, myMana) then
								Ability.CastNoTarget(necronomicon)
								FAIO.lastTick = os.clock() + 0.05
								return
							end
						end

						if NPC.IsEntityInRange(myHero, enemy, arcWardenAttackRange + Menu.GetValue(FAIO.optionArcWardenBlinkTrigger) - 50) then
							if Menu.IsEnabled(FAIO.optionArcWardenComboUlt) and tempestDouble and Ability.IsCastable(tempestDouble, myMana) then
								Ability.CastNoTarget(tempestDouble)
								FAIO.lastTick = os.clock() + 0.2
								return
							end
						end
					end
				end
			end

			FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
			for _, necro in ipairs(FAIO.GetNecronomiconEntityTable(myHero, myHero)) do
				FAIO.NecronomiconController(necro, enemy, nil)
			end
			if #FAIO.GetIllusionEntityTable(myHero, myHero) > 0 then
				FAIO.MantaIlluController(enemy, nil, myHero, myHero)
			end

			return
		end
	end

end

function FAIO.TempestInAttackAnimation(myHero)

	if not myHero then return false end
	if FAIO.ArcWardenEntity == nil then return false end
	if not Wrap.EIsAlive(FAIO.ArcWardenEntity) then return false end

	if FAIO.ArcWardenEntityAnimationStart < 1 then return false end
	if FAIO.ArcWardenEntityAnimationEnd < 1 then return false end

	if GameRules.GetGameTime() > FAIO.ArcWardenEntityAnimationEnd then return false end

	if GameRules.GetGameTime() >= FAIO.ArcWardenEntityAnimationStart then
		if GameRules.GetGameTime() <= FAIO.ArcWardenEntityAnimationEnd then
			return true
		end
	end

	return false

end

function FAIO.TempestTrackLockedTargetLocation(myHero, target)

	if not myHero then return end
	if not target then
		FAIO.ArcTempestLockedTargetPos = Vector()
		FAIO.ArcTempestLockedTargetPosTimer = 0
		return 
	end

	if not Entity.IsDormant(target) then
		if os.clock() > FAIO.ArcTempestLockedTargetPosTimer then
			FAIO.ArcTempestLockedTargetPos = Entity.GetAbsOrigin(target)
			FAIO.ArcTempestLockedTargetPosTimer = os.clock() + 0.5
			return
		end
	end

	return

end

function FAIO.TempestOrbWalker(myHero, tempestDoubleEntity, enemy)

	if not tempestDoubleEntity then return end
	if not enemy then return end

	if NPC.IsChannellingAbility(tempestDoubleEntity) then return end

	local attackRange = NPC.GetAttackRange(tempestDoubleEntity)

	local increasedAS = NPC.GetIncreasedAttackSpeed(tempestDoubleEntity)
	local attackTime = NPC.GetAttackTime(tempestDoubleEntity)
	local movementSpeed = NPC.GetMoveSpeed(tempestDoubleEntity)

	local attackPoint = 0.3 / (1 + (increasedAS/100))
	local attackBackSwing = 0.7 / (1 + (increasedAS/100))

	local idleTime = math.max(attackTime - attackPoint - attackBackSwing, 0)

	if FAIO.ArcWardenEntityProjectileCreate > 0 then
		if GameRules.GetGameTime() > FAIO.ArcWardenEntityAnimationStart and GameRules.GetGameTime() < FAIO.ArcWardenEntityProjectileCreate + attackBackSwing + idleTime then
			FAIO.TempestInAttackBackswing = true
		else
			FAIO.TempestInAttackBackswing = false
		end
	end
	

	if GameRules.GetGameTime() > FAIO.ArcWardenEntityAnimationStart and GameRules.GetGameTime() < FAIO.AttackProjectileCreate then
		FAIO.TempestInAttackBackswing = false
	end

	local breakPoint = attackRange * 0.7

	local moveDistance = NPC.GetMoveSpeed(tempestDoubleEntity) * (attackBackSwing + idleTime - NPC.GetTimeToFace(tempestDoubleEntity, enemy)) * 0.9
		if (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(tempestDoubleEntity)):Length2D() > breakPoint and (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(tempestDoubleEntity)):Length2D() <= breakPoint + moveDistance then
			moveDistance = (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(tempestDoubleEntity)):Length2D() - breakPoint
		end
	
	if not FAIO.TempestInAttackBackswing then
		if os.clock() - FAIO.TempestOrbwalkerDelay > 0.05 + attackPoint + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) and GameRules.GetGameTime() - FAIO.ArcWardenEntityAnimationStart > attackPoint + 0.1 then
			Player.AttackTarget(Players.GetLocal(), tempestDoubleEntity, enemy, false)
			FAIO.TempestOrbwalkerDelay = os.clock()
			return
		end
	else
		if (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(tempestDoubleEntity)):Length2D() > breakPoint then
			if os.clock() - FAIO.TempestOrbwalkerDelay > attackBackSwing + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) then
				if moveDistance > 50 then
					local targetVector = Entity.GetAbsOrigin(tempestDoubleEntity) + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(tempestDoubleEntity)):Normalized():Scaled(moveDistance)
					Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION, target, targetVector, ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, tempestDoubleEntity, queue, showEffects)
					FAIO.TempestOrbwalkerDelay = os.clock()
					return
				end
			end
		end
	end

end

function FAIO.TempestDoubleHandler(myHero, enemy, tempestDoubleEntity, tempestDouble, myMana, arcWardenAttackRange)
	if not tempestDoubleEntity then return end
	if not Wrap.EIsAlive(tempestDoubleEntity) then return end
	if tempestDoubleEntity == myHero then return end
	if os.clock() - FAIO.ControlledUnitPauseTime < 3.1 then return end
	
	if FAIO.heroCanCastSpells(tempestDoubleEntity) == false then return end

	local travelBoots1 = NPC.GetItem(tempestDoubleEntity, "item_travel_boots", true)
	local travelBoots2 = NPC.GetItem(tempestDoubleEntity, "item_travel_boots_2", true)
	local wardenMana = NPC.GetMana(tempestDoubleEntity)

	local TPing = nil
		if travelBoots1 and Ability.IsCastable(travelBoots1, wardenMana) then
			TPing = travelBoots1
		elseif travelBoots2 and Ability.IsCastable(travelBoots2, wardenMana) then
			TPing = travelBoots2
		end
		local tempestMod = NPC.GetModifier(tempestDoubleEntity, "modifier_kill")
		if tempestMod then
			local tempestCreaTime = Modifier.GetCreationTime(tempestMod)
			local tempestDieTime = Modifier.GetDieTime(tempestMod)
			if GameRules.GetGameTime() > tempestCreaTime + 0.35 * (tempestDieTime - tempestCreaTime) then
				TPing = nil
			end
		end

	if Menu.IsKeyDown(FAIO.optionComboKey) then
		if enemy and Entity.GetHealth(enemy) > 0 then
			if FAIO.ArcTempestLockedTarget == nil then
				FAIO.ArcWardenFight(myHero, enemy, tempestDoubleEntity, arcWardenAttackRange)
				FAIO.arcWardenStatus = 1
			end
		end
	else
		if FAIO.arcWardenStatus == 1 and FAIO.ArcTempestLockedTarget == nil then
			FAIO.arcWardenStatus = 0
		end
	end

	if FAIO.ArcTempestLockedTarget ~= nil then
		FAIO.TempestTrackLockedTargetLocation(myHero, FAIO.ArcTempestLockedTarget)
		if not Entity.IsDormant(FAIO.ArcTempestLockedTarget) then
			FAIO.ArcWardenFight(myHero, FAIO.ArcTempestLockedTarget, tempestDoubleEntity, arcWardenAttackRange)
			FAIO.arcWardenStatus = 1
		else
			FAIO.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, FAIO.ArcTempestLockedTargetPos, tempestDoubleEntity)
			FAIO.arcWardenStatus = 1
			if NPC.IsPositionInRange(tempestDoubleEntity, FAIO.ArcTempestLockedTargetPos, 100, 0) then
				FAIO.ArcWardenPush(myHero, tempestDoubleEntity, arcWardenAttackRange)
				FAIO.arcWardenStatus = 5
				FAIO.ArcTempestLockedTargetPos = Entity.GetAbsOrigin(tempestDoubleEntity)
			end
		end	
	end

	if FAIO.arcWardenPusher then

		if TPing then
			if FAIO.ArcWardenPort(myHero) ~= nil and not NPC.IsPositionInRange(tempestDoubleEntity, FAIO.ArcWardenPort(myHero), Menu.GetValue(FAIO.optionArcWardenPushTPRange)) then
				Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_POSITION, target, FAIO.ArcWardenPort(myHero), TPing, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, tempestDoubleEntity)
				FAIO.arcWardenStatus = 3
				FAIO.ControlledUnitPauseTime = os.clock()
				return
			else
				FAIO.ArcWardenPush(myHero, tempestDoubleEntity, arcWardenAttackRange)
				FAIO.arcWardenStatus = 2
			end
		else
			if not NPC.HasModifier(tempestDoubleEntity ,"modifier_teleporting") then
				if NPC.HasItem(myHero, "item_travel_boots", true) or NPC.HasItem(myHero, "item_travel_boots_2", true) then
					if not ((travelBoots1 and Ability.IsReady(travelBoots1)) or (travelBoots2 and Ability.IsReady(travelBoots2))) then
						FAIO.ArcWardenPush(myHero, tempestDoubleEntity, arcWardenAttackRange)
						FAIO.arcWardenStatus = 4
					else
						FAIO.ArcWardenPush(myHero, tempestDoubleEntity, arcWardenAttackRange)
						FAIO.arcWardenStatus = 2
					end
				else
					FAIO.ArcWardenPush(myHero, tempestDoubleEntity, arcWardenAttackRange)
					FAIO.arcWardenStatus = 2
				end
			end
		end
	end
			
	if not NPC.HasModifier(tempestDoubleEntity ,"modifier_teleporting") then
		FAIO.utilityItemMidas(tempestDoubleEntity, NPC.GetItem(tempestDoubleEntity, "item_hand_of_midas", true))
	end

end	

function FAIO.ArcWardenFight(myHero, enemy, tempestDoubleEntity, arcWardenAttackRange)

	if not tempestDoubleEntity then return end
	if not enemy then return end
	if not Wrap.EIsAlive(tempestDoubleEntity) then return end
	if tempestDoubleEntity == myHero then return end

	if FAIO.heroCanCastSpells(tempestDoubleEntity) == false then return end

	local flux = NPC.GetAbilityByIndex(tempestDoubleEntity, 0)
	local magneticField = NPC.GetAbilityByIndex(tempestDoubleEntity, 1)
	local sparkWraith = NPC.GetAbilityByIndex(tempestDoubleEntity, 2)

	local blink = NPC.GetItem(tempestDoubleEntity, "item_blink", true)
	local shadowBlade = NPC.GetItem(tempestDoubleEntity, "item_invis_sword", true)
	local silverEdge = NPC.GetItem(tempestDoubleEntity, "item_silver_edge", true)
	local bkb = NPC.GetItem(tempestDoubleEntity, "item_black_king_bar", true)

	local necronomicon = NPC.GetItem(tempestDoubleEntity, "item_necronomicon", true)
	if not necronomicon then
		for i = 2, 3 do
			necronomicon = NPC.GetItem(tempestDoubleEntity, "item_necronomicon_" .. i, true)
			if necronomicon then 
				break 
			end
		end
	end	 

	local wardenMana = NPC.GetMana(tempestDoubleEntity)

	if shadowBlade and Ability.IsCastable(shadowBlade, wardenMana) then
		Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_NO_TARGET, target, Vector(0,0,0), shadowBlade, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, tempestDoubleEntity)
		FAIO.noItemCastFor(0.5)
		FAIO.ControlledUnitCastTime = os.clock() + 0.25
		return
	end

	if silverEdge and Ability.IsCastable(silverEdge, wardenMana) then
		Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_NO_TARGET, target, Vector(0,0,0), silverEdge, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, tempestDoubleEntity)
		FAIO.noItemCastFor(0.5)
		FAIO.ControlledUnitCastTime = os.clock() + 0.25
		return
	end

	FAIO.itemUsageSmartOrder(tempestDoubleEntity, enemy, true)
	FAIO.TempestOrbWalker(myHero, tempestDoubleEntity, enemy)

	if not NPC.IsEntityInRange(tempestDoubleEntity, enemy, arcWardenAttackRange + 250) then
		if blink and Ability.IsReady(blink) then
			Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_POSITION, target, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(tempestDoubleEntity) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(250)), blink, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, tempestDoubleEntity)
			FAIO.Debugger(GameRules.GetGameTime(), tempestDoubleEntity, "blink", "DOTA_UNIT_ORDER_CAST_POSITION")
		end
	end

	if NPC.IsEntityInRange(tempestDoubleEntity, enemy, arcWardenAttackRange) then
		if (os.clock() - FAIO.ControlledUnitCastTime) > FAIO.GetAvgLatency() and necronomicon and Ability.IsCastable(necronomicon, wardenMana) then
			Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_NO_TARGET, target, Vector(0,0,0), necronomicon, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, tempestDoubleEntity)
			FAIO.ControlledUnitCastTime = os.clock()
			FAIO.Debugger(GameRules.GetGameTime(), tempestDoubleEntity, "necrobook", "DOTA_UNIT_ORDER_CAST_NO_TARGET")
		end

		if (os.clock() - FAIO.ControlledUnitCastTime) > FAIO.GetAvgLatency() and bkb and Ability.IsReady(bkb) then
			Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_NO_TARGET, target, Vector(0,0,0), bkb, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, tempestDoubleEntity)
			FAIO.ControlledUnitCastTime = os.clock()
			FAIO.Debugger(GameRules.GetGameTime(), tempestDoubleEntity, "bkb", "DOTA_UNIT_ORDER_CAST_NO_TARGET")
		end
	end

	if not (NPC.HasModifier(tempestDoubleEntity, "modifier_item_invisibility_edge_windwalk") or NPC.HasModifier(tempestDoubleEntity, "modifier_item_silver_edge_windwalk")) then
		if NPC.IsEntityInRange(tempestDoubleEntity, enemy, Ability.GetCastRange(flux)) then
			if NPC.IsLinkensProtected(enemy) and (os.clock() - FAIO.ControlledUnitCastTime) > FAIO.CastAnimationDelay(flux) and flux and Ability.IsCastable(flux, wardenMana) and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
				Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_TARGET, enemy, Vector(0,0,0), flux, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, tempestDoubleEntity)
				FAIO.ControlledUnitCastTime = os.clock()
				return
			end
		
			if Menu.IsEnabled(FAIO.optionHeroArcWardenFlux) and (os.clock() - FAIO.ControlledUnitCastTime) > FAIO.CastAnimationDelay(flux) and flux and Ability.IsCastable(flux, wardenMana) and #Wrap.HeroesInRadius(enemy, 225, Enum.TeamType.TEAM_FRIEND) < 1 and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
				Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_TARGET, enemy, Vector(0,0,0), flux, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, tempestDoubleEntity)
				FAIO.ControlledUnitCastTime = os.clock()
				return
			end
		end

		if NPC.IsEntityInRange(tempestDoubleEntity, enemy, arcWardenAttackRange) then
			if (os.clock() - FAIO.ControlledUnitCastTime) > FAIO.CastAnimationDelay(magneticField) and magneticField and Ability.IsCastable(magneticField, wardenMana) and not NPC.HasModifier(tempestDoubleEntity, "modifier_arc_warden_magnetic_field_attack_speed") and not Ability.IsInAbilityPhase(NPC.GetAbilityByIndex(myHero, 1)) and NPC.IsEntityInRange(tempestDoubleEntity, enemy, NPC.GetAttackRange(tempestDoubleEntity)) then
				if os.clock() > FAIO.arcWardenMagneticCastTime then
					Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_POSITION, target, Entity.GetAbsOrigin(tempestDoubleEntity) + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(tempestDoubleEntity)):Normalized():Scaled(50), magneticField, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, tempestDoubleEntity)
					FAIO.ControlledUnitCastTime = os.clock()
					FAIO.arcWardenMagneticCastTime = os.clock() + 0.55
					return
				end
			end
		end

		if NPC.IsEntityInRange(tempestDoubleEntity, enemy, 2000) then
			if Menu.IsEnabled(FAIO.optionHeroArcWardenSpark) and sparkWraith and (os.clock() - FAIO.ControlledUnitCastTime) > FAIO.CastAnimationDelay(sparkWraith) and Ability.IsCastable(sparkWraith, wardenMana) and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
				local sparkPrediction = 2.3 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
				local sparkPos = FAIO.castPrediction(tempestDoubleEntity, enemy, sparkPrediction)
				if NPC.IsPositionInRange(tempestDoubleEntity, sparkPos, 1999) then
					Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_POSITION, target, sparkPos, sparkWraith, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, tempestDoubleEntity)
					FAIO.ControlledUnitCastTime = os.clock()
					return
				end
			end
		end
	end
	
	for _, necro in ipairs(FAIO.GetNecronomiconEntityTable(myHero, tempestDoubleEntity)) do
		FAIO.NecronomiconController(necro, enemy, nil)
	end

	if #FAIO.GetIllusionEntityTable(myHero, tempestDoubleEntity) > 0 then
		FAIO.MantaIlluController(enemy, nil, myHero, tempestDoubleEntity)
	end

end
	
function FAIO.ArcWardenPort(myHero)

	local enemyFountainPos = FAIO.GetEnemyFountainPos(myHero)
	local myFountainPos = FAIO.GetMyFountainPos(myHero)

	if FAIO.arcWardenPushMode then
		local targetCreep
		local maxDistance = 99999
		if NPC.HasItem(myHero, "item_travel_boots", true) or NPC.HasItem(myHero, "item_travel_boots_2", true) then
			for i = 1, NPCs.Count() do 
			local npc = NPCs.Get(i)
    				if npc and Entity.IsSameTeam(myHero, npc) and Wrap.EIsAlive(npc) and NPC.IsLaneCreep(npc) and NPC.IsRanged(npc) and not Entity.IsDormant(npc) and not NPC.IsWaitingToSpawn(npc) and NPC.GetUnitName(npc) ~= "npc_dota_neutral_caster" then
					if npc ~= nil then
						local creepPosition = Entity.GetAbsOrigin(npc)
						local distanceToMouse = (creepPosition - Input.GetWorldCursorPos()):Length2D()
						if distanceToMouse < maxDistance then
							targetCreep = npc
							maxDistance = distanceToMouse
						end
					end
				end
			end
		end

		if targetCreep == nil then
			maxDistance = 99999
		end

		if targetCreep then
			return Entity.GetAbsOrigin(targetCreep)
		end
	else
		local targetCreep
		local pushDistance = 99999
		if NPC.HasItem(myHero, "item_travel_boots", true) or NPC.HasItem(myHero, "item_travel_boots_2", true) then
			for i = 1, NPCs.Count() do 
			local npc = NPCs.Get(i)
    				if npc and Entity.IsSameTeam(myHero, npc) and NPC.IsLaneCreep(npc) and NPC.IsRanged(npc) and not Entity.IsDormant(npc) and not NPC.IsWaitingToSpawn(npc) and NPC.GetUnitName(npc) ~= "npc_dota_neutral_caster" then
					if #Wrap.UnitsInRadius(npc, 1200, Enum.TeamType.TEAM_ENEMY) >= 3 and #Wrap.HeroesInRadius(npc, 900, Enum.TeamType.TEAM_ENEMY) <= 1  and #Wrap.HeroesInRadius(npc, 1000, Enum.TeamType.TEAM_FRIEND) <= 1 then
						if (Entity.GetHealth(npc) / Entity.GetMaxHealth(npc)) >= 0.8 and #Wrap.UnitsInRadius(npc, 500, Enum.TeamType.TEAM_FRIEND) >= 2 then	
							if npc ~= nil then
								if (Entity.GetAbsOrigin(npc) - Entity.GetAbsOrigin(myHero)):Length2D() > 3000 then
									if not FAIO.arcWardenPushModeLine then
										if (Entity.GetAbsOrigin(npc) - enemyFountainPos):Length2D() < pushDistance then
											targetCreep = npc
											pushDistance = (Entity.GetAbsOrigin(npc) - enemyFountainPos):Length2D()
											break
										end
									else
										if (Entity.GetAbsOrigin(npc) - myFountainPos):Length2D() < pushDistance then
											targetCreep = npc
											pushDistance = (Entity.GetAbsOrigin(npc) - myFountainPos):Length2D()
											break
										end
									end
								end
							end
						end
					end
				end
			end
		end

		if targetCreep == nil then
			pushDistance = 99999
		end

		if targetCreep ~= nil then
			return Entity.GetAbsOrigin(targetCreep)
		end
	end
end

function FAIO.ArcWardenPush(myHero, tempestDoubleEntity, arcWardenAttackRange)

	if not tempestDoubleEntity then return end
	if not Wrap.EIsAlive(tempestDoubleEntity) then return end
	if tempestDoubleEntity == myHero then return end

	local wardenMana = NPC.GetMana(tempestDoubleEntity)
	local mantaStyle = NPC.GetItem(tempestDoubleEntity, "item_manta", true)

	FAIO.utilityItemMidas(tempestDoubleEntity, NPC.GetItem(tempestDoubleEntity, "item_hand_of_midas", true))

	local necronomicon = NPC.GetItem(tempestDoubleEntity, "item_necronomicon", true)
	if not necronomicon then
		for i = 2, 3 do
			necronomicon = NPC.GetItem(tempestDoubleEntity, "item_necronomicon_" .. i, true)
			if necronomicon then 
				break 
			end
		end
	end

	local mjollnir = NPC.GetItem(tempestDoubleEntity, "item_mjollnir", true)

	if (os.clock() - FAIO.ControlledUnitCastTime) > FAIO.GetAvgLatency() and necronomicon and Ability.IsCastable(necronomicon, wardenMana) then
		Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_NO_TARGET, target, Vector(0,0,0), necronomicon, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, tempestDoubleEntity)
		FAIO.ControlledUnitCastTime = os.clock()
		FAIO.Debugger(GameRules.GetGameTime(), tempestDoubleEntity, "necronomicon", "DOTA_UNIT_ORDER_CAST_NO_TARGET")
	end
	if (os.clock() - FAIO.ControlledUnitCastTime) > FAIO.GetAvgLatency() and mantaStyle and Ability.IsCastable(mantaStyle, wardenMana) then
		Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_NO_TARGET, target, Vector(0,0,0), mantaStyle, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, tempestDoubleEntity)
		FAIO.ControlledUnitCastTime = os.clock()
		FAIO.Debugger(GameRules.GetGameTime(), tempestDoubleEntity, "mantaStyle", "DOTA_UNIT_ORDER_CAST_NO_TARGET")
	end
	if NPC.HasModifier(tempestDoubleEntity, "modifier_kill") then
		local tempestDieTime = Modifier.GetDieTime(NPC.GetModifier(tempestDoubleEntity, "modifier_kill"))
		if tempestDieTime - GameRules.GetGameTime() < 2.5 then
			if mjollnir and Ability.IsCastable(mjollnir, wardenMana) then
				for _, allyCreep in ipairs(Wrap.UnitsInRadius(tempestDoubleEntity, 825, Enum.TeamType.TEAM_FRIEND)) do
					if allyCreep and Wrap.EIsAlive(allyCreep) and NPC.IsLaneCreep(allyCreep) and not NPC.IsRanged(allyCreep) and Entity.GetHealth(allyCreep) > Entity.GetMaxHealth(allyCreep) * 0.6 then
						if (os.clock() - FAIO.ControlledUnitCastTime) > FAIO.GetAvgLatency() then
							Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_TARGET, allyCreep, Vector(0,0,0), mjollnir, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, tempestDoubleEntity)
							FAIO.ControlledUnitCastTime = os.clock()
						end
					end
				end
			end
		end
	end

	local targetHero
	local enemyHeroHealth = 99999
	local targetCreep
	local enemyCreepHealth = 99999
	for i, heroes in ipairs(Wrap.HeroesInRadius(tempestDoubleEntity, 799, Enum.TeamType.TEAM_ENEMY)) do
		if heroes then
        		if Wrap.EIsAlive(heroes) and not Entity.IsDormant(heroes) and not NPC.HasState(heroes, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and not NPC.IsIllusion(heroes) then
				if Entity.GetHealth(heroes) < enemyHeroHealth then
					targetHero = heroes
					enemyHeroHealth = Entity.GetHealth(heroes)
				end
			end
		end
	end
	if #Wrap.HeroesInRadius(tempestDoubleEntity, 799, Enum.TeamType.TEAM_ENEMY) < 1 then
		for i = 1, NPCs.Count() do 
		local creeps = NPCs.Get(i)
			if creeps and Wrap.EIsNPC(creeps) and not Entity.IsSameTeam(myHero, creeps) then
				if NPC.IsEntityInRange(tempestDoubleEntity, creeps, 799) then
					if Wrap.EIsAlive(creeps) and not Entity.IsDormant(creeps) and NPC.IsKillable(creeps) and not NPC.IsWaitingToSpawn(creeps) and NPC.GetUnitName(creeps) ~= "npc_dota_neutral_caster" then
						if Entity.GetHealth(creeps) < enemyCreepHealth then
							if creeps ~= nil then
								targetCreep = creeps
								enemyCreepHealth = Entity.GetHealth(creeps)
							end
						end
					end
				end
			end
		end
	end
	
	if #Wrap.UnitsInRadius(tempestDoubleEntity, 800, Enum.TeamType.TEAM_ENEMY) < 1 then
		targetHero = nil
		enemyHeroHealth = 99999
		targetCreep = nil
		enemyCreepHealth = 99999
	end
	
	if targetHero then
		FAIO.ArcWardenFight(myHero, targetHero, tempestDoubleEntity, arcWardenAttackRange)
		if not NPC.IsLinkensProtected(targetHero) then
			FAIO.itemUsageSmartOrder(tempestDoubleEntity, targetHero, true)
		end
	end

	if targetCreep then

		if not FAIO.TempestInAttackAnimation(myHero) then
			FAIO.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", targetCreep, nil, tempestDoubleEntity)
		end

		if #Wrap.UnitsInRadius(tempestDoubleEntity, 625, Enum.TeamType.TEAM_ENEMY) >= 3 then
			if (os.clock() - FAIO.ControlledUnitCastTime) > FAIO.CastAnimationDelay(NPC.GetAbilityByIndex(tempestDoubleEntity, 1)) and NPC.GetAbilityByIndex(tempestDoubleEntity, 1) and Ability.IsCastable(NPC.GetAbilityByIndex(tempestDoubleEntity, 1), wardenMana) then
				Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_POSITION, target, Entity.GetAbsOrigin(tempestDoubleEntity) + Entity.GetRotation(tempestDoubleEntity):GetForward():Normalized():Scaled(75), NPC.GetAbilityByIndex(tempestDoubleEntity, 1), Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, tempestDoubleEntity)
				FAIO.ControlledUnitCastTime = os.clock()
				return
			end
		end
		if NPC.IsEntityInRange(tempestDoubleEntity, targetCreep, 1900) then
			if (os.clock() - FAIO.ControlledUnitCastTime) > FAIO.CastAnimationDelay(NPC.GetAbilityByIndex(tempestDoubleEntity, 2)) and NPC.GetAbilityByIndex(tempestDoubleEntity, 2) and Ability.IsCastable(NPC.GetAbilityByIndex(tempestDoubleEntity, 2), wardenMana) and not NPC.IsStructure(targetCreep) then
				Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_CAST_POSITION, target, Entity.GetAbsOrigin(targetCreep), NPC.GetAbilityByIndex(tempestDoubleEntity, 2), Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_PASSED_UNIT_ONLY, tempestDoubleEntity)
				FAIO.ControlledUnitCastTime = os.clock()
				return
			end
		end
		for _, necro in ipairs(FAIO.GetNecronomiconEntityTable(myHero, tempestDoubleEntity)) do
			FAIO.NecronomiconController(necro, nil, FAIO.GenericLanePusher(tempestDoubleEntity))
		end
		if #FAIO.GetIllusionEntityTable(myHero, tempestDoubleEntity) > 0 then
			FAIO.MantaIlluController(nil, FAIO.GenericLanePusher(tempestDoubleEntity), myHero, tempestDoubleEntity)
		end		
	end

	if not targetHero and not targetCreep then

		if not FAIO.TempestInAttackAnimation(myHero) then
			FAIO.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_MOVE", nil, FAIO.GenericLanePusher(tempestDoubleEntity), tempestDoubleEntity)
		end

		for _, necro in ipairs(FAIO.GetNecronomiconEntityTable(myHero, tempestDoubleEntity)) do
			FAIO.NecronomiconController(necro, nil, FAIO.GenericLanePusher(tempestDoubleEntity))
		end

		if #FAIO.GetIllusionEntityTable(myHero, tempestDoubleEntity) > 0 then
			FAIO.MantaIlluController(nil, FAIO.GenericLanePusher(tempestDoubleEntity), myHero, tempestDoubleEntity)
		end
	end
end

function FAIO.drawArcWardenPanel(myHero)

	if not myHero then return end
	if not Menu.IsEnabled(FAIO.optionHeroArcWarden) then return end
	
	if Menu.IsKeyDownOnce(FAIO.optionHeroArcWardenPanelKey) then
		FAIO.Toggler = not FAIO.Toggler
	end
	
	if FAIO.Toggler then return end

	local w, h = Renderer.GetScreenSize()
	Renderer.SetDrawColor(255, 255, 255)

	if FAIO.arcWardenPanelX ~= Config.ReadInt("arcWarden", "panelX", w/2) then
		FAIO.arcWardenPanelX = Config.ReadInt("arcWarden", "panelX", w/2)
	end
	if FAIO.arcWardenPanelY ~= Config.ReadInt("arcWarden", "panelY", h/2) then
		FAIO.arcWardenPanelY = Config.ReadInt("arcWarden", "panelY", h/2)
	end

	if Menu.IsEnabled(FAIO.optionHeroArcWardenPanelMove) then
		if Input.IsKeyDownOnce(Enum.ButtonCode.KEY_UP) then
			FAIO.arcWardenPanelY = FAIO.arcWardenPanelY - 10
			Config.WriteInt("arcWarden", "panelY", FAIO.arcWardenPanelY)
		end
		if Input.IsKeyDownOnce(Enum.ButtonCode.KEY_DOWN) then
			FAIO.arcWardenPanelY = FAIO.arcWardenPanelY + 10
			Config.WriteInt("arcWarden", "panelY", FAIO.arcWardenPanelY)
		end
		if Input.IsKeyDownOnce(Enum.ButtonCode.KEY_LEFT) then
			FAIO.arcWardenPanelX = FAIO.arcWardenPanelX - 10
			Config.WriteInt("arcWarden", "panelX", FAIO.arcWardenPanelX)
		end
		if Input.IsKeyDownOnce(Enum.ButtonCode.KEY_RIGHT) then
			FAIO.arcWardenPanelX = FAIO.arcWardenPanelX + 10
			Config.WriteInt("arcWarden", "panelX", FAIO.arcWardenPanelX)
		end
	end

	local startX = FAIO.arcWardenPanelX
	local startY = FAIO.arcWardenPanelY

	local width = 120
	local height = 277

	 -- black background
	Renderer.SetDrawColor(0, 0, 0, 125)
	Renderer.DrawFilledRect(startX, startY, width, height)


	-- black border
	Renderer.SetDrawColor(0, 0, 0, 255)
	Renderer.DrawOutlineRect(startX, startY, width, height)

	Renderer.SetDrawColor(255, 0, 0, 255)
	Wrap.DrawTextCentered(FAIO.arcWardenfont, startX + width/2, startY + 10, "OPTIONS", 1)
	Renderer.SetDrawColor(0, 0, 0, 45)
	Renderer.DrawFilledRect(startX+1, startY+1, width-2, 20-2)

	Renderer.SetDrawColor(0, 191, 255, 255)
	Wrap.DrawTextCentered(FAIO.arcWardenfont, startX + width/2, startY + 30, "TP Push", 1)
	Renderer.SetDrawColor(255, 255, 255, 45)
	Renderer.DrawFilledRect(startX+1, startY+21, width-2, 20-2)
	Renderer.SetDrawColor(0, 0, 0, 255)
	Renderer.DrawOutlineRect(startX, startY+40, width/2, 20)
	Renderer.DrawOutlineRect(startX + width/2, startY+40, width/2, 20)

	local hoveringOverAuto = Input.IsCursorInRect(startX, startY+40, width/2, 20)
	local hoveringOverCursor = Input.IsCursorInRect(startX + width/2, startY+40, width/2, 20)

	if hoveringOverAuto and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) then
		if FAIO.arcWardenPushMode then
			FAIO.arcWardenPushMode = not FAIO.arcWardenPushMode
		end
	end

	if hoveringOverCursor and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) then
		if not FAIO.arcWardenPushMode then
			FAIO.arcWardenPushMode = not FAIO.arcWardenPushMode
		end
	end
	
	if not FAIO.arcWardenPushMode then
		Renderer.SetDrawColor(0, 255, 0, 255)
		Wrap.DrawTextCenteredX(FAIO.arcWardenfont, startX + width/4, startY + 40, "auto", 0)
		Renderer.SetDrawColor(255, 255, 255, 75)
		Wrap.DrawTextCenteredX(FAIO.arcWardenfont, startX + width/4*3, startY + 40, "cursor", 0)
	else
		Renderer.SetDrawColor(255, 255, 255, 75)
		Wrap.DrawTextCenteredX(FAIO.arcWardenfont, startX + width/4, startY + 40, "auto", 0)
		Renderer.SetDrawColor(0, 255, 0, 255)
		Wrap.DrawTextCenteredX(FAIO.arcWardenfont, startX + width/4*3, startY + 40, "cursor", 0)
	end

	Renderer.SetDrawColor(0, 191, 255, 255)
	Wrap.DrawTextCentered(FAIO.arcWardenfont, startX + width/2, startY + 70, "line select", 1)
	Renderer.SetDrawColor(255, 255, 255, 45)
	Renderer.DrawFilledRect(startX+1, startY+61, width-2, 20-2)
	Renderer.SetDrawColor(0, 0, 0, 255)
	Renderer.DrawOutlineRect(startX, startY+80, width/2, 20)
	Renderer.DrawOutlineRect(startX + width/2, startY+80, width/2, 20)

	local hoveringOverFurthest = Input.IsCursorInRect(startX, startY+80, width/2, 20)
	local hoveringOverLeast = Input.IsCursorInRect(startX + width/2, startY+80, width/2, 20)

	if hoveringOverFurthest and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) then
		if FAIO.arcWardenPushModeLine then
			FAIO.arcWardenPushModeLine = not FAIO.arcWardenPushModeLine
		end
	end

	if hoveringOverLeast and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) then
		if not FAIO.arcWardenPushModeLine then
			FAIO.arcWardenPushModeLine = not FAIO.arcWardenPushModeLine
		end
	end
	
	if FAIO.arcWardenPushMode then
		Renderer.SetDrawColor(255, 255, 255, 75)
		Wrap.DrawTextCenteredX(FAIO.arcWardenfont, startX + width/4, startY + 80, "min", 0)
		Wrap.DrawTextCenteredX(FAIO.arcWardenfont, startX + width/4*3, startY + 80, "max", 0)
	else
		if not FAIO.arcWardenPushModeLine then
			Renderer.SetDrawColor(0, 255, 0, 255)
			Wrap.DrawTextCenteredX(FAIO.arcWardenfont, startX + width/4, startY + 80, "min", 0)
			Renderer.SetDrawColor(255, 255, 255, 75)
			Wrap.DrawTextCenteredX(FAIO.arcWardenfont, startX + width/4*3, startY + 80, "max", 0)
		else
			Renderer.SetDrawColor(255, 255, 255, 75)
			Wrap.DrawTextCenteredX(FAIO.arcWardenfont, startX + width/4, startY + 80, "min", 0)
			Renderer.SetDrawColor(0, 255, 0, 255)
			Wrap.DrawTextCenteredX(FAIO.arcWardenfont, startX + width/4*3, startY + 80, "max", 0)
		end
	end

	local startXinfo = startX
	local startYinfo = startY + 110

	Renderer.SetDrawColor(255, 0, 0, 255)
	Wrap.DrawTextCentered(FAIO.arcWardenfont, startXinfo + width/2, startYinfo + 10, "INFORMATION", 1)
	Renderer.SetDrawColor(0, 0, 0, 45)
	Renderer.DrawFilledRect(startXinfo+1, startYinfo+1, width-2, 20-2)

	Renderer.SetDrawColor(0, 191, 255, 255)
	Wrap.DrawTextCentered(FAIO.arcWardenfont, startXinfo + width/2, startYinfo + 30, "Clone action", 1)
	Renderer.SetDrawColor(255, 255, 255, 45)
	Renderer.DrawFilledRect(startX+1, startYinfo+21, width-2, 20-2)

	if FAIO.ArcWardenEntity == nil then
		Renderer.SetDrawColor(255, 100, 0, 255)
		Wrap.DrawTextCenteredX(FAIO.arcWardenfont, startX + width/2, startYinfo + 40, "not spawned", 0)
	else	
		if FAIO.arcWardenStatus == 0 then
			if not Wrap.EIsAlive(FAIO.ArcWardenEntity) then
				Renderer.SetDrawColor(255, 100, 0, 255)
				Wrap.DrawTextCenteredX(FAIO.arcWardenfont, startX + width/2, startYinfo + 40, "dead", 0)
			else
				Renderer.SetDrawColor(255, 100, 0, 255)
				Wrap.DrawTextCenteredX(FAIO.arcWardenfont, startX + width/2, startYinfo + 40, "idle", 0)
			end
		elseif FAIO.arcWardenStatus == 1 and FAIO.ArcTempestLockedTarget ~= nil then
			Renderer.SetDrawColor(0, 255, 0, 255)
			Wrap.DrawTextCenteredX(FAIO.arcWardenfont, startXinfo + width/2, startYinfo + 40, "comboing", 0)
			local heroName = NPC.GetUnitName(FAIO.ArcTempestLockedTarget)
			local heroNameShort = string.gsub(heroName, "npc_dota_hero_", "")
			local imageHandle
				if FAIO.heroIconHandler[heroNameShort] ~= nil then
					imageHandle = FAIO.heroIconHandler[heroNameShort]
				else
					imageHandle = Renderer.LoadImage(FAIO.heroIconPath .. heroNameShort .. ".png")
					FAIO.heroIconHandler[heroNameShort] = imageHandle
				end
			Renderer.SetDrawColor(255, 255, 255, 255)
			Renderer.DrawImage(imageHandle, startX + width/2 - 35, startYinfo + 58, 67, 48)
		elseif FAIO.arcWardenStatus == 1 and FAIO.ArcTempestLockedTarget == nil and FAIO.LockedTarget ~= nil then
			Renderer.SetDrawColor(0, 255, 0, 255)
			Wrap.DrawTextCenteredX(FAIO.arcWardenfont, startXinfo + width/2, startYinfo + 40, "main comboing", 0)
			local heroName = NPC.GetUnitName(FAIO.LockedTarget)
			local heroNameShort = string.gsub(heroName, "npc_dota_hero_", "")
			local imageHandle
				if FAIO.heroIconHandler[heroNameShort] ~= nil then
					imageHandle = FAIO.heroIconHandler[heroNameShort]
				else
					imageHandle = Renderer.LoadImage(FAIO.heroIconPath .. heroNameShort .. ".png")
					FAIO.heroIconHandler[heroNameShort] = imageHandle
				end
			Renderer.SetDrawColor(255, 255, 255, 255)
			Renderer.DrawImage(imageHandle, startX + width/2 - 35, startYinfo + 58, 67, 48)
		elseif FAIO.arcWardenStatus == 2 then
			Renderer.SetDrawColor(0, 255, 0, 255)
			Wrap.DrawTextCenteredX(FAIO.arcWardenfont, startXinfo + width/2, startYinfo + 40, "pushing", 0)
		elseif FAIO.arcWardenStatus == 3 then
			Renderer.SetDrawColor(0, 255, 0, 255)
			Wrap.DrawTextCenteredX(FAIO.arcWardenfont, startXinfo + width/2, startYinfo + 40, "tping", 0)
		elseif FAIO.arcWardenStatus == 4 then
			Renderer.SetDrawColor(0, 255, 0, 255)
			Wrap.DrawTextCenteredX(FAIO.arcWardenfont, startXinfo + width/2, startYinfo + 40, "TP pushing", 0)
		elseif FAIO.arcWardenStatus == 5 then
			Renderer.SetDrawColor(0, 255, 0, 255)
			Wrap.DrawTextCenteredX(FAIO.arcWardenfont, startXinfo + width/2, startYinfo + 40, "hunting", 0)
		end
	end
					
	Renderer.SetDrawColor(0, 191, 255, 255)
	Wrap.DrawTextCentered(FAIO.arcWardenfont, startXinfo + width/2, startYinfo + 120, "Clone CDs", 1)
	Renderer.SetDrawColor(255, 255, 255, 45)
	Renderer.DrawFilledRect(startX+1, startYinfo+111, width-2, 20-2)

	if FAIO.ArcWardenEntity == nil then return end

	local travelBoots1 = NPC.GetItem(FAIO.ArcWardenEntity, "item_travel_boots", true)
	local travelBoots2 = NPC.GetItem(FAIO.ArcWardenEntity, "item_travel_boots_2", true)
	local midas = NPC.GetItem(FAIO.ArcWardenEntity, "item_hand_of_midas", true)
	local necronomicon = NPC.GetItem(FAIO.ArcWardenEntity, "item_necronomicon", true)
	if not necronomicon then
		for i = 2, 3 do
			necronomicon = NPC.GetItem(FAIO.ArcWardenEntity, "item_necronomicon_" .. i, true)
			if necronomicon then 
				break 
			end
		end
	end

	local tempTable = {}
	if travelBoots1 then
		table.insert(tempTable, travelBoots1)
	end
	if travelBoots2 then
		table.insert(tempTable, travelBoots2)
	end
	if midas then
		table.insert(tempTable, midas)
	end
	if necronomicon then
		table.insert(tempTable, necronomicon)
	end

	for i, v in ipairs(tempTable) do

		local itemName = Ability.GetName(v)
		local itemNameShort = string.gsub(itemName, "item_", "")
		local imageHandle
			if FAIO.itemIconHandler[itemNameShort] ~= nil then
				imageHandle = FAIO.itemIconHandler[itemNameShort]
			else
				imageHandle = Renderer.LoadImage(FAIO.itemIconPath .. itemNameShort .. ".png")
				FAIO.itemIconHandler[itemNameShort] = imageHandle
			end
		
		Renderer.SetDrawColor(255, 255, 255, 255)
		Renderer.DrawImage(imageHandle, startX + 3 + (39*(i-1)), startYinfo + 135, 37, 26)
		if Ability.GetCooldownTimeLeft(v) > 0 then
			Renderer.SetDrawColor(255, 255, 255, 45)
			Renderer.DrawFilledRect(startX + 3 + (39*(i-1)), startYinfo + 135, 37, 26)
			Renderer.SetDrawColor(255, 0, 0, 255)
			Wrap.DrawTextCenteredX(FAIO.arcWardenfont, startX + 21 + (39*(i-1)), startYinfo + 139, math.ceil(Ability.GetCooldownTimeLeft(v)), 0)
		end
			
	end

end
		
function FAIO.MorphCombo(myHero, enemy)

	if not Menu.IsEnabled(FAIO.optionHeroMorphling) then return end

	local waveForm = NPC.GetAbilityByIndex(myHero, 0)
	local adaptiveStrikeAGI = NPC.GetAbilityByIndex(myHero, 1)
	local adaptiveStrikeSTR = NPC.GetAbilityByIndex(myHero, 2)

	local blink = NPC.GetItem(myHero, "item_blink", true)

	local myMana = NPC.GetMana(myHero)
	FAIO.itemUsage(myHero, enemy)

	FAIO.GetMorphShotgunDMG(myHero, myMana, enemy)
	FAIO.MorphSelectCombo(myHero, enemy)

	if Menu.IsKeyDown(FAIO.optionComboKey) then
		Engine.ExecuteCommand("dota_range_display 800")
	else
		Engine.ExecuteCommand("dota_range_display 0")
	end

	if Menu.IsEnabled(FAIO.optionHeroMorphHPBalance) then
		FAIO.MorphBalaceHP(myHero, myMana)
	end

	local replicateMod = NPC.GetModifier(myHero, "modifier_morphling_replicate")	

	if not replicateMod then
		if enemy and Menu.IsKeyDown(FAIO.optionComboKey) and Entity.GetHealth(enemy) > 0 then
			if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and FAIO.heroCanCastSpells(myHero, enemy) == true then
				if not NPC.IsEntityInRange(myHero, enemy, 800) then
					if blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1550) then
						Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(300)))
						return
					end
				else
					if NPC.HasItem(myHero, "item_ethereal_blade", true) then
						if Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_ethereal_blade", true)) > 0.1 then
							if FAIO.morphlingComboSelect == false then
								FAIO.MorphComboWithoutWave(myHero, myMana, enemy, adaptiveStrikeAGI, adaptiveStrikeSTR)
							else
								FAIO.MorphComboWithWave(myHero, myMana, enemy, adaptiveStrikeAGI, adaptiveStrikeSTR, waveForm)
							end
						end
					else
						if not FAIO.morphlingComboSelect then
							FAIO.MorphComboWithoutWave(myHero, myMana, enemy, adaptiveStrikeAGI, adaptiveStrikeSTR)
						else
							FAIO.MorphComboWithWave(myHero, myMana, enemy, adaptiveStrikeAGI, adaptiveStrikeSTR, waveForm)
						end
					end
				end	
			end
		FAIO.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil, myHero)
		end
	else
		if enemy and Menu.IsKeyDown(FAIO.optionComboKey) and Entity.GetHealth(enemy) > 0 then
			FAIO.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil, myHero)
		end
	end
		
end

function FAIO.MorphComboWithWave(myHero, myMana, enemy, adaptiveStrikeAGI, adaptiveStrikeSTR, waveForm)

	if not myHero then return end
	if not enemy then return end
	if not adaptiveStrikeAGI or not waveForm then return end
	if Ability.GetLevel(adaptiveStrikeAGI) < 1 or Ability.GetLevel(waveForm) < 1 then return end

	if adaptiveStrikeAGI and Ability.IsCastable(adaptiveStrikeAGI, myMana) then
		Ability.CastTarget(adaptiveStrikeAGI, enemy)
		FAIO.lastTick = os.clock()
		return
	end
	if FAIO.SleepReady(0.1) and waveForm and Ability.IsCastable(waveForm, myMana) and not Ability.IsReady(adaptiveStrikeAGI) then
		Ability.CastPosition(waveForm, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(99))
		return
	end
	if adaptiveStrikeSTR and Ability.IsCastable(adaptiveStrikeSTR, myMana) then
		Ability.CastTarget(adaptiveStrikeSTR, enemy)
		FAIO.lastTick = os.clock()
		return
	end

	return

end

function FAIO.MorphComboWithoutWave(myHero, myMana, enemy, adaptiveStrikeAGI, adaptiveStrikeSTR)

	if not myHero then return end
	if not enemy then return end
	if not adaptiveStrikeAGI then return end
	if Ability.GetLevel(adaptiveStrikeAGI) < 1 then return end

	if adaptiveStrikeAGI and Ability.IsCastable(adaptiveStrikeAGI, myMana) then
		Ability.CastTarget(adaptiveStrikeAGI, enemy)
		return
	end
	if adaptiveStrikeSTR and Ability.IsCastable(adaptiveStrikeSTR, myMana) then
		Ability.CastTarget(adaptiveStrikeSTR, enemy)
		FAIO.lastTick = os.clock()
		return
	end

	return

end

function FAIO.GetMorphShotgunDMG(myHero, myMana, enemy)

	if not myHero then return end
	if not enemy then return end
	if not NPC.GetUnitName(myHero) == "npc_dota_hero_morphling" then return end

	local waveForm = NPC.GetAbilityByIndex(myHero, 0)
	local adaptiveStrike = NPC.GetAbilityByIndex(myHero, 1)

	local waveFormLevel
	if waveForm then
		waveFormLevel = Ability.GetLevel(waveForm)
	end
	local waveFormDMG
	if waveForm and Ability.IsCastable(waveForm, myMana) then
		waveFormDMG = 100 + 75 * (waveFormLevel - 1)
	elseif not waveForm or (waveForm and not Ability.IsCastable(waveForm, myMana)) then
		waveFormDMG = 0
	end

	local adaptiveStrikeLevel
	if adaptiveStrike then
		adaptiveStrikeLevel = Ability.GetLevel(adaptiveStrike)
	end
	local adaptiveStrikeDMG
	if adaptiveStrike and Ability.IsCastable(adaptiveStrike, myMana) then
		local basicDamage = 100
		local myAgility = Hero.GetAgilityTotal(myHero)
		local myStrength = Hero.GetStrengthTotal(myHero)
		local minMultiplier = 0.25
		local maxMultiplier = 0.5 + 0.5 * (adaptiveStrikeLevel - 1)

		local ratio = myAgility / myStrength
		local multiplier = minMultiplier
			if ratio > 1.5 then
				multiplier = maxMultiplier
			end

		adaptiveStrikeDMG = basicDamage + myAgility * multiplier
	elseif not adaptiveStrike or (adaptiveStrike and not Ability.IsCastable(adaptiveStrike, myMana)) then
		adaptiveStrikeDMG = 0
	end
	
	local eBlade = NPC.GetItem(myHero, "item_ethereal_blade", true)
	local eBladeDMG
	if eBlade and Ability.IsCastable(eBlade, myMana) then
		local myAgility = Hero.GetAgilityTotal(myHero)
		eBladeDMG = (2 * myAgility + 75)
	elseif not eBlade or (eBlade and not Ability.IsCastable(eBlade, myMana)) then
		eBladeDMG = 0
	end

	local dagon = NPC.GetItem(myHero, "item_dagon", true)
		if not dagon then
			for i = 2, 5 do
				dagon = NPC.GetItem(myHero, "item_dagon_" .. i, true)
				if dagon then break end
			end
		end
	local dagonDMG = 0
	if dagon and Ability.IsCastable(dagon, myMana) then
		dagonDMG = Ability.GetLevelSpecialValueFor(dagon, "damage")
	end

	local veil = NPC.GetItem(myHero, "item_veil_of_discord", true)

	local overAllDMG = waveFormDMG + adaptiveStrikeDMG + eBladeDMG + dagonDMG
	if veil and Ability.IsCastable(veil, myMana) then
		overAllDMG = overAllDMG * 1.25
	end
	if eBlade and Ability.IsCastable(eBlade, myMana) then
		overAllDMG = overAllDMG * 1.4
	end

	local overAllDMGwoWave = adaptiveStrikeDMG + eBladeDMG + dagonDMG
	if veil and Ability.IsCastable(veil, myMana) then
		overAllDMGwoWave = overAllDMGwoWave * 1.25
	end
	if eBlade and Ability.IsCastable(eBlade, myMana) then
		overAllDMGwoWave = overAllDMGwoWave * 1.4
	end
	
	local trueOverallDMG = math.floor((1 - NPC.GetMagicalArmorValue(enemy)) * overAllDMG + overAllDMG * (Hero.GetIntellectTotal(myHero) / 14 / 100))
	local trueOverallDMGwoWave = math.floor((1 - NPC.GetMagicalArmorValue(enemy)) * overAllDMGwoWave + overAllDMGwoWave * (Hero.GetIntellectTotal(myHero) / 14 / 100))

	if NPC.HasModifier(myHero, "modifier_morphling_replicate") then
		FAIO.morphlingTotalDMG = 0
		FAIO.morphlingTotalDMGwoWave = 0
	end

	FAIO.morphlingTotalDMG = trueOverallDMG - 35
	FAIO.morphlingTotalDMGwoWave = trueOverallDMGwoWave - 35
	

end

function FAIO.MorphBalaceHP(myHero, myMana)

	if not myHero then return end
	if not FAIO.MorphBalanceToggler then return end
	
	if os.clock() - FAIO.MorphBalanceTimer < 0.1 then return end

	if NPC.IsSilenced(myHero) then return end
	if NPC.IsStunned(myHero) then return end

	local targetHP
	if FAIO.MorphBalanceSelectedHP > 0 then
		targetHP = FAIO.MorphBalanceSelectedHP
	end

	if not targetHP then return end

	local morphAGI = NPC.GetAbility(myHero, "morphling_morph_agi")
	local morphSTR = NPC.GetAbility(myHero, "morphling_morph_str")

		if not morphAGI or not morphSTR then return end
		if Ability.GetLevel(morphAGI) < 1 then return end
		if NPC.HasModifier(myHero, "modifier_morphling_replicate") then return end

	local myHP = Entity.GetHealth(myHero)
	local myMAXHP = Entity.GetMaxHealth(myHero)

	local shouldToggleAGI = false
	local shouldToggleStr = false
	local allowedDeviation = Menu.GetValue(FAIO.optionHeroMorphHPBalanceDeviation)

	if not NPC.HasModifier(myHero, "modifier_fountain_aura_buff") then
		if targetHP - myHP >= allowedDeviation then
			if Hero.GetAgility(myHero) > 1 then
				shouldToggleStr = true
			else
				shouldToggleStr = false
			end
		else
			shouldToggleStr = false
		end

		if myMAXHP - targetHP >= allowedDeviation and (myHP - targetHP) >= allowedDeviation then
			if Hero.GetStrength(myHero) > 1 then
				shouldToggleAGI = true
			else
				shouldToggleAGI = false
			end
		else
			shouldToggleAGI = false
		end

		if myMana < 35 then
			shouldToggleAGI = false
			shouldToggleStr = false
		end
	else
		if myMAXHP - myHP <= 50 then
			if myMAXHP - targetHP >= 50 then
				shouldToggleAGI = true
			elseif targetHP - myHP >= 50 then
				shouldToggleStr = true
			else
				shouldToggleAGI = false
				shouldToggleStr = false
			end
		end
	end
	

	if shouldToggleStr then
		if not Ability.GetToggleState(morphSTR) then
			Ability.Toggle(morphSTR)
			FAIO.MorphBalanceTimer = os.clock()
			return
		end
	else
		if Ability.GetToggleState(morphSTR) then
			Ability.Toggle(morphSTR)
			FAIO.MorphBalanceTimer = os.clock()
			return
		end
	end

	if shouldToggleAGI then
		if not Ability.GetToggleState(morphAGI) then
			Ability.Toggle(morphAGI)
			FAIO.MorphBalanceTimer = os.clock()
			return
		end
	else
		if Ability.GetToggleState(morphAGI) then
			Ability.Toggle(morphAGI)
			FAIO.MorphBalanceTimer = os.clock()
			return
		end
	end
				
end

function FAIO.MorphDrawBalanceBoard(myHero)

	if not myHero then return end
	if not Menu.IsEnabled(FAIO.optionHeroMorphDrawBoard) then return end

	local maxMorphAGI = math.floor(Hero.GetAgility(myHero))
	local maxMorphSTR = math.floor(Hero.GetStrength(myHero))

	local currentMAXHP = Entity.GetMaxHealth(myHero)

	local minHP = currentMAXHP - maxMorphSTR * 20
	local maxHP = currentMAXHP + maxMorphAGI * 20

	local w, h = Renderer.GetScreenSize()
	Renderer.SetDrawColor(255, 255, 255)

	local startX = w - 300 - Menu.GetValue(FAIO.optionHeroMorphDrawBoardXPos)
	local startY = 300 + Menu.GetValue(FAIO.optionHeroMorphDrawBoardYPos)
	
	if Menu.IsKeyDownOnce(FAIO.optionHeroMorphBoardToggleKey) then
		FAIO.Toggler = not FAIO.Toggler
	end

	if not FAIO.Toggler then return end
		
	-- black background
	Renderer.SetDrawColor(0, 0, 0, 150)
	Renderer.DrawFilledRect(startX-1, startY, 202, 25)

	-- black border
	Renderer.SetDrawColor(0, 0, 0, 255)
	Renderer.DrawOutlineRect(startX-1, startY, 202, 25)

	-- min/max HP
	Renderer.SetDrawColor(0, 255, 0, 150)
	Renderer.DrawText(FAIO.font, startX-25, startY-25, minHP, 0)
	Renderer.SetDrawColor(255, 0, 0, 150)
	Renderer.DrawText(FAIO.font, startX+175, startY-25, maxHP, 0)

	-- colored rect
	for i = 1, 20 do
		Renderer.SetDrawColor(25 + i*10, 230 - i*10, 0, 150)
		Renderer.DrawFilledRect(startX + (i-1)*10 , startY+1, 10, 23)
	end

	-- hovering rects
	local hoveringTable = {}
	if next(hoveringTable) == nil then
		for i = 1, 20 do
			hoveringTable[i] = Input.IsCursorInRect(startX + (i-1)*10 , startY+1, 10, 23)
		end
	end

	-- on/off rects
	Renderer.SetDrawColor(0, 0, 0, 255)
	Renderer.DrawOutlineRect(startX+75, startY-25, 50, 20)
	Renderer.SetDrawColor(0, 0, 0, 150)
	Renderer.DrawFilledRect(startX+75, startY-25, 50, 20)
		local togglerHovering = Input.IsCursorInRect(startX+75, startY-25, 50, 20)
		if togglerHovering and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) then
			FAIO.MorphBalanceToggler = not FAIO.MorphBalanceToggler
		end

	if FAIO.MorphBalanceToggler then
		Renderer.SetDrawColor(0, 255, 0, 150)
		Wrap.DrawTextCenteredX(FAIO.font, startX+100, startY-27, "ON", 0)
	else
		Renderer.SetDrawColor(255, 0, 0, 150)
		Wrap.DrawTextCenteredX(FAIO.font, startX+100, startY-27, "OFF", 0)
	end

	local HPsteps = math.floor((maxHP - minHP) / 20)

	if Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) then
		for i, v in ipairs(hoveringTable) do
			if hoveringTable[1] == true then
				FAIO.MorphBalanceSelectedHP = minHP
				FAIO.MorphBalanceSelected = 1
			elseif hoveringTable[20] == true then
				FAIO.MorphBalanceSelectedHP = maxHP
				FAIO.MorphBalanceSelected = 20
			else
				if v == true then
					FAIO.MorphBalanceSelectedHP = minHP + HPsteps*i
					FAIO.MorphBalanceSelected = i
				end
			end		
		end
	end

	if FAIO.MorphBalanceSelected > 0 then
		Renderer.SetDrawColor(0, 0, 0, 200)
		Renderer.DrawFilledRect(startX+3+10*(FAIO.MorphBalanceSelected-1), startY, 4, 30)
		Wrap.DrawTextCenteredX(FAIO.font, startX+3+10*(FAIO.MorphBalanceSelected-1), startY+30, FAIO.MorphBalanceSelectedHP, 0)
	end

end

function FAIO.MorphSelectCombo(myHero, enemy)

	if not myHero then return end
	if not enemy then return end

	local adaptiveStrike = NPC.GetAbilityByIndex(myHero, 1)

	if adaptiveStrike and Ability.SecondsSinceLastUse(adaptiveStrike) > -1 and Ability.SecondsSinceLastUse(adaptiveStrike) < ((Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Length2D() / 1150) + 0.15 then
		FAIO.morphlingComboSelect = false
		return
	end

	if Entity.GetHealth(enemy) >= FAIO.morphlingTotalDMGwoWave then
		FAIO.morphlingComboSelect = true
	else
		FAIO.morphlingComboSelect = false
	end
	return

end		

function FAIO.drawMorphlingKillIndicator(myHero)

	if not myHero then return end
	
	if FAIO.morphlingTotalDMG == 0 then return end

	local enemy = FAIO.targetChecker(Input.GetNearestHeroToCursor(Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY))
		if not enemy then return end
		if not NPC.IsPositionInRange(enemy, Input.GetWorldCursorPos(), 500, 0) then return end

	local pos = Entity.GetAbsOrigin(enemy)
	local posY = NPC.GetHealthBarOffset(enemy)
		pos:SetZ(pos:GetZ() + posY)
			
	local x, y, visible = Renderer.WorldToScreen(pos)

	if FAIO.morphlingTotalDMG > 0 then
		if visible then
			if Entity.GetHealth(enemy) > FAIO.morphlingTotalDMG then
				Renderer.SetDrawColor(255,102,102,255)
			else
				Renderer.SetDrawColor(50,205,50,255)
			end
				Renderer.DrawText(FAIO.skywrathFont, x-50, y-70, "Shotgun DMG:  " .. math.floor(FAIO.morphlingTotalDMG), 0)
		end
	end

end

function FAIO.PuckCombo(myHero, enemy)

	if not Menu.IsEnabled(FAIO.optionHeroPuck) then return end
	if not NPC.IsEntityInRange(myHero, enemy, 3000)	then return end

	local illusoryOrb = NPC.GetAbilityByIndex(myHero, 0)
	local etherealJaunt = NPC.GetAbility(myHero, "puck_ethereal_jaunt")
	local waningRift = NPC.GetAbilityByIndex(myHero, 1)
	local phaseShift = NPC.GetAbility(myHero, "puck_phase_shift")
	local dreamCoil = NPC.GetAbility(myHero, "puck_dream_coil")

	local blink = NPC.GetItem(myHero, "item_blink", true)

	local myMana = NPC.GetMana(myHero)
	FAIO.itemUsage(myHero, enemy)

	local orbIsFlying = false
	if illusoryOrb and Ability.SecondsSinceLastUse(illusoryOrb) > 0 and Ability.SecondsSinceLastUse(illusoryOrb) <= 2.995 then
		orbIsFlying = true
	end

	if orbIsFlying then
		FAIO.lastPosition = Vector(0, 0, 0)
	end
		
	if Menu.IsEnabled(FAIO.optionHeroPuckPanic) then
		if Menu.IsKeyDownOnce(FAIO.optionHeroPuckPanicKey) then
			FAIO.GenericUpValue = false
		end
		if Menu.IsKeyDown(FAIO.optionHeroPuckPanicKey) then
			FAIO.PuckPanic(myHero, enemy, myMana, orbIsFlying)
		end
	end

	if Menu.IsEnabled(FAIO.optionHeroPuckDefend) then
		FAIO.PuckDefend(myHero, enemy, myMana, waningRift)
	end

	if Menu.IsKeyDown(FAIO.optionComboKey) and Entity.GetHealth(enemy) > 0 and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and FAIO.heroCanCastSpells(myHero, enemy) == true then
		if not NPC.IsEntityInRange(myHero, enemy, 375) then
			if blink and Ability.IsReady(blink) then
				if NPC.IsEntityInRange(myHero, enemy, 1000) then
					FAIO.lastPosition = Entity.GetAbsOrigin(myHero)
					if Menu.GetValue(FAIO.optionHeroPuckJump) == 0 then
						Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(175))
						return
					else
						if #Wrap.NInRadius(Entity.GetAbsOrigin(enemy), 375, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY) <= 1 then
							Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(175))
							return
						else
							local bestPos = FAIO.getBestPosition(Wrap.HInRadius(Entity.GetAbsOrigin(enemy), 700, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY), 350)
							if bestPos ~= nil then
								Ability.CastPosition(blink, bestPos)
								return
							end
						end
					end
				else
					if FAIO.SleepReady(0.1) then
						Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION, target, Entity.GetAbsOrigin(enemy), ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_HERO_ONLY, npc, queue, showEffects)
						FAIO.lastTick = os.clock()
						return
					end
				end
			end

			if not blink and Menu.IsEnabled(FAIO.optionHeroPuckOrbInit) then
				if FAIO.SleepReady(0.15) and illusoryOrb and Ability.IsCastable(illusoryOrb, myMana) then
					local orbPrediction = Ability.GetCastPoint(illusoryOrb) + (Entity.GetAbsOrigin(enemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 651) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
					Ability.CastPosition(illusoryOrb, FAIO.castLinearPrediction(myHero, enemy, orbPrediction))
					FAIO.lastTick = os.clock()
					FAIO.PuckOrbCastTime = GameRules.GetGameTime()
					return
				end
				if etherealJaunt and Ability.IsReady(etherealJaunt) then
					for _, v in ipairs(FAIO.PuckOrbHitSim) do
						local origin = v[1]
						local velocity = v[2]
						local orbPos = origin + velocity:Scaled(GameRules.GetGameTime() - FAIO.PuckOrbCastTime)
						if NPC.IsPositionInRange(enemy, orbPos, 150, 0) then
							Ability.CastNoTarget(etherealJaunt)
							FAIO.PuckOrbHitSim = {}
							return
						end
					end
				end		
			end
		else
			if not Ability.IsChannelling(phaseShift) or NPC.HasModifier(myHero, "modifier_eul_cyclone") then
				if FAIO.SleepReady(0.15) and waningRift and Ability.IsCastable(waningRift, myMana) then 
					Ability.CastNoTarget(waningRift)
					FAIO.lastTick = os.clock()
				end
				if Menu.IsKeyDown(FAIO.optionHeroPuckComboAltKey) then	
					if FAIO.SleepReady(0.15) and dreamCoil and Ability.IsCastable(dreamCoil, myMana) then
						local bestPos = FAIO.getBestPosition(Wrap.HInRadius(Entity.GetAbsOrigin(enemy), 700, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY), 350)
						if bestPos ~= nil then
							Ability.CastPosition(dreamCoil, bestPos)
							FAIO.lastTick = os.clock()
						end
					end
				end
				if FAIO.SleepReady(0.15) and illusoryOrb and Ability.IsCastable(illusoryOrb, myMana) then
					if FAIO.lastPosition:__tostring() ~= Vector(0, 0, 0):__tostring() then
						Ability.CastPosition(illusoryOrb, Entity.GetAbsOrigin(myHero) + (FAIO.lastPosition - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(500))
						FAIO.lastTick = os.clock()
						return
					end
					if FAIO.lastPosition:__tostring() == Vector(0, 0, 0):__tostring() then
						Ability.CastPosition(illusoryOrb, Entity.GetAbsOrigin(myHero) + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(500))
						FAIO.lastTick = os.clock()
						return
					end
				end			
			else
				FAIO.GenericUpValue = false
				FAIO.PuckPanic(myHero, enemy, myMana, orbIsFlying)
			end
		end
	FAIO.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil, myHero)	
	end
end

function FAIO.PuckPanic(myHero, enemy, myMana, orbIsFlying)

	if FAIO.heroCanCastSpells(myHero, enemy) == false then return end

	local illusoryOrb = NPC.GetAbilityByIndex(myHero, 0)
	local etherealJaunt = NPC.GetAbility(myHero, "puck_ethereal_jaunt")
	local phaseShift = NPC.GetAbility(myHero, "puck_phase_shift")

	local blink = NPC.GetItem(myHero, "item_blink", true)
	local euls = NPC.GetItem(myHero, "item_cyclone", true)

	local orbFlyingTimeLeft = 0
		if orbIsFlying then
			orbFlyingTimeLeft = 2.995 - Ability.SecondsSinceLastUse(illusoryOrb)
		end

	if NPC.IsSilenced(myHero) then
		if not FAIO.GenericUpValue then
			if blink and Ability.IsReady(blink) then
				if Menu.GetValue(FAIO.optionHeroPuckPanicDirection) == 0 then
					Ability.CastPosition(blink, Entity.GetAbsOrigin(myHero) + (FAIO.GetMyFountainPos(myHero) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(1150))
					FAIO.GenericUpValue = true
					return
				else
					Ability.CastPosition(blink, Entity.GetAbsOrigin(myHero) + (Input.GetWorldCursorPos() - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(1150))
					FAIO.GenericUpValue = true
					return
				end
			end
			if (blink and Ability.GetCooldownTimeLeft(blink) <= 2.5) or (illusoryOrb and Ability.GetCooldownTimeLeft(illusoryOrb) <= 2.5) or (phaseShift and blink and Ability.GetCooldownTimeLeft(blink) <= 2.5 + Ability.GetLevelSpecialValueForFloat(phaseShift, "duration")) then
				if euls and Ability.IsCastable(euls, myMana) then
					Ability.CastTarget(euls, myHero)
					return
				end
			end
		end
		if (not euls or (euls and not Ability.IsCastable(euls, myMana))) and (not blink or (blink and not Ability.IsReady(blink))) then
			return
		end	
	else
		if not FAIO.GenericUpValue and not Ability.IsChannelling(phaseShift) then
			if illusoryOrb and Ability.SecondsSinceLastUse(illusoryOrb) > 0 and Ability.SecondsSinceLastUse(illusoryOrb) <= 2.995 then
				if Ability.SecondsSinceLastUse(illusoryOrb) > 0 and Ability.SecondsSinceLastUse(illusoryOrb) <= 1.25 then
					if phaseShift and Ability.IsReady(phaseShift) then
						Ability.CastNoTarget(phaseShift)
						return
					end
				end
				if Ability.SecondsSinceLastUse(illusoryOrb) > 1.25 and Ability.SecondsSinceLastUse(illusoryOrb) <= 2.995 then
					if etherealJaunt and Ability.IsReady(etherealJaunt) then
						Ability.CastNoTarget(etherealJaunt)
						FAIO.GenericUpValue = true
						return
					end
				end
			end		
			if blink then
				if Ability.IsReady(blink) then
					if Menu.GetValue(FAIO.optionHeroPuckPanicDirection) == 0 then
						Ability.CastPosition(blink, Entity.GetAbsOrigin(myHero) + (FAIO.GetMyFountainPos(myHero) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(1150))
						FAIO.GenericUpValue = true
						return
					else
						Ability.CastPosition(blink, Entity.GetAbsOrigin(myHero) + (Input.GetWorldCursorPos() - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(1150))
						FAIO.GenericUpValue = true
						return
					end
				end
				if Ability.GetCooldownTimeLeft(blink) > 0.1 and Ability.GetCooldownTimeLeft(blink) < Ability.GetLevelSpecialValueForFloat(phaseShift, "duration") then
					if phaseShift and Ability.IsReady(phaseShift) then
						Ability.CastNoTarget(phaseShift)
						return
					end
				end
			end
			if illusoryOrb and Ability.IsCastable(illusoryOrb, myMana) and (phaseShift and Ability.IsReady(phaseShift)) then
				if Menu.GetValue(FAIO.optionHeroPuckPanicDirection) == 0 then
					Ability.CastPosition(illusoryOrb, Entity.GetAbsOrigin(myHero) + (FAIO.GetMyFountainPos(myHero) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(500))
					Ability.CastNoTarget(phaseShift, true)
					return
				else
					Ability.CastPosition(illusoryOrb, Entity.GetAbsOrigin(myHero) + (Input.GetWorldCursorPos() - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(500))
					Ability.CastNoTarget(phaseShift, true)
					return
				end
			end
			if euls and Ability.IsCastable(euls, myMana) then
				if (blink and Ability.GetCooldownTimeLeft(blink) > Ability.GetLevelSpecialValueForFloat(phaseShift, "duration") and Ability.GetCooldownTimeLeft(blink) <= Ability.GetLevelSpecialValueForFloat(phaseShift, "duration") + 2.5) or (illusoryOrb and Ability.GetCooldownTimeLeft(illusoryOrb) > 0 and Ability.GetCooldownTimeLeft(illusoryOrb) < 2.5 and phaseShift and Ability.GetCooldownTimeLeft(phaseShift) < 2.5) then
					Ability.CastTarget(euls, myHero)
					return
				end
			end	
		end
	end

	if Ability.IsChannelling(phaseShift) then
		if not FAIO.GenericUpValue then
			if orbIsFlying then
				local phaseShiftTimeLeft = math.max(Ability.GetChannelStartTime(phaseShift) + Ability.GetLevelSpecialValueForFloat(phaseShift, "duration") - GameRules.GetGameTime(), 0)
				if etherealJaunt and Ability.IsReady(etherealJaunt) then
					if phaseShiftTimeLeft > orbFlyingTimeLeft then
						if orbFlyingTimeLeft / 2.995 <= 0.25 then
							Ability.CastNoTarget(etherealJaunt)
							FAIO.GenericUpValue = true
							return
						end
					else
						if phaseShiftTimeLeft / Ability.GetLevelSpecialValueForFloat(phaseShift, "duration") <= 0.25 then
							Ability.CastNoTarget(etherealJaunt)
							FAIO.GenericUpValue = true
							return
						end
					end
						
				end
			end
			if not orbIsFlying then
				if blink and Ability.IsReady(blink) then
					if Menu.GetValue(FAIO.optionHeroPuckPanicDirection) == 0 then
						Ability.CastPosition(blink, Entity.GetAbsOrigin(myHero) + (FAIO.GetMyFountainPos(myHero) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(1150))
						FAIO.GenericUpValue = true
						return
					else
						Ability.CastPosition(blink, Entity.GetAbsOrigin(myHero) + (Input.GetWorldCursorPos() - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(1150))
						FAIO.GenericUpValue = true
						return
					end
				end
			end
			
		end
	end				
end


function FAIO.PuckDefend(myHero, enemy, myMana, waningRift)

	if not myHero then return end

	if FAIO.heroCanCastSpells(myHero, enemy) == false then return end
	if FAIO.isHeroChannelling(myHero) == true then return end 
	if FAIO.IsHeroInvisible(myHero) == true then return end

	if not waningRift then return end
	if not Ability.IsCastable(waningRift, myMana) then return end

	for _, heroes in ipairs(Wrap.HeroesInRadius(myHero, 400, Enum.TeamType.TEAM_ENEMY)) do
		if heroes and not Entity.IsDormant(heroes) and Wrap.EIsAlive(heroes) then
			local enemyDagger = NPC.GetItem(heroes, "item_blink", true)
			if enemyDagger and NPC.IsEntityInRange(myHero, heroes, 375) and Ability.GetCooldownTimeLeft(enemyDagger) >= 9 and Ability.SecondsSinceLastUse(enemyDagger) > 0 and Ability.SecondsSinceLastUse(enemyDagger) <= 1 then
				if waningRift and Ability.IsCastable(waningRift, myMana) and not NPC.HasState(heroes, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
					Ability.CastNoTarget(waningRift)
					break
					return
				end
			end
		end
	end
end

function FAIO.ZuusCombo(myHero, enemy)

	if not Menu.IsEnabled(FAIO.optionHeroZuus) then return end

  	local arc = NPC.GetAbilityByIndex(myHero, 0)
 	local bolt = NPC.GetAbilityByIndex(myHero, 1)
 	local static = NPC.GetAbilityByIndex(myHero, 2)
 	local wrath = NPC.GetAbility(myHero, "zuus_thundergods_wrath")
	local nimbus = NPC.GetAbility(myHero, "zuus_cloud")

	local lens = NPC.GetItem(myHero, "item_aether_lens", true)
	local refresher = NPC.GetItem(myHero, "item_refresher", true)
	local blink = NPC.GetItem(myHero, "item_blink", true)

	local bonusTalentRange = NPC.GetAbility(myHero, "special_bonus_cast_range_200")
  	local arcBonusTalentDamage = NPC.GetAbility(myHero, "special_bonus_unique_zeus_2")
  	local staticBonusTalentDamage = NPC.GetAbility(myHero, "special_bonus_unique_zeus")
	local spellAmplification = Hero.GetIntellectTotal(myHero)  / 14 / 100

	local arcCastRange = 850
  	local boltCastRange = 700
  	local staticCastRange = 1200

	if lens then
    		arcCastRange = arcCastRange + 250
    		boltCastRange = boltCastRange + 250
    		staticCastRange = staticCastRange + 250
  	end

	local arcDamage = 0
		if arc then
			arcDamage = Ability.GetLevelSpecialValueFor(arc, "arc_damage") * (1 + spellAmplification / 100)
		end
  	local boltDamage = Ability.GetDamage(bolt) * (1 + spellAmplification / 100)
	local staticDamage = 0
	if static and Ability.GetLevel(static) > 0 then
		staticDamage = 2 + (2 * Ability.GetLevel(static))
	end
  	local wrathDamage = (225 + (100 * (Ability.GetLevel(wrath) - 1))) * (1 + spellAmplification / 100)

	if arcBonusTalentDamage and Ability.GetLevel(arcBonusTalentDamage) > 0 then
    		arcDamage = arcDamage + (75 * (1 + spellAmplification / 100))
  	end

	if bonusTalentRange and Ability.GetLevel(bonusTalentRange) > 0 then
    		arcCastRange = arcCastRange + 200
    		boltCastRange = boltCastRange + 200
    		staticCastRange = staticCastRange + 200
  	end

	if staticBonusTalentDamage and Ability.GetLevel(staticBonusTalentDamage) > 0 then
      		staticDamage = staticDamage + 2
    	end

	local myMana = NPC.GetMana(myHero)

	FAIO.itemUsage(myHero, enemy)

	if Menu.IsKeyDown(FAIO.optionHeroZuusFarmKey) then
		FAIO.ZuusArcFarm(myHero, myMana, arc, arcDamage, arcCastRange, staticDamage)
	end

	if Menu.IsKeyDown(FAIO.optionHeroZuusHarassKey) then
		FAIO.ZuusArcHarass(myHero, myMana, arc, arcCastRange)
	end

	if Menu.IsKeyDown(FAIO.optionHeroZuusFarmKey) or Menu.IsKeyDown(FAIO.optionHeroZuusHarassKey) then
		Engine.ExecuteCommand("dota_range_display " .. tostring(arcCastRange))
	else
		Engine.ExecuteCommand("dota_range_display 0")
	end

	if Menu.IsEnabled(FAIO.optionHeroZuusKillsteal) then
		FAIO.ZuusFullKillSteal(myHero, myMana, arc, bolt, static, wrath, arcCastRange, boltCastRange, staticCastRange, arcDamage, boltDamage, staticDamage, wrathDamage, refresher, nimbus)
	end
	
	if enemy and NPC.IsEntityInRange(myHero, enemy, 2000) then	
		if Menu.IsKeyDown(FAIO.optionComboKey) and Wrap.EIsAlive(enemy) and FAIO.heroCanCastSpells(myHero, enemy) == true then
			if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_INVULNERABLE) then
				if not NPC.IsEntityInRange(myHero, enemy, boltCastRange) then
					if blink and Ability.IsReady(blink) and Menu.IsEnabled(FAIO.optionHeroZuusBlink) then
						if NPC.IsEntityInRange(myHero, enemy, 1900) then
							Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(750))
							return
						else
							if FAIO.SleepReady(0.5) then
								Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION, target, Entity.GetAbsOrigin(enemy), ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_HERO_ONLY, npc, queue, showEffects)
								FAIO.lastTick = os.clock()
								return
							end
						end
					end
					if not blink or (blink and not Ability.IsReady(blink)) or not Menu.IsEnabled(FAIO.optionHeroZuusBlink) then
						if FAIO.SleepReady(0.5) then
							NPC.MoveTo(myHero, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(boltCastRange - 75), false, false)
							FAIO.lastTick = os.clock()
							return
						end
					end
					if arc and Ability.IsCastable(arc, myMana) and NPC.IsEntityInRange(myHero, enemy, arcCastRange) then
						Ability.CastTarget(arc, enemy)
						FAIO.lastTick = os.clock()
					end	
				else
					if arc and Ability.IsCastable(arc, myMana) then
						Ability.CastTarget(arc, enemy)
						FAIO.lastTick = os.clock()
					end
					if FAIO.SleepReady(0.2) and bolt and Ability.IsCastable(bolt, myMana) then
						Ability.CastTarget(bolt, enemy)
						FAIO.lastTick = os.clock()
					end
				end
			end
			if Menu.IsEnabled(FAIO.optionHeroZuusRightClick) then
				FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
			end
		end
	end

end

function FAIO.ZuusArcHarass(myHero, myMana, arc, arcCastRange)

	if not myHero then return end

	if FAIO.heroCanCastSpells(myHero, enemy) == false then return end
	if FAIO.isHeroChannelling(myHero) == true then return end 
	if FAIO.IsHeroInvisible(myHero) == true then return end

	if not arc then return end
		if not Ability.IsCastable(arc, myMana) then return end

	local targetHero
	local minHP = 99999

	if (myMana / NPC.GetMaxMana(myHero)) >= (Menu.GetValue(FAIO.optionHeroZuusHarassMana) / 100) then
		for _, hero in ipairs(Wrap.HeroesInRadius(myHero, arcCastRange - 25, Enum.TeamType.TEAM_ENEMY)) do
			if hero and Entity.IsHero(hero) and not Entity.IsDormant(hero) and not NPC.IsIllusion(hero) then
				if Wrap.EIsAlive(hero) then
					if Entity.GetHealth(hero) < minHP then
						targetHero = hero
						minHP = Entity.GetHealth(hero)
					end
				end
			end
		end
	end

	if targetHero then
		Ability.CastTarget(arc, targetHero)
        	return
	else
		if (myMana / NPC.GetMaxMana(myHero)) >= (Menu.GetValue(FAIO.optionHeroZuusHarassMana) / 100) then
			for _, npc in ipairs(Wrap.UnitsInRadius(myHero, arcCastRange - 25, Enum.TeamType.TEAM_ENEMY)) do
				if npc and not Entity.IsDormant(npc) and not Entity.IsHero(npc) and NPC.IsCreep(npc) then 
					if Wrap.EIsAlive(npc) and not NPC.IsWaitingToSpawn(npc) and NPC.GetUnitName(npc) ~= "npc_dota_neutral_caster" then
        					Ability.CastTarget(arc, npc)
						break
        					return
					end
				end	
			end
      		end		
	end

end

function FAIO.ZuusArcFarm(myHero, myMana, arc, arcDamage, arcCastRange, staticDamage)

	if not myHero then return end

	if FAIO.heroCanCastSpells(myHero, enemy) == false then return end
	if FAIO.isHeroChannelling(myHero) == true then return end 
	if FAIO.IsHeroInvisible(myHero) == true then return end

	if not arc then return end
		if not Ability.IsCastable(arc, myMana) then return end

	for _, npc in ipairs(Wrap.UnitsInRadius(myHero, arcCastRange - 25, Enum.TeamType.TEAM_ENEMY)) do

		if npc and not Entity.IsDormant(npc) and not Entity.IsHero(npc) and NPC.IsCreep(npc) then 
			if Wrap.EIsAlive(npc) and not NPC.IsWaitingToSpawn(npc) and NPC.GetUnitName(npc) ~= "npc_dota_neutral_caster" then
      				if Entity.GetHealth(npc) < (arcDamage + (Entity.GetHealth(npc) * (staticDamage / 100))) * NPC.GetMagicalArmorDamageMultiplier(npc) then
        				Ability.CastTarget(arc, npc)
					break
        				return
				end
			end
      		end		
	end

end

function FAIO.ZuusFullKillSteal(myHero, myMana, arc, bolt, static, wrath, arcCastRange, boltCastRange, staticCastRange, arcDamage, boltDamage, staticDamage, wrathDamage, refresher, nimbus)

	if not myHero then return end
	
	if FAIO.heroCanCastSpells(myHero, enemy) == false then return end
	if FAIO.isHeroChannelling(myHero) == true then return end 
	if FAIO.IsHeroInvisible(myHero) == true then return end

	for i = 1, Heroes.Count() do
	local enemies = Heroes.Get(i)
		if enemies ~= nil and Entity.IsHero(enemies) and not Entity.IsSameTeam(myHero, enemies) then
			local enemy = FAIO.targetChecker(enemies)
			if enemy then
				if Ability.GetLevel(static) > 0 and NPC.IsEntityInRange(myHero, enemy, staticCastRange-25, 0) then
          				boltDamage  = boltDamage + (Entity.GetHealth(enemy) * (staticDamage / 100))
          				arcDamage = arcDamage + (Entity.GetHealth(enemy) * (staticDamage / 100))
        			end
        			boltDamage = NPC.GetMagicalArmorDamageMultiplier(enemy) * boltDamage
        			arcDamage = NPC.GetMagicalArmorDamageMultiplier(enemy) * arcDamage
        			wrathDamage = NPC.GetMagicalArmorDamageMultiplier(enemy) * wrathDamage
				if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_INVULNERABLE) and not NPC.HasModifier(enemy, "modifier_templar_assassin_refraction_absorb") then
        				if FAIO.ZuusWrathCount(myHero, myMana, wrath, wrathDamage, static, staticDamage, staticCastRange, false) == true and wrath and Ability.IsCastable(wrath, myMana) then
            					Ability.CastNoTarget(wrath) 
            					return
          				end
					if refresher and Ability.IsCastable(refresher, myMana) then
						if FAIO.ZuusWrathCount(myHero, myMana, wrath, wrathDamage, static, staticDamage, staticCastRange, true) == true and wrath and Ability.IsCastable(wrath, myMana) then
            						Ability.CastNoTarget(wrath)
							Ability.CastNoTarget(refresher, true)
            						return
						end
					end
					if nimbus and not Ability.IsHidden(nimbus) and Ability.IsCastable(nimbus, myMana) then
						if not NPC.IsPositionInRange(myHero, Entity.GetAbsOrigin(enemy), arcCastRange, 0) then
							if Entity.GetHealth(enemy) <= boltDamage then
								Ability.CastPosition(nimbus, Entity.GetAbsOrigin(enemy))
								return
							end
						end
					end
					if not NPC.IsLinkensProtected(enemy) and Entity.GetHealth(enemy) <= arcDamage and arc and Ability.IsCastable(arc, myMana) and NPC.IsPositionInRange(myHero, Entity.GetAbsOrigin(enemy), arcCastRange, 0) then
            					Ability.CastTarget(arc, enemy) 
            					return 
         				end
        				if not NPC.IsLinkensProtected(enemy) and Entity.GetHealth(enemy) <= boltDamage and bolt and Ability.IsCastable(bolt, myMana) and NPC.IsPositionInRange(myHero, Entity.GetAbsOrigin(enemy), boltCastRange, 0) then
            					Ability.CastTarget(bolt, enemy) 
           	 				return
          				end
        				if not NPC.IsLinkensProtected(enemy) and Entity.GetHealth(enemy) <= (boltDamage + arcDamage) and arc and bolt and Ability.IsCastable(bolt, myMana - 80) and Ability.IsCastable(arc, myMana) and NPC.IsPositionInRange(myHero, Entity.GetAbsOrigin(enemy), boltCastRange, 0) then
            					Ability.CastTarget(bolt, enemy)
						Ability.CastTarget(arc, enemy, true)
            					return 
          				end
          			end
			end
		end
	end

end

function FAIO.ZuusWrathCount(myHero, myMana, wrath, wrathDamage, static, staticDamage, staticCastRange, doubleUlt)

	if not myHero then return false end
	if not wrath then return false end
		if not Ability.IsReady(wrath) then return false end
		if not Ability.IsCastable(wrath, myMana) then return false end

	local count = 0
	local countRefresher = 0
	for i = 1, Heroes.Count(), 1 do
	local enemies = Heroes.Get(i)
		if enemies ~= nil and Entity.IsHero(enemies) and not Entity.IsSameTeam(myHero, enemies) then
			local enemy = FAIO.targetChecker(enemies)
			if enemy then
				if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_INVULNERABLE) then
					if not doubleUlt then
						if Ability.GetLevel(static) > 0 and NPC.IsEntityInRange(myHero, enemy, staticCastRange-25, 0) then
							if Entity.GetHealth(enemy) <= (wrathDamage + (Entity.GetHealth(enemy) * (staticDamage / 100))) then
								count = count + 1
							end
						else
							if Entity.GetHealth(enemy) <= wrathDamage then
								count = count + 1
							end
						end
					else
						if Ability.GetLevel(static) > 0 and NPC.IsEntityInRange(myHero, enemy, staticCastRange-25, 0) then
							if Entity.GetHealth(enemy) <= (wrathDamage + (Entity.GetHealth(enemy) * (staticDamage / 100))) * 2 then
								countRefresher = countRefresher + 1
							end
						else
							if Entity.GetHealth(enemy) <= wrathDamage * 2 then
								countRefresher = countRefresher + 1
							end
						end	
					end
				end
			end
		end
	end

	if count > 0 and doubleUlt == false then
		if count >= Menu.GetValue(FAIO.optionHeroZuusUltCount) then
			return true
		end
	end

	if countRefresher > 0 and doubleUlt == true and myMana > (Ability.GetManaCost(wrath) * 2 + 375) then
		if countRefresher >= Menu.GetValue(FAIO.optionHeroZuusUltCountRefresher) then
			return true
		end
	end

	return false

end

function FAIO.ProphetHelper(myHero, enemy)

	if not Menu.IsEnabled(FAIO.optionHeroProphet) then return end
	
	if Menu.IsKeyDownOnce(FAIO.optionHeroProphetToggleKey) then
		FAIO.Toggler = not FAIO.Toggler
		FAIO.TogglerTime = os.clock()
	end

	FAIO.itemUsage(myHero, enemy)

	if enemy and NPC.IsEntityInRange(myHero, enemy, 2000) then	
		if Menu.IsKeyDown(FAIO.optionComboKey) and Wrap.EIsAlive(enemy) and FAIO.heroCanCastItems(myHero) == true then
			FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
		end
	end
	
	local treantEntities = {}
	if FAIO.Toggler then
		for i = 1, NPCs.Count() do 
		local npc = NPCs.Get(i)
			if npc and Entity.IsSameTeam(myHero, npc) and Wrap.EIsAlive(npc) then
				if npc ~= myHero then
					if Entity.GetOwner(npc) == myHero then
						if npc ~= nil then
							if NPC.GetUnitName(npc) == "npc_dota_furion_treant" then
								if npc ~= nil then
									FAIO.GenericAttackIssuer2("Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_MOVE", nil, FAIO.GenericLanePusher(npc), npc)
								end
							end	
						end
					end
				end
			end
		end
	end
			
end

function FAIO.DrawProphetHelperSwitch()

	local w, h = Renderer.GetScreenSize()
	Renderer.SetDrawColor(255, 0, 255)

	if os.clock() - FAIO.TogglerTime < 3 then
		if FAIO.Toggler then
			Wrap.DrawTextCentered(FAIO.font, w / 2, h / 2 + 300, "LANE PUSH ON", 1)
		else 
			Wrap.DrawTextCentered(FAIO.font, w / 2, h / 2 + 300, "LANE PUSH OFF", 1)
		end
	end

end

function FAIO.DrawProphetAwareness(myHero)

	if not myHero then return end
	local w, h = Renderer.GetScreenSize()
	Renderer.SetDrawColor(255, 255, 255)

	for i = 1, Heroes.Count() do 
	local hero = Heroes.Get(i)
		if hero and not Entity.IsSameTeam(myHero, hero) and Wrap.EIsAlive(hero) then
			if not Entity.IsDormant(hero) and not NPC.IsIllusion(hero) then
				if Entity.GetHealth(hero) / Entity.GetMaxHealth(hero) <= 0.20 then
					Wrap.DrawTextCentered(FAIO.font, w / 2, h / 2 + 300, "POSSIBLE PORT TARGET", 1)
					FAIO.DrawProphetAwarenessMinimap(hero)
				end
			end
		end
	end
end

function FAIO.DrawProphetAwarenessMinimap(hero)

	if not hero then return end
	if not Menu.IsEnabled(FAIO.optionProphetDrawKSminimap) then return end

	local w, h = Renderer.GetScreenSize()
	local targetPos = Entity.GetAbsOrigin(hero)
	Renderer.SetDrawColor(255, 255, 255)

	position = FAIO:WorldToMiniMap(targetPos, w, h)
	Renderer.DrawText(FAIO.font, position:GetX(), position:GetY(), "X", 1)

end

function FAIO.InvokerCombo(myHero, enemy)

	if not Menu.IsEnabled(FAIO.optionHeroInvoker) then return end
	if FAIO.heroCanCastSpells(myHero, enemy) == false then return end

	if os.clock() - FAIO.invokerCaptureGhostwalkActivation < 1.0 then return end

	if Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0)) < 1 and Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 2)) < 1 and Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 2)) < 1 then
		return
	end

	local sunStrike = NPC.GetAbility(myHero, "invoker_sun_strike")
	local emp = NPC.GetAbility(myHero, "invoker_emp")
	local tornado = NPC.GetAbility(myHero, "invoker_tornado")
	local ghostWalk = NPC.GetAbility(myHero, "invoker_ghost_walk")
	local deafeningBlast = NPC.GetAbility(myHero, "invoker_deafening_blast")
	local chaosMeteor = NPC.GetAbility(myHero, "invoker_chaos_meteor")
	local iceWall = NPC.GetAbility(myHero, "invoker_ice_wall")
	local coldSnap = NPC.GetAbility(myHero, "invoker_cold_snap")
	local alacrity = NPC.GetAbility(myHero, "invoker_alacrity")
	local forgeSpirit = NPC.GetAbility(myHero, "invoker_forge_spirit")

	local invoke = NPC.GetAbility(myHero, "invoker_invoke")
	local myMana = NPC.GetMana(myHero)
	local aghanims = NPC.GetItem(myHero, "item_ultimate_scepter", true)
	local refresher = NPC.GetItem(myHero, "item_refresher", true)
	local blink = NPC.GetItem(myHero, "item_blink", true)
		if not Menu.IsEnabled(FAIO.optionHeroInvokerBlink) then
			blink = nil
		end

	if NPC.HasAbility(myHero, "special_bonus_unique_invoker_8") then
		if Ability.GetLevel(NPC.GetAbility(myHero, "special_bonus_unique_invoker_8")) > 0 then
			if FAIO.invokerTornadoLiftDuration[1] < 1.1 then
				FAIO.invokerTornadoLiftDuration = { 1.1, 1.4, 1.7, 2.0, 2.3, 2.6, 2.9, 3.2 }
			end
		end
	end
	
	local euls = NPC.GetItem(myHero, "item_cyclone", true)

	local invokeTranslator = {
		"invoker_tornado",
		"invoker_emp",
		"invoker_chaos_meteor", 
		"invoker_deafening_blast",
		"invoker_sun_strike",
		"invoker_ice_wall",
		"invoker_cold_snap",
		"invoker_forge_spirit",
		"invoker_alacrity"
			}

	if Menu.IsKeyDown(FAIO.optionHeroInvokerAltKey) and Menu.IsKeyDown(FAIO.optionComboKey) then
		if FAIO.InvokerComboSelector == 1 then
			FAIO.PreInvokeSkills = {{coldSnap, forgeSpirit}}
		elseif FAIO.InvokerComboSelector == 2 then
			FAIO.PreInvokeSkills = {{coldSnap, forgeSpirit}}
		elseif FAIO.InvokerComboSelector == 3 then
			FAIO.PreInvokeSkills = {{emp, tornado}}
		elseif FAIO.InvokerComboSelector == 4 then
			FAIO.PreInvokeSkills = {{chaosMeteor, tornado}}
		elseif FAIO.InvokerComboSelector == 5 then
			FAIO.PreInvokeSkills = {{chaosMeteor, sunStrike}}
		elseif FAIO.InvokerComboSelector == 6 then
			FAIO.PreInvokeSkills = {{emp, tornado}}
		elseif FAIO.InvokerComboSelector == 7 then
			FAIO.PreInvokeSkills = {{sunStrike, tornado}}
		elseif FAIO.InvokerComboSelector == 8 then
			FAIO.PreInvokeSkills = {{sunStrike, tornado}}
		elseif FAIO.InvokerComboSelector == 9 then
			FAIO.PreInvokeSkills = {{emp, tornado}}
		elseif FAIO.InvokerComboSelector == 10 then
			FAIO.PreInvokeSkills = {{deafeningBlast, chaosMeteor}}
		elseif FAIO.InvokerComboSelector == 12 then
			if Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill1) > 0 and Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill2) > 0 then
				if Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill1) > 9 and Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill2) <= 9 then
					FAIO.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill3)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill2)])}}
				elseif Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill1) <= 9 and Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill2) > 9 then
					FAIO.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill3)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill1)])}}
				elseif Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill1) > 9 and Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill2) > 9 then
					FAIO.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill4)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill3)])}}
				else
					FAIO.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill2)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill1)])}}
				end
			end
		elseif FAIO.InvokerComboSelector == 13 then
			if Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill1) > 0 and Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill2) > 0 then
				if Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill1) > 9 and Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill2) <= 9 then
					FAIO.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill3)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill2)])}}
				elseif Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill1) <= 9 and Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill2) > 9 then
					FAIO.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill3)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill1)])}}
				elseif Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill1) > 9 and Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill2) > 9 then
					FAIO.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill4)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill3)])}}
				else
					FAIO.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill2)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill1)])}}
				end
			end
		elseif FAIO.InvokerComboSelector == 14 then
			if Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill1) > 0 and Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill2) > 0 then
				if Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill1) > 9 and Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill2) <= 9 then
					FAIO.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill3)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill2)])}}
				elseif Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill1) <= 9 and Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill2) > 9 then
					FAIO.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill3)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill1)])}}
				elseif Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill1) > 9 and Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill2) > 9 then
					FAIO.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill4)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill3)])}}
				else
					FAIO.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill2)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill1)])}}
				end
			end
		end
	end
	

	if Menu.IsKeyDownOnce(FAIO.optionInvokerGhostWalkKey) then
		FAIO.invokerCaptureGhostwalkActivation = os.clock()
	end
	
	if next(FAIO.PreInvokeSkills) ~= nil then
		FAIO.InvokerPreInvoke(myHero, myMana, invoke)
	end
	
	if Menu.IsKeyDown(FAIO.optionHeroInvokerIcewallKey) then
		FAIO.InvokerFastIceWall(myHero, myMana, invoke, enemy)
	end

	if Menu.IsKeyDown(FAIO.optionHeroInvokerAlacrityKey) then
		FAIO.InvokerFastAlacrity(myHero, myMana, invoke, enemy)
	end

	if Menu.IsKeyDown(FAIO.optionHeroInvokerTornadoKey) then
		FAIO.InvokerFastTornado(myHero, myMana, invoke, enemy)
	end

	if Menu.IsKeyDownOnce(FAIO.optionHeroInvokerCustom1Key) then
		if Menu.IsEnabled(FAIO.optionHeroInvokerAutoInvoke) then
			if FAIO.InvokerComboSelector ~= 12 then
				if Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill1) > 0 and Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill2) > 0 then
					if Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill1) > 9 and Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill2) <= 9 then
						FAIO.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill3)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill2)])}}
						FAIO.InvokerComboSelector = 12
					elseif Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill1) <= 9 and Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill2) > 9 then
						FAIO.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill3)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill1)])}}
						FAIO.InvokerComboSelector = 12
					elseif Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill1) > 9 and Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill2) > 9 then
						FAIO.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill4)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill3)])}}
						FAIO.InvokerComboSelector = 12
					else
						FAIO.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill2)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill1)])}}
						FAIO.InvokerComboSelector = 12
					end
				else
					FAIO.InvokerComboSelector = 0
				end	
			end
		else
			if FAIO.InvokerComboSelector ~= 12 then
				FAIO.InvokerComboSelector = 12
			end
		end
	end

	if Menu.IsKeyDownOnce(FAIO.optionHeroInvokerCustom2Key) then
		if Menu.IsEnabled(FAIO.optionHeroInvokerAutoInvoke) then
			if FAIO.InvokerComboSelector ~= 13 then
				if Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill1) > 0 and Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill2) > 0 then
					if Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill1) > 9 and Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill2) <= 9 then
						FAIO.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill3)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill2)])}}
						FAIO.InvokerComboSelector = 13
					elseif Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill1) <= 9 and Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill2) > 9 then
						FAIO.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill3)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill1)])}}
						FAIO.InvokerComboSelector = 13
					elseif Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill1) > 9 and Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill2) > 9 then
						FAIO.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill4)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill3)])}}
						FAIO.InvokerComboSelector = 13
					else
						FAIO.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill2)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill1)])}}
						FAIO.InvokerComboSelector = 13
					end
				else
					FAIO.InvokerComboSelector = 0
				end		
			end
		else
			if FAIO.InvokerComboSelector ~= 13 then
				FAIO.InvokerComboSelector = 13
			end
		end
	end

	if Menu.IsKeyDownOnce(FAIO.optionHeroInvokerCustom3Key) then
		if Menu.IsEnabled(FAIO.optionHeroInvokerAutoInvoke) then
			if FAIO.InvokerComboSelector ~= 14 then
				if Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill1) > 0 and Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill2) > 0 then
					if Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill1) > 9 and Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill2) <= 9 then
						FAIO.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill3)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill2)])}}
						FAIO.InvokerComboSelector = 14
					elseif Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill1) <= 9 and Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill2) > 9 then
						FAIO.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill3)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill1)])}}
						FAIO.InvokerComboSelector = 14
					elseif Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill1) > 9 and Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill2) > 9 then
						FAIO.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill4)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill3)])}}
						FAIO.InvokerComboSelector = 14
					else
						FAIO.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill2)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill1)])}}
						FAIO.InvokerComboSelector = 14
					end
				else
					FAIO.InvokerComboSelector = 0
				end		
			end
		else
			if FAIO.InvokerComboSelector ~= 14 then
				FAIO.InvokerComboSelector = 14
			end
		end
	end

	if Menu.IsEnabled(FAIO.optionHeroInvokerCancelEnable) then
		if Menu.IsEnabled(FAIO.optionHeroInvokerCancelTPFog) then
			FAIO.InvokerCancelTPingInFog(myHero, myMana, enemy, invoke, tornado)
		end
		if Menu.IsEnabled(FAIO.optionHeroInvokerCancelBara) then
			FAIO.InvokerCancelBaraCharge(myHero, myMana, enemy, invoke, coldSnap, tornado, deafeningBlast)
		end
		if Menu.IsEnabled(FAIO.optionHeroInvokerCancelChannelling) then
			FAIO.InvokerCancelVisibleChannellingAbilities(myHero, myMana, enemy, invoke, coldSnap, tornado)
		end
	end

	if Menu.IsEnabled(FAIO.optionKillStealInvokerTPpartice) then
		FAIO.EnemyHPTracker(myHero)
	end
	
	if Menu.IsEnabled(FAIO.optionHeroInvokerCataKS) then
		FAIO.InvokerCataclysmKillSteal(myHero, myMana, invoke)
	end



	if Menu.IsKeyDown(FAIO.optionComboKey) and not Menu.IsKeyDown(FAIO.optionHeroInvokerAltKey) then
		if enemy and Entity.GetHealth(enemy) > 0 then
			if NPC.IsEntityInRange(myHero, enemy, 1500) and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
				if FAIO.InvokerComboSelector == 0 then
					FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
				elseif FAIO.InvokerComboSelector == 1 then
					FAIO.InvokerComboCSAlacritySpirit(myHero, myMana, enemy, coldSnap, alacrity, forgeSpirit, blink, invoke)
				elseif FAIO.InvokerComboSelector == 2 then
					FAIO.InvokerComboCSSpiritSunstrike(myHero, myMana, enemy, coldSnap, forgeSpirit, sunStrike, blink, invoke)
				elseif FAIO.InvokerComboSelector == 3 then
					FAIO.InvokerComboTornadoEmpIcewall(myHero, myMana, enemy, tornado, emp, iceWall, coldSnap, blink, invoke)
				elseif FAIO.InvokerComboSelector == 4 then
					FAIO.InvokerComboTornadoMeteorBlast(myHero, myMana, enemy, tornado, chaosMeteor, deafeningBlast, blink, invoke)
				elseif FAIO.InvokerComboSelector == 5 then
					FAIO.InvokerComboEulsSunstrikeMeteorBlast(myHero, myMana, enemy, sunStrike, chaosMeteor, deafeningBlast, blink, euls, invoke)
				elseif FAIO.InvokerComboSelector == 6 then
					FAIO.InvokerComboAghaTornadoEmpMeteorBlast(myHero, myMana, enemy, tornado, emp, chaosMeteor, deafeningBlast, aghanims, blink, invoke)
				elseif FAIO.InvokerComboSelector == 7 then
					FAIO.InvokerComboAghaTornadoSunstrikeMeteorBlast(myHero, myMana, enemy, tornado, sunStrike, chaosMeteor, deafeningBlast, aghanims, blink, invoke)
				elseif FAIO.InvokerComboSelector == 8 then
					FAIO.InvokerComboRefresherAghaTornadoSunstrikeMeteorBlast(myHero, myMana, enemy, tornado, sunStrike, chaosMeteor, deafeningBlast, aghanims, refresher, blink, invoke)
				elseif FAIO.InvokerComboSelector == 9 then
					FAIO.InvokerComboRefresherAghaTornadoEmpMeteorBlast(myHero, myMana, enemy, tornado, emp, chaosMeteor, deafeningBlast, aghanims, refresher, blink, invoke)
				elseif FAIO.InvokerComboSelector == 10 then
					FAIO.InvokerComboRefresherAghaBlastMeteorSunstrike(myHero, myMana, enemy, deafeningBlast, chaosMeteor, sunStrike, blink, aghanims, refresher, invoke)
				elseif FAIO.InvokerComboSelector == 11 then
					FAIO.InvokerComboDynamicMode(myHero, myMana, enemy, blink, invoke)
				elseif FAIO.InvokerComboSelector == 12 then
					FAIO.InvokerComboCustomMode(myHero, myMana, enemy, blink, invoke)
				elseif FAIO.InvokerComboSelector == 13 then
					FAIO.InvokerComboCustomMode(myHero, myMana, enemy, blink, invoke)
				elseif FAIO.InvokerComboSelector == 14 then
					FAIO.InvokerComboCustomMode(myHero, myMana, enemy, blink, invoke)
				end
			else
				FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
			end
		end
	else
		FAIO.InvokerCanComboStart = false
	end

end

function FAIO.InvokerIceWallHelper(myHero, enemy, iceWall, myMana)
	
	if not myHero then return end
	if not enemy then return end
	if FAIO.heroCanCastSpells(myHero, enemy) == false then return end

	if not iceWall then return end
	if not Ability.IsReady(iceWall) or not Ability.IsCastable(iceWall, myMana) or not FAIO.InvokerIsAbilityInvoked(myHero, iceWall) then return end
	if not NPC.IsEntityInRange(myHero, enemy, 600) then return end

	local betaRad = math.acos(200 / (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D())
	local beta = betaRad * 180 / math.pi
	local delta = math.acos((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Dot(Entity.GetRotation(myHero):GetForward()) / (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() * (Entity.GetRotation(myHero):GetForward()):Length2D()) * 180 / math.pi

	if NPC.IsEntityInRange(myHero, enemy, 275) then
		Ability.CastNoTarget(iceWall)
		return
	else
		if math.abs(delta - beta) > 7.5 then
			FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Entity.GetAbsOrigin(myHero) + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(5):Rotated(beta))		
			return
		else
			Ability.CastNoTarget(iceWall)
			return
		end
	end

end

function FAIO.InvokerComboCSAlacritySpirit(myHero, myMana, enemy, coldSnap, alacrity, forgeSpirit, blink, invoke)

	if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) < 0.25 then return end
	if NPC.HasModifier(myHero, "modifier_invoker_ghost_walk_self") then return end

	FAIO.itemUsage(myHero, enemy)

	if FAIO.InvokerInvokedChecker(myHero, "invoker_cold_snap", "invoker_forge_spirit") and invoke and Ability.IsReady(invoke) then
	FAIO.InvokerCanComboStart = true
		if not NPC.IsEntityInRange(myHero, enemy, NPC.GetAttackRange(myHero)) then
			if blink and Ability.IsReady(blink) then
				if NPC.IsEntityInRange(myHero, enemy, 1150 + 400) then
					Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(400))
					return
				else
					if FAIO.SleepReady(0.1) then
						Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION, target, Entity.GetAbsOrigin(enemy), ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_HERO_ONLY, npc, queue, showEffects)
						FAIO.lastTick = os.clock()
						return
					end
				end
			end
			if not blink or (blink and not Ability.IsReady(blink)) then
				FAIO.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil, myHero)
				return
			end
		else
			if FAIO.SleepReady(0.05) and coldSnap and Ability.IsCastable(coldSnap, myMana) then
				Ability.CastTarget(coldSnap, enemy)
				FAIO.lastTick = os.clock()
				return
			end
			if FAIO.SleepReady(0.05) and forgeSpirit and Ability.IsCastable(forgeSpirit, myMana) then
				Ability.CastNoTarget(forgeSpirit)
				FAIO.lastTick = os.clock()
				return
			end
			if FAIO.SleepReady(0.05) and invoke and Ability.IsCastable(invoke, myMana) and FAIO.InvokerIsSkillInvokable(myHero, alacrity) then
				FAIO.invokerInvokeAbility(myHero, alacrity)
				FAIO.lastTick = os.clock()
				return
			end
		end
	else
		if Menu.IsEnabled(FAIO.optionHeroInvokerForceDynamic) then
			if not FAIO.InvokerCanComboStart then
				FAIO.InvokerComboDynamicMode(myHero, myMana, enemy, blink, invoke)
				return
			end
		end
	end	




	if not Ability.IsReady(coldSnap) and not Ability.IsReady(forgeSpirit) then
		if FAIO.SleepReady(0.05) and alacrity and Ability.IsCastable(alacrity, myMana) then
			Ability.CastTarget(alacrity, myHero)
			FAIO.lastTick = os.clock()
			return
		end
	end

	FAIO.invokerForgedSpiritController(myHero, enemy)

	if Menu.IsEnabled(FAIO.optionHeroInvokerSwitch) then
		if not Ability.IsReady(coldSnap) and not Ability.IsReady(forgeSpirit) and not Ability.IsReady(alacrity) then
			FAIO.InvokerComboSelector = 11
		end
	end

	FAIO.invokerProcessInstancesWhileComboing(myHero)
	FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	return

end

function FAIO.InvokerComboCSSpiritSunstrike(myHero, myMana, enemy, coldSnap, forgeSpirit, sunStrike, blink, invoke)

	if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) < 0.25 then return end
	if NPC.HasModifier(myHero, "modifier_invoker_ghost_walk_self") then return end

	FAIO.itemUsage(myHero, enemy)

	if FAIO.InvokerInvokedChecker(myHero, "invoker_cold_snap", "invoker_forge_spirit") and invoke and Ability.IsReady(invoke) then
	FAIO.InvokerCanComboStart = true
		if not NPC.IsEntityInRange(myHero, enemy, NPC.GetAttackRange(myHero)) then
			if blink and Ability.IsReady(blink) then
				if NPC.IsEntityInRange(myHero, enemy, 1150 + 400) then
					Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(400))
					return
				else
					if FAIO.SleepReady(0.1) then
						Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION, target, Entity.GetAbsOrigin(enemy), ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_HERO_ONLY, npc, queue, showEffects)
						FAIO.lastTick = os.clock()
						return
					end
				end
			end
			if not blink or (blink and not Ability.IsReady(blink)) then
				FAIO.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil, myHero)
				return
			end
		else
			if FAIO.SleepReady(0.05) and coldSnap and Ability.IsCastable(coldSnap, myMana) then
				Ability.CastTarget(coldSnap, enemy)
				FAIO.lastTick = os.clock()
				return
			end
			if not Ability.IsReady(coldSnap) and FAIO.SleepReady(0.05) and forgeSpirit and Ability.IsCastable(forgeSpirit, myMana) then
				Ability.CastNoTarget(forgeSpirit)
				FAIO.lastTick = os.clock()
				return
			end
			if not Ability.IsReady(forgeSpirit) and FAIO.SleepReady(0.05) and invoke and Ability.IsCastable(invoke, myMana) and FAIO.InvokerIsSkillInvokable(myHero, sunStrike) then
				FAIO.invokerInvokeAbility(myHero, sunStrike)
				FAIO.lastTick = os.clock()
				return
			end
		end
	else
		if Menu.IsEnabled(FAIO.optionHeroInvokerForceDynamic) then
			if not FAIO.InvokerCanComboStart then
				FAIO.InvokerComboDynamicMode(myHero, myMana, enemy, blink, invoke)
				return
			end
		end
	end
	
	FAIO.invokerForgedSpiritController(myHero, enemy)

	if not Ability.IsReady(coldSnap) and not Ability.IsReady(forgeSpirit) then
		if FAIO.SleepReady(0.05) and sunStrike and Ability.IsCastable(sunStrike, myMana) and FAIO.InvokerIsAbilityInvoked(myHero, sunStrike) then
			if not NPC.IsTurning(enemy) then
				Ability.CastPosition(sunStrike, FAIO.castPrediction(myHero, enemy, Ability.GetCastPoint(NPC.GetAbility(myHero, "invoker_sun_strike")) + 1.7 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)))
				FAIO.lastTick = os.clock()
				return
			end
		end
	end

	if Menu.IsEnabled(FAIO.optionHeroInvokerSwitch) then
		if not Ability.IsReady(coldSnap) and not Ability.IsReady(forgeSpirit) and not Ability.IsReady(sunStrike) then
			FAIO.InvokerComboSelector = 11
		end
	end

	FAIO.invokerProcessInstancesWhileComboing(myHero)
	FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	return

end


function FAIO.InvokerComboTornadoEmpIcewall(myHero, myMana, enemy, tornado, emp, iceWall, coldSnap, blink, invoke)

	if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) < 0.25 then return end
	if NPC.HasModifier(myHero, "modifier_invoker_ghost_walk_self") then return end

	local rangeChecker
		if 400 + (400 * Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 1))) < 1000 then
			rangeChecker = 400 + (400 * Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 1)))
		else
			rangeChecker = 1000
		end

	if Menu.IsEnabled(FAIO.optionHeroInvokerTornadoItems) then
		FAIO.itemUsage(myHero, enemy)
	else
		if not Ability.IsReady(tornado) then
			FAIO.itemUsage(myHero, enemy)
		end
	end

	if FAIO.InvokerInvokedChecker(myHero, Ability.GetName(emp), Ability.GetName(tornado)) and invoke and Ability.IsReady(invoke) then
	FAIO.InvokerCanComboStart = true
		if not NPC.IsEntityInRange(myHero, enemy, 1000) then
			if blink and Ability.IsReady(blink) then
				if NPC.IsEntityInRange(myHero, enemy, 1150 + NPC.GetAttackRange(myHero)) then
					FAIO.noItemCastFor(0.5)
					Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(600))
					return
				else
					if FAIO.SleepReady(0.1) then
						Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION, target, Entity.GetAbsOrigin(enemy), ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_HERO_ONLY, npc, queue, showEffects)
						FAIO.lastTick = os.clock()
						FAIO.noItemCastFor(0.5)
						return
					end
				end
			end
			if not blink or (blink and not Ability.IsReady(blink)) and not NPC.HasModifier(enemy, "modifier_invoker_tornado") then
				FAIO.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil, myHero)
				FAIO.noItemCastFor(0.5)
				return
			end
		else
			local travelTime = (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000
			local tornadoTiming = FAIO.invokerTornadoLiftDuration[Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0))] * (1 - (math.ceil(Hero.GetStrengthTotal(enemy) * 0.15)/100)) + travelTime
			if tornadoTiming < 2.9 then
				if FAIO.SleepReady(0.05) and emp and Ability.IsCastable(emp, myMana) then
					if NPC.IsEntityInRange(myHero, enemy, 925) then
						Ability.CastPosition(emp, Entity.GetAbsOrigin(enemy))
						FAIO.lastTick = os.clock()
						FAIO.lastCastTime = os.clock()
						return
					else
						Ability.CastPosition(emp, Entity.GetAbsOrigin(myHero) + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(925))
						FAIO.lastTick = os.clock()
						FAIO.lastCastTime = os.clock()
						return
					end
				end
				if not Ability.IsReady(emp) then
					if FAIO.SleepReady(0.05) and tornado and Ability.IsCastable(tornado, myMana) then
						if os.clock() - FAIO.lastCastTime <= 2.9 - tornadoTiming - 0.5 then
							FAIO.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil, myHero)
							return
						else	
							if Menu.GetValue(FAIO.optionHeroInvokerSkillshotStyle) == 0 then
								local tornadoPrediction = Ability.GetCastPoint(tornado) + (Entity.GetAbsOrigin(enemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1000) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
								Ability.CastPosition(tornado, FAIO.castLinearPrediction(myHero, enemy, tornadoPrediction))
								FAIO.lastTick = os.clock()
								FAIO.noItemCastFor((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000 + 0.5)
								return
							else
								Ability.CastPosition(tornado, Input.GetWorldCursorPos())
								FAIO.lastTick = os.clock()
								FAIO.noItemCastFor((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000 + 0.5)
								return
							end
						end
					end
				end
			else
				if FAIO.SleepReady(0.05) and tornado and Ability.IsCastable(tornado, myMana) then
					if Menu.GetValue(FAIO.optionHeroInvokerSkillshotStyle) == 0 then
						local tornadoPrediction = Ability.GetCastPoint(tornado) + (Entity.GetAbsOrigin(enemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1000) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
						Ability.CastPosition(tornado, FAIO.castLinearPrediction(myHero, enemy, tornadoPrediction))
						FAIO.lastTick = os.clock()
						FAIO.lastCastTime = os.clock()
						FAIO.noItemCastFor((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000 + 0.5)
						return
					else
						Ability.CastPosition(tornado, Input.GetWorldCursorPos())
						FAIO.lastTick = os.clock()
						FAIO.lastCastTime = os.clock()
						FAIO.noItemCastFor((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000 + 0.5)
						return
					end
				end
				if FAIO.SleepReady(0.05) and emp and Ability.IsCastable(emp, myMana) then
					local travelTime = (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000
					local tornadoTiming = FAIO.invokerTornadoLiftDuration[Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0))] * (1 - (math.ceil(Hero.GetStrengthTotal(enemy) * 0.15)/100)) + travelTime
					if os.clock() - FAIO.lastCastTime > tornadoTiming - 2.9 + 0.05 then
						if NPC.IsEntityInRange(myHero, enemy, 925) then
							Ability.CastPosition(emp, Entity.GetAbsOrigin(enemy))
							FAIO.lastTick = os.clock()
							return
						else
							Ability.CastPosition(emp, Entity.GetAbsOrigin(myHero) + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(925))
							FAIO.lastTick = os.clock()
							return
						end
					end
				end
			end
			if not Ability.IsReady(emp) and not Ability.IsReady(tornado) and NPC.HasModifier(enemy, "modifier_invoker_tornado") then
				local distance = math.abs((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() - 550)
				local timeToTarget = distance / NPC.GetMoveSpeed(myHero)
				if GameRules.GetGameTime() + timeToTarget <= Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_tornado")) then
					if FAIO.SleepReady(0.05) and invoke and Ability.IsCastable(invoke, myMana) and FAIO.InvokerIsSkillInvokable(myHero, iceWall) then
						FAIO.invokerInvokeAbility(myHero, iceWall)
						FAIO.lastTick = os.clock()
						return
					end
				else
					if FAIO.SleepReady(0.05) and invoke and Ability.IsCastable(invoke, myMana) and FAIO.InvokerIsSkillInvokable(myHero, coldSnap) then
						FAIO.invokerInvokeAbility(myHero, coldSnap)
						FAIO.lastTick = os.clock()
						return
					end
				end
			end
		end
	else
		if Menu.IsEnabled(FAIO.optionHeroInvokerForceDynamic) then
			if not FAIO.InvokerCanComboStart then
				FAIO.InvokerComboDynamicMode(myHero, myMana, enemy, blink, invoke)
				return
			end
		end
	end

	if not Ability.IsReady(tornado) and not Ability.IsReady(emp) then
		if FAIO.InvokerIsAbilityInvoked(myHero, iceWall) then
			if FAIO.SleepReady(0.05) and iceWall and Ability.IsCastable(iceWall, myMana) then
				if not NPC.IsEntityInRange(myHero, enemy, 550) then
					FAIO.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(500), myHero)
				else
					FAIO.InvokerIceWallHelper(myHero, enemy, iceWall, myMana)
					FAIO.lastTick = os.clock()
					return
				end
			end
		end
		if FAIO.InvokerIsAbilityInvoked(myHero, coldSnap) then
			if FAIO.SleepReady(0.05) and coldSnap and Ability.IsCastable(coldSnap, myMana) then
				if NPC.HasModifier(enemy, "modifier_invoker_tornado") then
					if not NPC.IsEntityInRange(myHero, enemy, NPC.GetAttackRange(myHero)) then
						FAIO.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(NPC.GetAttackRange(myHero) - 25), myHero)
					end
				else
					Ability.CastTarget(coldSnap, enemy)
					FAIO.lastTick = os.clock()
					return
				end
			end
		end
	end

	if Menu.IsEnabled(FAIO.optionHeroInvokerSwitch) then
		if not Ability.IsReady(tornado) and not Ability.IsReady(emp) and (not Ability.IsReady(coldSnap) or not Ability.IsReady(iceWall)) then
			FAIO.InvokerComboSelector = 11
		end
	end

	FAIO.invokerProcessInstancesWhileComboing(myHero)
	if not NPC.HasModifier(enemy, "modifier_invoker_tornado") then
		FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	end
	return

end

function FAIO.InvokerComboTornadoMeteorBlast(myHero, myMana, enemy, tornado, chaosMeteor, deafeningBlast, blink, invoke)

	if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) < 0.25 then return end
	if NPC.HasModifier(myHero, "modifier_invoker_ghost_walk_self") then return end

	if Menu.IsEnabled(FAIO.optionHeroInvokerTornadoItems) then
		FAIO.itemUsage(myHero, enemy)
	else
		if not Ability.IsReady(tornado) then
			FAIO.itemUsage(myHero, enemy)
		end
	end	

	if FAIO.InvokerInvokedChecker(myHero, Ability.GetName(chaosMeteor), Ability.GetName(tornado)) and invoke and Ability.IsReady(invoke) then
	FAIO.InvokerCanComboStart = true
		if not NPC.IsEntityInRange(myHero, enemy, 950) then
			if blink and Ability.IsReady(blink) then
				if NPC.IsEntityInRange(myHero, enemy, 1150 + NPC.GetAttackRange(myHero)) then
					FAIO.noItemCastFor(0.5)
					Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(600))
					return
				else
					if FAIO.SleepReady(0.1) then
						Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION, target, Entity.GetAbsOrigin(enemy), ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_HERO_ONLY, npc, queue, showEffects)
						FAIO.lastTick = os.clock()
						FAIO.noItemCastFor(0.5)
						return
					end
				end
			end
			if not blink or (blink and not Ability.IsReady(blink)) and not NPC.HasModifier(enemy, "modifier_invoker_tornado") then
				FAIO.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil, myHero)
				FAIO.noItemCastFor(0.5)
				return
			end
		else
			local travelTime = (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000
			local tornadoTiming = FAIO.invokerTornadoLiftDuration[Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0))] * (1 - (math.ceil(Hero.GetStrengthTotal(enemy) * 0.15)/100)) + travelTime
			if tornadoTiming < 1.3 then
				if FAIO.SleepReady(0.05) and chaosMeteor and Ability.IsCastable(chaosMeteor, myMana) then
					Ability.CastPosition(chaosMeteor, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(250))
					FAIO.lastTick = os.clock()
					FAIO.lastCastTime = os.clock()
					return
				end
				if not Ability.IsReady(chaosMeteor) then
					if FAIO.SleepReady(0.05) and tornado and Ability.IsCastable(tornado, myMana) then
						if os.clock() - FAIO.lastCastTime <= 1.3 - tornadoTiming then
							FAIO.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil, myHero)
							return
						else	
							if Menu.GetValue(FAIO.optionHeroInvokerSkillshotStyle) == 0 then
								local tornadoPrediction = Ability.GetCastPoint(tornado) + (Entity.GetAbsOrigin(enemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1000) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
								Ability.CastPosition(tornado, FAIO.castLinearPrediction(myHero, enemy, tornadoPrediction))
								FAIO.lastTick = os.clock()
								return
							else
								Ability.CastPosition(tornado, Input.GetWorldCursorPos())
								FAIO.lastTick = os.clock()
								return
							end
						end
					end
				end
				if NPC.HasModifier(enemy, "modifier_invoker_tornado") then
					if FAIO.SleepReady(0.05) and not Ability.IsReady(tornado) and invoke and Ability.IsCastable(invoke, myMana) and FAIO.InvokerIsSkillInvokable(myHero, deafeningBlast) then
						FAIO.invokerInvokeAbility(myHero, deafeningBlast)
						FAIO.lastTick = os.clock()
						return
					end
				end
			else
				if FAIO.SleepReady(0.05) and tornado and Ability.IsCastable(tornado, myMana) then
					if Menu.GetValue(FAIO.optionHeroInvokerSkillshotStyle) == 0 then
						local tornadoPrediction = Ability.GetCastPoint(tornado) + (Entity.GetAbsOrigin(enemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1000) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
						Ability.CastPosition(tornado, FAIO.castLinearPrediction(myHero, enemy, tornadoPrediction))
						FAIO.lastTick = os.clock()
						FAIO.noItemCastFor((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000 + 0.5)
						return
					else
						Ability.CastPosition(tornado, Input.GetWorldCursorPos())
						FAIO.lastTick = os.clock()
						FAIO.noItemCastFor((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000 + 0.5)
						return
					end
				end
				if NPC.HasModifier(enemy, "modifier_invoker_tornado") then
					if FAIO.SleepReady(0.05) and not Ability.IsReady(tornado) and invoke and Ability.IsCastable(invoke, myMana) and FAIO.InvokerIsSkillInvokable(myHero, deafeningBlast) then
						FAIO.invokerInvokeAbility(myHero, deafeningBlast)
						FAIO.lastTick = os.clock()
						return
					end
				end
			end
		end
	else
		if Menu.IsEnabled(FAIO.optionHeroInvokerForceDynamic) then
			if not FAIO.InvokerCanComboStart then
				FAIO.InvokerComboDynamicMode(myHero, myMana, enemy, blink, invoke)
				return
			end
		end
	end

	if not Ability.IsReady(tornado) then
		if Ability.IsReady(chaosMeteor) and NPC.HasModifier(enemy, "modifier_invoker_tornado") then
			local distance = (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() - NPC.GetAttackRange(myHero)
				if distance < 0 then
					distance = 0
				end
			local timeToPosition = distance / NPC.GetMoveSpeed(myHero)
			if GameRules.GetGameTime() + timeToPosition < Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_tornado")) - 1.3 then
				if not NPC.IsEntityInRange(myHero, enemy, NPC.GetAttackRange(myHero)) then
					FAIO.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(NPC.GetAttackRange(myHero)), myHero)	
				else
					if GameRules.GetGameTime() >= Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_tornado")) - 1.3 then
						if FAIO.SleepReady(0.05) and chaosMeteor and Ability.IsCastable(chaosMeteor, myMana) then
							Ability.CastPosition(chaosMeteor, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(100))
							FAIO.lastTick = os.clock()
							return
						end
					end
				end
			else
				if not NPC.IsEntityInRange(myHero, enemy, 950) then
					FAIO.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(950), myHero)	
				else
					if GameRules.GetGameTime() >= Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_tornado")) - 1.3 then
						if FAIO.SleepReady(0.05) and chaosMeteor and Ability.IsCastable(chaosMeteor, myMana) then
							Ability.CastPosition(chaosMeteor, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(100))
							FAIO.lastTick = os.clock()
							return
						end
					end
				end
			end
		else
			if FAIO.SleepReady(0.05) and deafeningBlast and Ability.IsCastable(deafeningBlast, myMana) and FAIO.InvokerIsAbilityInvoked(myHero, deafeningBlast) then
				if NPC.HasModifier(enemy, "modifier_invoker_tornado") then
					local blastTime = ((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1100) - 0.25
					if GameRules.GetGameTime() >= Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_tornado")) - blastTime - NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) then
						Ability.CastPosition(deafeningBlast, Entity.GetAbsOrigin(enemy))
						FAIO.lastTick = os.clock()
						return
					end
				else
					Ability.CastPosition(deafeningBlast, Entity.GetAbsOrigin(enemy))
					FAIO.lastTick = os.clock()
					return
				end
			end
		end
	end

	if Menu.IsEnabled(FAIO.optionHeroInvokerSwitch) then
		if not Ability.IsReady(tornado) and not Ability.IsReady(chaosMeteor) and not Ability.IsReady(deafeningBlast) then
			FAIO.InvokerComboSelector = 11
		end
	end

	FAIO.invokerProcessInstancesWhileComboing(myHero)
	if not NPC.HasModifier(enemy, "modifier_invoker_tornado") then
		FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	end
	return

end

function FAIO.InvokerComboEulsSunstrikeMeteorBlast(myHero, myMana, enemy, sunStrike, chaosMeteor, deafeningBlast, blink, euls, invoke)

	if not euls then
		if Menu.IsEnabled(FAIO.optionHeroInvokerForceDynamic) then
			FAIO.InvokerComboDynamicMode(myHero, myMana, enemy, blink, invoke)
			return
		end
	end

	if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) < 0.25 then return end
	if NPC.HasModifier(myHero, "modifier_invoker_ghost_walk_self") then return end

	if FAIO.InvokerInvokedChecker(myHero, Ability.GetName(chaosMeteor), Ability.GetName(sunStrike)) and invoke and Ability.IsReady(invoke) then
	FAIO.InvokerCanComboStart = true
		if not NPC.IsEntityInRange(myHero, enemy, 550) then
			if blink and Ability.IsReady(blink) then
				if NPC.IsEntityInRange(myHero, enemy, 1150 + NPC.GetAttackRange(myHero)) then
					FAIO.noItemCastFor(0.5)
					Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(500))
					return
				else
					if FAIO.SleepReady(0.1) then
						Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION, target, Entity.GetAbsOrigin(enemy), ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_HERO_ONLY, npc, queue, showEffects)
						FAIO.lastTick = os.clock()
						FAIO.noItemCastFor(0.5)
						return
					end
				end
			end
			if not blink or (blink and not Ability.IsReady(blink)) and not NPC.HasModifier(enemy, "modifier_eul_cyclone") then
				FAIO.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Entity.GetAbsOrigin(enemy), myHero)
				FAIO.noItemCastFor(0.5)
				return
			end
		else
			if FAIO.SleepReady(0.05) and euls and Ability.IsCastable(euls, myMana) then
				Ability.CastTarget(euls, enemy)
				FAIO.lastTick = os.clock()
				FAIO.noItemCastFor(2.5)
				return
			else
				if Menu.IsEnabled(FAIO.optionHeroInvokerForceDynamic) then
					FAIO.InvokerComboDynamicMode(myHero, myMana, enemy, blink, invoke)
					return
				end
			end
			if NPC.HasModifier(enemy, "modifier_eul_cyclone") then
				if GameRules.GetGameTime() >= Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_eul_cyclone")) - 1.7 then
					if FAIO.SleepReady(0.05) and sunStrike and Ability.IsCastable(sunStrike, myMana) then
						Ability.CastPosition(sunStrike, Entity.GetAbsOrigin(enemy))
						FAIO.lastTick = os.clock()
						return
					end
				end
			end
			if FAIO.SleepReady(0.05) and not Ability.IsReady(sunStrike) and invoke and Ability.IsCastable(invoke, myMana) and not FAIO.InvokerIsAbilityInvoked(myHero, deafeningBlast) and FAIO.InvokerIsSkillInvokable(myHero, deafeningBlast) then
				FAIO.invokerInvokeAbility(myHero, deafeningBlast)
				FAIO.lastTick = os.clock()
				return
			end
		end
	else
		if Menu.IsEnabled(FAIO.optionHeroInvokerForceDynamic) then
			if not FAIO.InvokerCanComboStart then
				FAIO.InvokerComboDynamicMode(myHero, myMana, enemy, blink, invoke)
				return
			end
		end
	end

	if FAIO.InvokerIsAbilityInvoked(myHero, deafeningBlast) and not Ability.IsReady(sunStrike) then
		if NPC.HasModifier(enemy, "modifier_eul_cyclone") then
			if GameRules.GetGameTime() >= Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_eul_cyclone")) - 1.3 then
				if FAIO.SleepReady(0.05) and chaosMeteor and Ability.IsCastable(chaosMeteor, myMana) then
					Ability.CastPosition(chaosMeteor, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(100))
					FAIO.lastTick = os.clock()
					return
				end
			end
			local blastTime = ((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1100) - 0.25
			if not Ability.IsReady(chaosMeteor) then
				if GameRules.GetGameTime() >= Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_eul_cyclone")) - blastTime - NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) then
					Ability.CastPosition(deafeningBlast, Entity.GetAbsOrigin(enemy))
					FAIO.lastTick = os.clock()
					return
				end
			end
		end
	end

	FAIO.itemUsage(myHero, enemy)

	if Menu.IsEnabled(FAIO.optionHeroInvokerSwitch) then
		if not Ability.IsReady(sunStrike) and not Ability.IsReady(chaosMeteor) and not Ability.IsReady(deafeningBlast) then
			FAIO.InvokerComboSelector = 11
		end
	end

	FAIO.invokerProcessInstancesWhileComboing(myHero)
	if not NPC.HasModifier(enemy, "modifier_eul_cyclone") then
		FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	end
	return

end


function FAIO.InvokerComboAghaTornadoEmpMeteorBlast(myHero, myMana, enemy, tornado, emp, chaosMeteor, deafeningBlast, aghanims, blink, invoke)

	if not aghanims and not NPC.HasModifier(myHero, "modifier_item_ultimate_scepter_consumed") then
		if Menu.IsEnabled(FAIO.optionHeroInvokerForceDynamic) then
			FAIO.InvokerComboDynamicMode(myHero, myMana, enemy, blink, invoke)
			return
		end
	end

	if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) < 0.25 then return end
	if NPC.HasModifier(myHero, "modifier_invoker_ghost_walk_self") then return end

	if Menu.IsEnabled(FAIO.optionHeroInvokerTornadoItems) then
		FAIO.itemUsage(myHero, enemy)
	else
		if not Ability.IsReady(tornado) then
			FAIO.itemUsage(myHero, enemy)
		end
	end

	if FAIO.InvokerInvokedChecker(myHero, Ability.GetName(emp), Ability.GetName(tornado)) and invoke and Ability.IsReady(invoke) then
	FAIO.InvokerCanComboStart = true
		if not NPC.IsEntityInRange(myHero, enemy, 1000) then
			if blink and Ability.IsReady(blink) then
				if NPC.IsEntityInRange(myHero, enemy, 1150 + NPC.GetAttackRange(myHero)) then
					FAIO.noItemCastFor(0.5)
					Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(600))
					return
				else
					if FAIO.SleepReady(0.1) then
						Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION, target, Entity.GetAbsOrigin(enemy), ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_HERO_ONLY, npc, queue, showEffects)
						FAIO.lastTick = os.clock()
						FAIO.noItemCastFor(0.5)
						return
					end
				end
			end
			if not blink or (blink and not Ability.IsReady(blink)) and not NPC.HasModifier(enemy, "modifier_invoker_tornado") then
				FAIO.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil, myHero)
				FAIO.noItemCastFor(0.5)
				return
			end
		else
			if FAIO.SleepReady(0.05) and tornado and Ability.IsCastable(tornado, myMana) then
				if Menu.GetValue(FAIO.optionHeroInvokerSkillshotStyle) == 0 then
					local tornadoPrediction = Ability.GetCastPoint(tornado) + (Entity.GetAbsOrigin(enemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1000) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
					Ability.CastPosition(tornado, FAIO.castLinearPrediction(myHero, enemy, tornadoPrediction))
					FAIO.lastTick = os.clock()
					FAIO.lastCastTime = os.clock()
					FAIO.noItemCastFor((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000 + 0.5)
					return
				else
					Ability.CastPosition(tornado, Input.GetWorldCursorPos())
					FAIO.lastTick = os.clock()
					FAIO.lastCastTime = os.clock()
					FAIO.noItemCastFor((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000 + 0.5)
					return
				end
			end
			if not Ability.IsReady(tornado) then
				if FAIO.SleepReady(0.05) and invoke and Ability.IsCastable(invoke, myMana) and FAIO.InvokerIsSkillInvokable(myHero, chaosMeteor) then
					FAIO.invokerInvokeAbility(myHero, chaosMeteor)
					FAIO.lastTick = os.clock()
					return
				end
			end	
		end
	else
		if Menu.IsEnabled(FAIO.optionHeroInvokerForceDynamic) then
			if not FAIO.InvokerCanComboStart then
				FAIO.InvokerComboDynamicMode(myHero, myMana, enemy, blink, invoke)
				return
			end
		end
	end

	if not Ability.IsReady(tornado) and FAIO.InvokerInvokedChecker(myHero, Ability.GetName(chaosMeteor), Ability.GetName(emp)) then
		if FAIO.SleepReady(0.05) and emp and Ability.IsCastable(emp, myMana) then
			local travelTime = (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000
			local tornadoTiming = FAIO.invokerTornadoLiftDuration[Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0))] * (1 - (math.ceil(Hero.GetStrengthTotal(enemy) * 0.15)/100)) + travelTime
			if os.clock() - FAIO.lastCastTime > tornadoTiming - 2.9 + 0.25 then
				if NPC.IsEntityInRange(myHero, enemy, 925) then
					Ability.CastPosition(emp, Entity.GetAbsOrigin(enemy))
					FAIO.lastTick = os.clock()
					return
				else
					Ability.CastPosition(emp, Entity.GetAbsOrigin(myHero) + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(925))
					FAIO.lastTick = os.clock()
					return
				end
			end
		end
		if NPC.HasModifier(enemy, "modifier_invoker_tornado") then
			if FAIO.SleepReady(0.05) and chaosMeteor and Ability.IsCastable(chaosMeteor, myMana) then
				local distance = (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() - NPC.GetAttackRange(myHero)
					if distance < 0 then
						distance = 0
					end
				local timeToPosition = distance / NPC.GetMoveSpeed(myHero)
				if GameRules.GetGameTime() + timeToPosition < Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_tornado")) - 1.3 then
					if not NPC.IsEntityInRange(myHero, enemy, NPC.GetAttackRange(myHero)) then
						FAIO.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(NPC.GetAttackRange(myHero)), myHero)	
					else
						if GameRules.GetGameTime() >= Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_tornado")) - 1.3 then
							if FAIO.SleepReady(0.05) and chaosMeteor and Ability.IsCastable(chaosMeteor, myMana) then
								Ability.CastPosition(chaosMeteor, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(100))
								FAIO.lastTick = os.clock()
								return
							end
						end
					end
				else
					if not NPC.IsEntityInRange(myHero, enemy, 950) then
						FAIO.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(950), myHero)	
					else
						if GameRules.GetGameTime() >= Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_tornado")) - 1.3 then
							if FAIO.SleepReady(0.05) and chaosMeteor and Ability.IsCastable(chaosMeteor, myMana) then
								Ability.CastPosition(chaosMeteor, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(100))
								FAIO.lastTick = os.clock()
								return
							end
						end
					end
				end
			end
		end			
	end
	if not Ability.IsReady(chaosMeteor) then
		if FAIO.SleepReady(0.05) and invoke and Ability.IsCastable(invoke, myMana) and not FAIO.InvokerIsAbilityInvoked(myHero, deafeningBlast) and FAIO.InvokerIsSkillInvokable(myHero, deafeningBlast) then
			FAIO.invokerInvokeAbility(myHero, deafeningBlast)
			FAIO.lastTick = os.clock()
			return
		end
		if FAIO.SleepReady(0.05) and deafeningBlast and Ability.IsCastable(deafeningBlast, myMana) and FAIO.InvokerIsAbilityInvoked(myHero, deafeningBlast) then
			if NPC.HasModifier(enemy, "modifier_invoker_tornado") then
				local blastTime = ((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1100) - 0.25
				if GameRules.GetGameTime() >= Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_tornado")) - blastTime - NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) then
					Ability.CastPosition(deafeningBlast, Entity.GetAbsOrigin(enemy))
					FAIO.lastTick = os.clock()
					return
				end
			else
				Ability.CastPosition(deafeningBlast, Entity.GetAbsOrigin(enemy))
				FAIO.lastTick = os.clock()
				return
			end
		end
	end

	if Menu.IsEnabled(FAIO.optionHeroInvokerSwitch) then
		if not Ability.IsReady(tornado) and not Ability.IsReady(emp) and not Ability.IsReady(chaosMeteor) and not Ability.IsReady(deafeningBlast) then
			FAIO.InvokerComboSelector = 11
		end
	end

	FAIO.invokerProcessInstancesWhileComboing(myHero)
	if not NPC.HasModifier(enemy, "modifier_invoker_tornado") then
		FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	end
	return

	
end

function FAIO.InvokerComboAghaTornadoSunstrikeMeteorBlast(myHero, myMana, enemy, tornado, sunStrike, chaosMeteor, deafeningBlast, aghanims, blink, invoke)

	if not aghanims and not NPC.HasModifier(myHero, "modifier_item_ultimate_scepter_consumed") then
		if Menu.IsEnabled(FAIO.optionHeroInvokerForceDynamic) then
			FAIO.InvokerComboDynamicMode(myHero, myMana, enemy, blink, invoke)
			return
		end
	end

	if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) < 0.25 then return end
	if NPC.HasModifier(myHero, "modifier_invoker_ghost_walk_self") then return end

	if Menu.IsEnabled(FAIO.optionHeroInvokerTornadoItems) then
		FAIO.itemUsage(myHero, enemy)
	else
		if not Ability.IsReady(tornado) then
			FAIO.itemUsage(myHero, enemy)
		end
	end

	if FAIO.InvokerInvokedChecker(myHero, Ability.GetName(sunStrike), Ability.GetName(tornado)) and invoke and Ability.IsReady(invoke) then
	FAIO.InvokerCanComboStart = true
		if not NPC.IsEntityInRange(myHero, enemy, 1000) then
			if blink and Ability.IsReady(blink) then
				if NPC.IsEntityInRange(myHero, enemy, 1150 + NPC.GetAttackRange(myHero)) then
					FAIO.noItemCastFor(0.5)
					Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(600))
					return
				else
					if FAIO.SleepReady(0.1) then
						Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION, target, Entity.GetAbsOrigin(enemy), ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_HERO_ONLY, npc, queue, showEffects)
						FAIO.lastTick = os.clock()
						FAIO.noItemCastFor(0.5)
						return
					end
				end
			end
			if not blink or (blink and not Ability.IsReady(blink)) and not NPC.HasModifier(enemy, "modifier_invoker_tornado") then
				FAIO.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil, myHero)
				FAIO.noItemCastFor(0.5)
				return
			end
		else
			if FAIO.SleepReady(0.05) and tornado and Ability.IsCastable(tornado, myMana) then
				if Menu.GetValue(FAIO.optionHeroInvokerSkillshotStyle) == 0 then
					local tornadoPrediction = Ability.GetCastPoint(tornado) + (Entity.GetAbsOrigin(enemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1000) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
					Ability.CastPosition(tornado, FAIO.castLinearPrediction(myHero, enemy, tornadoPrediction))
					FAIO.lastTick = os.clock()
					FAIO.noItemCastFor((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000 + 0.5)
					return
				else
					Ability.CastPosition(tornado, Input.GetWorldCursorPos())
					FAIO.lastTick = os.clock()
					FAIO.noItemCastFor((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000 + 0.5)
					return
				end
			end
			if not Ability.IsReady(tornado) then
				if FAIO.SleepReady(0.05) and invoke and Ability.IsCastable(invoke, myMana) and FAIO.InvokerIsSkillInvokable(myHero, chaosMeteor) then
					FAIO.invokerInvokeAbility(myHero, chaosMeteor)
					FAIO.lastTick = os.clock()
					return
				end
			end
		end
	else
		if Menu.IsEnabled(FAIO.optionHeroInvokerForceDynamic) then
			if not FAIO.InvokerCanComboStart then
				FAIO.InvokerComboDynamicMode(myHero, myMana, enemy, blink, invoke)
				return
			end
		end
	end
		
	if NPC.HasModifier(enemy, "modifier_invoker_tornado") and FAIO.InvokerInvokedChecker(myHero, Ability.GetName(chaosMeteor), Ability.GetName(sunStrike)) then
		if FAIO.SleepReady(0.05) and sunStrike and Ability.IsCastable(sunStrike, myMana) then
			local distance = (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() - NPC.GetAttackRange(myHero)
				if distance < 0 then
					distance = 0
				end
			local timeToPosition = distance / NPC.GetMoveSpeed(myHero)
			if GameRules.GetGameTime() + timeToPosition < Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_tornado")) - 1.7 then
				if not NPC.IsEntityInRange(myHero, enemy, NPC.GetAttackRange(myHero)) then
					FAIO.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(NPC.GetAttackRange(myHero)), myHero)	
				else
					if GameRules.GetGameTime() >= Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_tornado")) - 1.7 then
						if FAIO.SleepReady(0.05) and sunStrike and Ability.IsCastable(sunStrike, myMana) then
							Ability.CastPosition(sunStrike, Entity.GetAbsOrigin(enemy))
							FAIO.lastTick = os.clock()
							return
						end
					end
				end
			else
				if not NPC.IsEntityInRange(myHero, enemy, 950) then
					FAIO.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(950), myHero)	
				else
					if GameRules.GetGameTime() >= Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_tornado")) - 1.7 then
						if FAIO.SleepReady(0.05) and sunStrike and Ability.IsCastable(sunStrike, myMana) then
							Ability.CastPosition(sunStrike, Entity.GetAbsOrigin(enemy))
							FAIO.lastTick = os.clock()
							return
						end
					end
				end
			end
		end			
		
		if not Ability.IsReady(tornado) and not Ability.IsReady(sunStrike) then
			if NPC.HasModifier(enemy, "modifier_invoker_tornado") then
				if GameRules.GetGameTime() >= Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_tornado")) - 1.3 then
					if FAIO.SleepReady(0.05) and chaosMeteor and Ability.IsCastable(chaosMeteor, myMana) then
						Ability.CastPosition(chaosMeteor, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(250))
						FAIO.lastTick = os.clock()
						return
					end
				end
			end
		end
	end

	if not Ability.IsReady(chaosMeteor) then
		if FAIO.SleepReady(0.05) and invoke and Ability.IsCastable(invoke, myMana) and not FAIO.InvokerIsAbilityInvoked(myHero, deafeningBlast) and FAIO.InvokerIsSkillInvokable(myHero, deafeningBlast) then
			FAIO.invokerInvokeAbility(myHero, deafeningBlast)
			FAIO.lastTick = os.clock()
			return
		end
		if FAIO.SleepReady(0.05) and deafeningBlast and Ability.IsCastable(deafeningBlast, myMana) and FAIO.InvokerIsAbilityInvoked(myHero, deafeningBlast) then
			if NPC.HasModifier(enemy, "modifier_invoker_tornado") then
				local blastTime = ((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1100) - 0.25
				if GameRules.GetGameTime() >= Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_tornado")) - blastTime - NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) then
					Ability.CastPosition(deafeningBlast, Entity.GetAbsOrigin(enemy))
					FAIO.lastTick = os.clock()
					return
				end
			else
				Ability.CastPosition(deafeningBlast, Entity.GetAbsOrigin(enemy))
				FAIO.lastTick = os.clock()
				return
			end	
		end
	end

	if Menu.IsEnabled(FAIO.optionHeroInvokerSwitch) then
		if not Ability.IsReady(tornado) and not Ability.IsReady(sunStrike) and not Ability.IsReady(chaosMeteor) and not Ability.IsReady(deafeningBlast) then
			FAIO.InvokerComboSelector = 11
		end
	end

	FAIO.invokerProcessInstancesWhileComboing(myHero)
	if not NPC.HasModifier(enemy, "modifier_invoker_tornado") then
		FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	end
	return
		
end

function FAIO.InvokerComboRefresherAghaTornadoSunstrikeMeteorBlast(myHero, myMana, enemy, tornado, sunStrike, chaosMeteor, deafeningBlast, aghanims, refresher, blink, invoke)

	if not aghanims and not NPC.HasModifier(myHero, "modifier_item_ultimate_scepter_consumed") then
		if Menu.IsEnabled(FAIO.optionHeroInvokerForceDynamic) then
			FAIO.InvokerComboDynamicMode(myHero, myMana, enemy, blink, invoke)
			return
		end
	end

	if not refresher then
		if Menu.IsEnabled(FAIO.optionHeroInvokerForceDynamic) then
			FAIO.InvokerComboDynamicMode(myHero, myMana, enemy, blink, invoke)
			return
		end
	end

	if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) < 0.25 then return end
	if NPC.HasModifier(myHero, "modifier_invoker_ghost_walk_self") then return end

	if Menu.IsEnabled(FAIO.optionHeroInvokerTornadoItems) then
		FAIO.itemUsage(myHero, enemy)
	else
		if not Ability.IsReady(tornado) or not Ability.IsReady(refresher) then
			FAIO.itemUsage(myHero, enemy)
		end
	end

	if Ability.IsReady(refresher) then
		if FAIO.InvokerInvokedChecker(myHero, Ability.GetName(sunStrike), Ability.GetName(tornado)) and invoke and Ability.IsReady(invoke) then
		FAIO.InvokerCanComboStart = true
			if not NPC.IsEntityInRange(myHero, enemy, 1000) then
				if blink and Ability.IsReady(blink) then
					if NPC.IsEntityInRange(myHero, enemy, 1150 + NPC.GetAttackRange(myHero)) then
						FAIO.noItemCastFor(0.5)
						Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(600))
						return
					else
						if FAIO.SleepReady(0.1) then
							Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION, target, Entity.GetAbsOrigin(enemy), ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_HERO_ONLY, npc, queue, showEffects)
							FAIO.lastTick = os.clock()
							FAIO.noItemCastFor(0.5)
							return
						end
					end
				end
				if not blink or (blink and not Ability.IsReady(blink)) and not NPC.HasModifier(enemy, "modifier_invoker_tornado") then
					FAIO.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil, myHero)
					FAIO.noItemCastFor(0.5)
					return
				end
			else
				if FAIO.SleepReady(0.05) and tornado and Ability.IsCastable(tornado, myMana) then
					if Menu.GetValue(FAIO.optionHeroInvokerSkillshotStyle) == 0 then
						local tornadoPrediction = Ability.GetCastPoint(tornado) + (Entity.GetAbsOrigin(enemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1000) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
						Ability.CastPosition(tornado, FAIO.castLinearPrediction(myHero, enemy, tornadoPrediction))
						FAIO.lastTick = os.clock()
						FAIO.noItemCastFor((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000 + 0.5)
						return
					else
						Ability.CastPosition(tornado, Input.GetWorldCursorPos())
						FAIO.lastTick = os.clock()
						FAIO.noItemCastFor((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000 + 0.5)
						return
					end
				end
				if not Ability.IsReady(tornado) then
					if FAIO.SleepReady(0.05) and invoke and Ability.IsCastable(invoke, myMana) and FAIO.InvokerIsSkillInvokable(myHero, chaosMeteor) then
						FAIO.invokerInvokeAbility(myHero, chaosMeteor)
						FAIO.lastTick = os.clock()
						return
					end
				end
			end
		else
			if Menu.IsEnabled(FAIO.optionHeroInvokerForceDynamic) then
				if not FAIO.InvokerCanComboStart then
					FAIO.InvokerComboDynamicMode(myHero, myMana, enemy, blink, invoke)
					return
				end
			end
		end
		
		if NPC.HasModifier(enemy, "modifier_invoker_tornado") and FAIO.InvokerInvokedChecker(myHero, Ability.GetName(chaosMeteor), Ability.GetName(sunStrike)) then
			if FAIO.SleepReady(0.05) and sunStrike and Ability.IsCastable(sunStrike, myMana) then
				local distance = (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() - NPC.GetAttackRange(myHero)
					if distance < 0 then
						distance = 0
					end
				local timeToPosition = distance / NPC.GetMoveSpeed(myHero)
				if GameRules.GetGameTime() + timeToPosition < Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_tornado")) - 1.7 then
					if not NPC.IsEntityInRange(myHero, enemy, NPC.GetAttackRange(myHero)) then
						FAIO.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(NPC.GetAttackRange(myHero)), myHero)	
					else
						if GameRules.GetGameTime() >= Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_tornado")) - 1.7 then
							if FAIO.SleepReady(0.05) and sunStrike and Ability.IsCastable(sunStrike, myMana) then
								Ability.CastPosition(sunStrike, Entity.GetAbsOrigin(enemy))
								FAIO.lastTick = os.clock()
								return
							end
						end
					end
				else
					if not NPC.IsEntityInRange(myHero, enemy, 950) then
						FAIO.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(950), myHero)	
					else
						if GameRules.GetGameTime() >= Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_tornado")) - 1.7 then
							if FAIO.SleepReady(0.05) and sunStrike and Ability.IsCastable(sunStrike, myMana) then
								Ability.CastPosition(sunStrike, Entity.GetAbsOrigin(enemy))
								FAIO.lastTick = os.clock()
								return
							end
						end
					end
				end
			end			
		
			if not Ability.IsReady(tornado) and not Ability.IsReady(sunStrike) then
				if NPC.HasModifier(enemy, "modifier_invoker_tornado") then
					if GameRules.GetGameTime() >= Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_tornado")) - 1.3 then
						if FAIO.SleepReady(0.05) and chaosMeteor and Ability.IsCastable(chaosMeteor, myMana) then
							Ability.CastPosition(chaosMeteor, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(250))
							FAIO.lastTick = os.clock()
							return
						end
					end
				end
			end
		end
		

		if not Ability.IsReady(chaosMeteor) then
			if FAIO.SleepReady(0.05) and invoke and Ability.IsCastable(invoke, myMana) and not FAIO.InvokerIsAbilityInvoked(myHero, deafeningBlast) and FAIO.InvokerIsSkillInvokable(myHero, deafeningBlast) then
				FAIO.invokerInvokeAbility(myHero, deafeningBlast)
				FAIO.lastTick = os.clock()
				return
			end
			if FAIO.SleepReady(0.05) and deafeningBlast and Ability.IsCastable(deafeningBlast, myMana) and FAIO.InvokerIsAbilityInvoked(myHero, deafeningBlast) then
				if NPC.HasModifier(enemy, "modifier_invoker_tornado") then
					local blastTime = ((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1100) - 0.25
					if GameRules.GetGameTime() >= Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_tornado")) - blastTime - NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) then
						Ability.CastPosition(deafeningBlast, Entity.GetAbsOrigin(enemy))
						FAIO.lastTick = os.clock()
						return
					end
				else
					Ability.CastPosition(deafeningBlast, Entity.GetAbsOrigin(enemy))
					FAIO.lastTick = os.clock()
					return
				end	
			end
		end

		if not Ability.IsReady(tornado) and not Ability.IsReady(sunStrike) and not Ability.IsReady(chaosMeteor) and not Ability.IsReady(deafeningBlast) then
			if refresher and Ability.IsCastable(refresher, myMana) then
				Ability.CastNoTarget(refresher)
				FAIO.lastTick = os.clock()
				return
			end
		end
	else
		if Ability.SecondsSinceLastUse(refresher) > 3 then
			if Menu.IsEnabled(FAIO.optionHeroInvokerForceDynamic) then
				FAIO.InvokerComboDynamicMode(myHero, myMana, enemy, blink, invoke)
				return
			end
		end
	end

	if not Ability.IsReady(refresher) and Ability.SecondsSinceLastUse(refresher) > 0 and Ability.SecondsSinceLastUse(refresher) < 3 then
		if FAIO.SleepReady(0.05) and chaosMeteor and Ability.IsCastable(chaosMeteor, myMana) then
			Ability.CastPosition(chaosMeteor, Entity.GetAbsOrigin(enemy))
			FAIO.lastTick = os.clock()
			return
		end
		if not Ability.IsReady(chaosMeteor) and not FAIO.InvokerIsAbilityInvoked(myHero, sunStrike) then
			if FAIO.SleepReady(0.05) and invoke and Ability.IsCastable(invoke, myMana) and FAIO.InvokerIsSkillInvokable(myHero, sunStrike) then
				FAIO.invokerInvokeAbility(myHero, sunStrike)
				FAIO.lastTick = os.clock()
				return
			end
		end
		if FAIO.InvokerIsAbilityInvoked(myHero, sunStrike) then
			if FAIO.SleepReady(0.05) and sunStrike and Ability.IsCastable(sunStrike, myMana) then
					Ability.CastPosition(sunStrike, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(300))
					FAIO.lastTick = os.clock()
					return
			end
		end
		if not Ability.IsReady(sunStrike) then
			if FAIO.SleepReady(0.05) and deafeningBlast and Ability.IsCastable(deafeningBlast, myMana) and FAIO.InvokerIsAbilityInvoked(myHero, deafeningBlast) then
				Ability.CastPosition(deafeningBlast, Entity.GetAbsOrigin(enemy))
				FAIO.lastTick = os.clock()
				return
			end
		end
	end

	if Menu.IsEnabled(FAIO.optionHeroInvokerSwitch) then
		if not Ability.IsReady(refresher) and not Ability.IsReady(chaosMeteor) and not Ability.IsReady(sunStrike) and not Ability.IsReady(deafeningBlast) then
			FAIO.InvokerComboSelector = 11
		end
	end
	
	FAIO.invokerProcessInstancesWhileComboing(myHero)
	if not NPC.HasModifier(enemy, "modifier_invoker_tornado") then
		FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	end
	return		
end

function FAIO.InvokerComboRefresherAghaTornadoEmpMeteorBlast(myHero, myMana, enemy, tornado, emp, chaosMeteor, deafeningBlast, aghanims, refresher, blink, invoke)

	if not aghanims and not NPC.HasModifier(myHero, "modifier_item_ultimate_scepter_consumed") then
		if Menu.IsEnabled(FAIO.optionHeroInvokerForceDynamic) then
			FAIO.InvokerComboDynamicMode(myHero, myMana, enemy, blink, invoke)
			return
		end
	end

	if not refresher then
		if Menu.IsEnabled(FAIO.optionHeroInvokerForceDynamic) then
			FAIO.InvokerComboDynamicMode(myHero, myMana, enemy, blink, invoke)
			return
		end
	end

	if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) < 0.25 then return end
	if NPC.HasModifier(myHero, "modifier_invoker_ghost_walk_self") then return end

	if Menu.IsEnabled(FAIO.optionHeroInvokerTornadoItems) then
		FAIO.itemUsage(myHero, enemy)
	else
		if not Ability.IsReady(tornado) or not Ability.IsReady(refresher) then
			FAIO.itemUsage(myHero, enemy)
		end
	end

	if Ability.IsReady(refresher) then
		if FAIO.InvokerInvokedChecker(myHero, Ability.GetName(emp), Ability.GetName(tornado)) and invoke and Ability.IsReady(invoke) then
		FAIO.InvokerCanComboStart = true
			if not NPC.IsEntityInRange(myHero, enemy, 1000) then
				if blink and Ability.IsReady(blink) then
					if NPC.IsEntityInRange(myHero, enemy, 1150 + NPC.GetAttackRange(myHero)) then
						FAIO.noItemCastFor(0.5)
						Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(600))
						return
					else
						if FAIO.SleepReady(0.1) then
							Player.PrepareUnitOrders(Players.GetLocal(), Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION, target, Entity.GetAbsOrigin(enemy), ability, Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_HERO_ONLY, npc, queue, showEffects)
							FAIO.lastTick = os.clock()
							FAIO.noItemCastFor(0.5)
							return
						end
					end
				end
				if not blink or (blink and not Ability.IsReady(blink)) and not NPC.HasModifier(enemy, "modifier_invoker_tornado") then
					FAIO.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil, myHero)
					FAIO.noItemCastFor(0.5)
					return
				end
			else
				if FAIO.SleepReady(0.05) and tornado and Ability.IsCastable(tornado, myMana) then
					if Menu.GetValue(FAIO.optionHeroInvokerSkillshotStyle) == 0 then
						local tornadoPrediction = Ability.GetCastPoint(tornado) + (Entity.GetAbsOrigin(enemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1000) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
						Ability.CastPosition(tornado, FAIO.castLinearPrediction(myHero, enemy, tornadoPrediction))
						FAIO.lastTick = os.clock()
						FAIO.lastCastTime = os.clock()
						FAIO.noItemCastFor((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000 + 0.5)
						return
					else
						Ability.CastPosition(tornado, Input.GetWorldCursorPos())
						FAIO.lastTick = os.clock()
						FAIO.lastCastTime = os.clock()
						FAIO.noItemCastFor((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000 + 0.5)
						return
					end
				end
				if not Ability.IsReady(tornado) then
					if FAIO.SleepReady(0.05) and invoke and Ability.IsCastable(invoke, myMana) and FAIO.InvokerIsSkillInvokable(myHero, chaosMeteor) then
						FAIO.invokerInvokeAbility(myHero, chaosMeteor)
						FAIO.lastTick = os.clock()
						return
					end
				end	
			end
		else
			if Menu.IsEnabled(FAIO.optionHeroInvokerForceDynamic) then
				if not FAIO.InvokerCanComboStart then
					FAIO.InvokerComboDynamicMode(myHero, myMana, enemy, blink, invoke)
					return
				end
			end
		end

		if not Ability.IsReady(tornado) and FAIO.InvokerInvokedChecker(myHero, Ability.GetName(chaosMeteor), Ability.GetName(emp)) then
			if FAIO.SleepReady(0.05) and emp and Ability.IsCastable(emp, myMana) then
				local travelTime = (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000
				local tornadoTiming = FAIO.invokerTornadoLiftDuration[Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0))] * (1 - (math.ceil(Hero.GetStrengthTotal(enemy) * 0.15)/100)) + travelTime
				if os.clock() - FAIO.lastCastTime > tornadoTiming - 2.9 + 0.25 then
					if NPC.IsEntityInRange(myHero, enemy, 925) then
						Ability.CastPosition(emp, Entity.GetAbsOrigin(enemy))
						FAIO.lastTick = os.clock()
						return
					else
						Ability.CastPosition(emp, Entity.GetAbsOrigin(myHero) + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(925))
						FAIO.lastTick = os.clock()
						return
					end
				end
			end
			if NPC.HasModifier(enemy, "modifier_invoker_tornado") then
				if FAIO.SleepReady(0.05) and chaosMeteor and Ability.IsCastable(chaosMeteor, myMana) then
					local distance = (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() - NPC.GetAttackRange(myHero)
						if distance < 0 then
							distance = 0
						end
					local timeToPosition = distance / NPC.GetMoveSpeed(myHero)
					if GameRules.GetGameTime() + timeToPosition < Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_tornado")) - 1.3 then
						if not NPC.IsEntityInRange(myHero, enemy, NPC.GetAttackRange(myHero)) then
							FAIO.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(NPC.GetAttackRange(myHero)), myHero)	
						else
							if GameRules.GetGameTime() >= Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_tornado")) - 1.3 then
								if FAIO.SleepReady(0.05) and chaosMeteor and Ability.IsCastable(chaosMeteor, myMana) then
									Ability.CastPosition(chaosMeteor, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(100))
									FAIO.lastTick = os.clock()
									return
								end
							end
						end
					else
						if not NPC.IsEntityInRange(myHero, enemy, 950) then
							FAIO.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(950), myHero)	
						else
							if GameRules.GetGameTime() >= Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_tornado")) - 1.3 then
								if FAIO.SleepReady(0.05) and chaosMeteor and Ability.IsCastable(chaosMeteor, myMana) then
									Ability.CastPosition(chaosMeteor, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(100))
									FAIO.lastTick = os.clock()
									return
								end
							end
						end
					end
				end
			end			
		end		

		if not Ability.IsReady(chaosMeteor) then
			if FAIO.SleepReady(0.05) and invoke and Ability.IsCastable(invoke, myMana) and not FAIO.InvokerIsAbilityInvoked(myHero, deafeningBlast) and FAIO.InvokerIsSkillInvokable(myHero, deafeningBlast) then
				FAIO.invokerInvokeAbility(myHero, deafeningBlast)
				FAIO.lastTick = os.clock()
				return
			end
			if FAIO.SleepReady(0.05) and deafeningBlast and Ability.IsCastable(deafeningBlast, myMana) and FAIO.InvokerIsAbilityInvoked(myHero, deafeningBlast) then
				if NPC.HasModifier(enemy, "modifier_invoker_tornado") then
					local blastTime = ((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1100) - 0.25
					if GameRules.GetGameTime() >= Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_tornado")) - blastTime - NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) then
						Ability.CastPosition(deafeningBlast, Entity.GetAbsOrigin(enemy))
						FAIO.lastTick = os.clock()
						return
					end
				else
					Ability.CastPosition(deafeningBlast, Entity.GetAbsOrigin(enemy))
					FAIO.lastTick = os.clock()
					return
				end
			end
		end

		if not Ability.IsReady(tornado) and not Ability.IsReady(emp) and not Ability.IsReady(chaosMeteor) and not Ability.IsReady(deafeningBlast) then
			if refresher and Ability.IsCastable(refresher, myMana) then
				Ability.CastNoTarget(refresher)
				FAIO.lastTick = os.clock()
				return
			end
		end
	else
		if Ability.SecondsSinceLastUse(refresher) > 3 then
			if Menu.IsEnabled(FAIO.optionHeroInvokerForceDynamic) then
				FAIO.InvokerComboDynamicMode(myHero, myMana, enemy, blink, invoke)
				return
			end
		end
	end

	if not Ability.IsReady(refresher) and Ability.SecondsSinceLastUse(refresher) > 0 and Ability.SecondsSinceLastUse(refresher) < 3 then
		if FAIO.SleepReady(0.05) and chaosMeteor and Ability.IsCastable(chaosMeteor, myMana) then
			Ability.CastPosition(chaosMeteor, Entity.GetAbsOrigin(enemy))
			FAIO.lastTick = os.clock()
			return
		end
		if not Ability.IsReady(chaosMeteor) and not FAIO.InvokerIsAbilityInvoked(myHero, emp) then
			if FAIO.SleepReady(0.05) and invoke and Ability.IsCastable(invoke, myMana) and FAIO.InvokerIsSkillInvokable(myHero, emp) then
				FAIO.invokerInvokeAbility(myHero, emp)
				FAIO.lastTick = os.clock()
				return
			end
		end
		if FAIO.InvokerIsAbilityInvoked(myHero, emp) then
			if FAIO.SleepReady(0.05) and emp and Ability.IsCastable(emp, myMana) then
				if NPC.IsEntityInRange(myHero, enemy, 625) then
							Ability.CastPosition(emp, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(300))
							FAIO.lastTick = os.clock()
							return
						else
							Ability.CastPosition(emp, Entity.GetAbsOrigin(enemy))
							FAIO.lastTick = os.clock()
							return
						end
					Ability.CastPosition(emp, Entity.GetAbsOrigin(enemy))
					FAIO.lastTick = os.clock()
					return
			end
		end
		if not Ability.IsReady(emp) then
			if FAIO.SleepReady(0.05) and deafeningBlast and Ability.IsCastable(deafeningBlast, myMana) and FAIO.InvokerIsAbilityInvoked(myHero, deafeningBlast) then
				Ability.CastPosition(deafeningBlast, Entity.GetAbsOrigin(enemy))
				FAIO.lastTick = os.clock()
				return
			end
		end
	end

	if Menu.IsEnabled(FAIO.optionHeroInvokerSwitch) then
		if not Ability.IsReady(refresher) and not Ability.IsReady(chaosMeteor) and not Ability.IsReady(emp) and not Ability.IsReady(deafeningBlast) then
			FAIO.InvokerComboSelector = 11
		end
	end

	FAIO.invokerProcessInstancesWhileComboing(myHero)
	if not NPC.HasModifier(enemy, "modifier_invoker_tornado") then
		FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	end
	return		
end

function FAIO.InvokerComboRefresherAghaBlastMeteorSunstrike(myHero, myMana, enemy, deafeningBlast, chaosMeteor, sunStrike, blink, aghanims, refresher, invoke)

	if not aghanims and not NPC.HasModifier(myHero, "modifier_item_ultimate_scepter_consumed") then
		if Menu.IsEnabled(FAIO.optionHeroInvokerForceDynamic) then
			FAIO.InvokerComboDynamicMode(myHero, myMana, enemy, blink, invoke)
			return
		end
	end

	if not refresher then
		if Menu.IsEnabled(FAIO.optionHeroInvokerForceDynamic) then
			FAIO.InvokerComboDynamicMode(myHero, myMana, enemy, blink, invoke)
			return
		end
	end

	if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) < 0.25 then return end
	if NPC.HasModifier(myHero, "modifier_invoker_ghost_walk_self") then return end
	FAIO.itemUsage(myHero, enemy)

	if Ability.IsReady(refresher) then
		if FAIO.InvokerInvokedChecker(myHero, Ability.GetName(deafeningBlast), Ability.GetName(chaosMeteor)) and invoke and Ability.IsReady(invoke) then
		FAIO.InvokerCanComboStart = true
			if not NPC.IsEntityInRange(myHero, enemy, NPC.GetAttackRange(myHero)) then
				if blink and Ability.IsReady(blink) then
					if NPC.IsEntityInRange(myHero, enemy, 1150 + NPC.GetAttackRange(myHero)) then
						Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(NPC.GetAttackRange(myHero)-50))
						FAIO.lastTick = os.clock()
						return
					else
						FAIO.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, Entity.GetAbsOrigin(enemy), myHero)
						return
					end
				end
				if not blink or (blink and not Ability.IsReady(blink)) then
					FAIO.GenericAttackIssuer("Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil, myHero)
					return
				end
			else
				if FAIO.SleepReady(0.05) and deafeningBlast and Ability.IsCastable(deafeningBlast, myMana) then
					Ability.CastPosition(deafeningBlast, Entity.GetAbsOrigin(enemy))
					FAIO.lastTick = os.clock()
					return
				end

				if not Ability.IsReady(deafeningBlast) then
					if FAIO.SleepReady(0.05) and chaosMeteor and Ability.IsCastable(chaosMeteor, myMana) then
						Ability.CastPosition(chaosMeteor, Entity.GetAbsOrigin(enemy))
						FAIO.lastTick = os.clock()
						return
					end
				end

				if not Ability.IsReady(deafeningBlast) and not Ability.IsReady(chaosMeteor) and not FAIO.InvokerIsAbilityInvoked(myHero, sunStrike) then
					if FAIO.SleepReady(0.05) and invoke and Ability.IsCastable(invoke, myMana) and FAIO.InvokerIsSkillInvokable(myHero, sunStrike) then
						FAIO.invokerInvokeAbility(myHero, sunStrike)
						FAIO.lastTick = os.clock()
						return
					end
				end
			end
		else
			if Menu.IsEnabled(FAIO.optionHeroInvokerForceDynamic) then
				if not FAIO.InvokerCanComboStart then
					FAIO.InvokerComboDynamicMode(myHero, myMana, enemy, blink, invoke)
					return
				end
			end
		end
		
		if NPC.HasModifier(enemy, "modifier_invoker_deafening_blast_knockback") and FAIO.InvokerInvokedChecker(myHero, Ability.GetName(sunStrike), Ability.GetName(deafeningBlast)) then
			if FAIO.SleepReady(0.05) and sunStrike and Ability.IsCastable(sunStrike, myMana) then
				Ability.CastPosition(sunStrike, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(300))
				FAIO.lastTick = os.clock()
				return
			end
		end
	
		if not Ability.IsReady(deafeningBlast) and not Ability.IsReady(chaosMeteor) and not Ability.IsReady(sunStrike) then
			if refresher and Ability.IsCastable(refresher, myMana) then
				Ability.CastNoTarget(refresher)
				FAIO.lastTick = os.clock()
				return
			end
		end
	else
		if Ability.SecondsSinceLastUse(refresher) > 3 then
			if Menu.IsEnabled(FAIO.optionHeroInvokerForceDynamic) then
				FAIO.InvokerComboDynamicMode(myHero, myMana, enemy, blink, invoke)
				return
			end
		end
	end

	if not Ability.IsReady(refresher) and Ability.SecondsSinceLastUse(refresher) > 0 and Ability.SecondsSinceLastUse(refresher) < 3 then
		if FAIO.SleepReady(0.05) and deafeningBlast and Ability.IsCastable(deafeningBlast, myMana) then
			if NPC.HasModifier(enemy, "modifier_invoker_deafening_blast_knockback") then
				local blastTime = ((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1100) - 0.25
				if GameRules.GetGameTime() >= Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_deafening_blast_knockback")) - blastTime - NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) then
					Ability.CastPosition(deafeningBlast, Entity.GetAbsOrigin(enemy))
					FAIO.lastTick = os.clock()
					return
				end
			else
				Ability.CastPosition(deafeningBlast, Entity.GetAbsOrigin(enemy))
				FAIO.lastTick = os.clock()
				return
			end
		end
		if not Ability.IsReady(deafeningBlast) and not FAIO.InvokerIsAbilityInvoked(myHero, chaosMeteor) then
			if FAIO.SleepReady(0.05) and invoke and Ability.IsCastable(invoke, myMana) and FAIO.InvokerIsSkillInvokable(myHero, chaosMeteor) then
				FAIO.invokerInvokeAbility(myHero, chaosMeteor)
				FAIO.lastTick = os.clock()
				return
			end
		end
		if not Ability.IsReady(deafeningBlast) and FAIO.InvokerIsAbilityInvoked(myHero, chaosMeteor) then
			if FAIO.SleepReady(0.05) and sunStrike and Ability.IsCastable(sunStrike, myMana) then
				Ability.CastPosition(sunStrike, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(300))
				FAIO.lastTick = os.clock()
				return
			end
		end
		if not Ability.IsReady(deafeningBlast) and FAIO.InvokerIsAbilityInvoked(myHero, chaosMeteor) and not Ability.IsReady(sunStrike) then
			if FAIO.SleepReady(0.05) and chaosMeteor and Ability.IsCastable(chaosMeteor, myMana) then
				Ability.CastPosition(chaosMeteor, Entity.GetAbsOrigin(enemy))
				FAIO.lastTick = os.clock()
				return
			end
		end
	end

	if Menu.IsEnabled(FAIO.optionHeroInvokerSwitch) then
		if not Ability.IsReady(refresher) and not Ability.IsReady(chaosMeteor) and not Ability.IsReady(sunStrike) and not Ability.IsReady(deafeningBlast) then
			FAIO.InvokerComboSelector = 11
		end
	end

	FAIO.invokerProcessInstancesWhileComboing(myHero)
	FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	return

end

function FAIO.InvokerSkillProcessingTornado(myHero, myMana, enemy)

	if not enemy then return end

	local tornado = NPC.GetAbility(myHero, "invoker_tornado")
		if not tornado then return end

	local tornadoTravelTime = (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000
	local blastTravelTime = (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1100
	local tornadoLiftDuration = FAIO.invokerTornadoLiftDuration[Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0))] * (1 - (math.ceil(Hero.GetStrengthTotal(enemy) * 0.15)/100))
	local tornadoTiming = tornadoTravelTime + tornadoLiftDuration

	local curTime = GameRules.GetGameTime()

	local delay
	if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_emp")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_emp")) <= 2.9 then
		if tornadoTiming > 2.95 then
			delay = curTime - Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_emp")) + 2.95 - tornadoTravelTime
		else
			delay = FAIO.InvokerLastCastedSkillTime + 0.05
		end
	elseif Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_sun_strike")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_sun_strike")) <= 1.7 then
		if tornadoTiming > 1.75 then
			delay = curTime - Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_sun_strike")) + 1.75 - tornadoTravelTime + 0.1
		else
			delay = FAIO.InvokerLastCastedSkillTime + 0.05
		end
	elseif Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_chaos_meteor")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_chaos_meteor")) <= 1.3 + 2 then
		if tornadoTiming > 1.3 then
			delay = curTime - Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_chaos_meteor")) + 3.0 - tornadoTravelTime
		else
			delay = FAIO.InvokerLastCastedSkillTime + 0.05
		end
	elseif Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_deafening_blast")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_deafening_blast")) <= Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0)) * 0.25 + blastTravelTime then
		if tornadoTiming > Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0)) * 0.25 + blastTravelTime then
			delay = curTime - Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_deafening_blast")) + Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0)) * 0.25 + blastTravelTime - tornadoTravelTime
		else
			delay = FAIO.InvokerLastCastedSkillTime + 0.05
		end
	elseif NPC.HasModifier(enemy, "modifier_invoker_cold_snap") then
		delay = Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_cold_snap")) - 0.1 - tornadoTravelTime
	elseif  NPC.HasModifier(enemy, "modifier_sheepstick_debuff") then
		delay = Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_sheepstick_debuff")) - 0.1 - tornadoTravelTime
	elseif FAIO.TargetDisableTimer(myHero, enemy) > 0 then
		delay = FAIO.TargetDisableTimer(myHero, enemy) + 0.05 - tornadoTravelTime
	else
		delay = FAIO.InvokerLastCastedSkillTime + 0.05
	end
		

	return { delay, FAIO.castLinearPrediction(myHero, enemy, Ability.GetCastPoint(NPC.GetAbility(myHero, "invoker_tornado")) + (Entity.GetAbsOrigin(enemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1000) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)) }

end

function FAIO.InvokerSkillProcessingEMP(myHero, myMana, enemy)

	if not enemy then return end

	local emp = NPC.GetAbility(myHero, "invoker_emp")
		if not emp then return end

	local tornadoTravelTime = (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000
	local tornadoLiftDuration = FAIO.invokerTornadoLiftDuration[Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0))] * (1 - (math.ceil(Hero.GetStrengthTotal(enemy) * 0.15)/100))
	local tornadoTiming = tornadoTravelTime + tornadoLiftDuration

	local curTime = GameRules.GetGameTime()

	local delay
	if FAIO.InvokerLastCastedSkill == nil then
		delay = 0.05
	else
		if Ability.GetName(FAIO.InvokerLastCastedSkill) == "invoker_tornado" then
			if FAIO.InvokerLastCastedSkillTime + tornadoTiming > curTime + 2.9 then
				delay = FAIO.InvokerLastCastedSkillTime + tornadoTiming - 2.9
			else
				delay = FAIO.InvokerLastCastedSkillTime + 0.05
			end
		else
			delay = FAIO.InvokerLastCastedSkillTime + 0.05
		end
	end

	return { delay, Entity.GetAbsOrigin(enemy) }

end

function FAIO.InvokerSkillProcessingMeteor(myHero, myMana, enemy)

	if not enemy then return end

	local chaosMeteor = NPC.GetAbility(myHero, "invoker_chaos_meteor")
		if not chaosMeteor then return end

	local tornadoTravelTime = (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000
	local tornadoLiftDuration = FAIO.invokerTornadoLiftDuration[Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0))] * (1 - (math.ceil(Hero.GetStrengthTotal(enemy) * 0.15)/100))
	local tornadoTiming = tornadoTravelTime + tornadoLiftDuration

	local curTime = GameRules.GetGameTime()

	local delay
	if FAIO.InvokerLastCastedSkill == nil then
		if FAIO.TargetIsInvulnarable(myHero, enemy) > 0 then
			local timing = FAIO.TargetIsInvulnarable(myHero, enemy) - 1.25
			delay = timing
		else
			delay = 0.05
		end
	else
		if Ability.GetName(FAIO.InvokerLastCastedSkill) == "invoker_tornado" then
			if FAIO.InvokerLastCastedSkillTime + tornadoTiming > curTime + 1.3 then
				delay = FAIO.InvokerLastCastedSkillTime + tornadoTiming - 1.3
			else
				delay = FAIO.InvokerLastCastedSkillTime + 0.05
			end
		else
			if FAIO.TargetIsInvulnarable(myHero, enemy) > 0 then
				local timing = FAIO.TargetIsInvulnarable(myHero, enemy) - 1.25
				delay = timing
			elseif not NPC.HasModifier(enemy, "modifier_invoker_tornado") then
				if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_tornado")) > 0 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_tornado")) < ((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000 + FAIO.invokerTornadoLiftDuration[Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0))] * (1 - (math.ceil(Hero.GetStrengthTotal(enemy) * 0.15)/100)) + 0.5) then
					delay = curTime - Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_tornado")) + tornadoTiming - 1.3
				else
					delay = FAIO.InvokerLastCastedSkillTime + 0.05
				end
			elseif NPC.HasModifier(enemy, "modifier_invoker_tornado") then
				delay = Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_tornado")) - 1.3
			else
				delay = FAIO.InvokerLastCastedSkillTime + 0.05
			end
		end
	end

	local position = Vector()
	if NPC.HasModifier(enemy, "modifier_invoker_deafening_blast_knockback") or Ability.IsReady(NPC.GetAbility(myHero, "invoker_deafening_blast")) then
		position = Entity.GetAbsOrigin(enemy)
	elseif FAIO.InvokerLastCastedSkill ~= nil and Ability.GetName(FAIO.InvokerLastCastedSkill) == "invoker_deafening_blast" then
		position = Entity.GetAbsOrigin(enemy)
	elseif Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_deafening_blast")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_deafening_blast")) < ((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1100 + 0.25) then
		position = Entity.GetAbsOrigin(enemy)
	else
		position = (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(100))
	end

	return { delay, position }

end

function FAIO.InvokerSkillProcessingBlast(myHero, myMana, enemy)

	if not enemy then return end

	local deafeningBlast = NPC.GetAbility(myHero, "invoker_deafening_blast")
		if not deafeningBlast then return end

	local tornadoTravelTime = (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000
	local tornadoLiftDuration = FAIO.invokerTornadoLiftDuration[Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0))] * (1 - (math.ceil(Hero.GetStrengthTotal(enemy) * 0.15)/100))
	local tornadoTiming = tornadoTravelTime + tornadoLiftDuration
	
	local curTime = GameRules.GetGameTime()

	local delay
	if FAIO.InvokerLastCastedSkill == nil then
		if FAIO.TargetIsInvulnarable(myHero, enemy) > 0 then
			local timing = FAIO.TargetIsInvulnarable(myHero, enemy) - ((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1100) + 0.25
			delay = timing
		else
			delay = 0.05
		end
	else
		if Ability.GetName(FAIO.InvokerLastCastedSkill) == "invoker_tornado" then
			if FAIO.InvokerLastCastedSkillTime + tornadoTiming > curTime + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1100 - 0.25 then
				delay = FAIO.InvokerLastCastedSkillTime + tornadoTiming - ((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1100) + 0.25
			else
				delay = FAIO.InvokerLastCastedSkillTime + 0.05
			end
		else
			if FAIO.TargetIsInvulnarable(myHero, enemy) > 0 then
				local timing = FAIO.TargetIsInvulnarable(myHero, enemy) - ((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1100) + 0.25
				delay = timing
			elseif not NPC.HasModifier(enemy, "modifier_invoker_tornado") then
				if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_tornado")) > 0 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_tornado")) < ((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000 + FAIO.invokerTornadoLiftDuration[Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0))] * (1 - (math.ceil(Hero.GetStrengthTotal(enemy) * 0.15)/100)) + 0.5) then
					delay = curTime - Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_tornado")) + tornadoTiming - ((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1100) + 0.25
				else
					delay = FAIO.InvokerLastCastedSkillTime + 0.05
				end
			elseif NPC.HasModifier(enemy, "modifier_invoker_tornado") then
				delay = Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_tornado")) - ((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1100) + 0.25
			else
				delay = FAIO.InvokerLastCastedSkillTime + 0.05
			end
		end
	end

	return { delay, Entity.GetAbsOrigin(enemy) }

end

function FAIO.InvokerSkillProcessingSunstrike(myHero, myMana, enemy)

	if not enemy then return end

	local sunStrike = NPC.GetAbility(myHero, "invoker_sun_strike")
		if not sunStrike then return end

	local tornadoTravelTime = (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000
	local tornadoLiftDuration = FAIO.invokerTornadoLiftDuration[Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0))] * (1 - (math.ceil(Hero.GetStrengthTotal(enemy) * 0.15)/100))
	local tornadoTiming = tornadoTravelTime + tornadoLiftDuration

	local curTime = GameRules.GetGameTime()

	local delay
	if FAIO.InvokerLastCastedSkill == nil then
		if FAIO.invokerSunstrikeKSdisabledTargetProcess(myHero, enemy) ~= nil and FAIO.invokerSunstrikeKSdisabledTargetProcess(myHero, enemy)[1] > 0 then
			local timing = FAIO.invokerSunstrikeKSdisabledTargetProcess(myHero, enemy)[1]
			delay = timing
		elseif NPC.HasItem(myHero, "item_rod_of_atos", true) and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_rod_of_atos", true)) > -1 and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_rod_of_atos", true)) < ((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1500 + 0.25) then
			delay = curTime + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1500 + 0.25
		else
			delay = 0.05
		end
	else
		if Ability.GetName(FAIO.InvokerLastCastedSkill) == "invoker_tornado" then
			if FAIO.InvokerLastCastedSkillTime + tornadoTiming > curTime + 1.7 then
				delay = FAIO.InvokerLastCastedSkillTime + tornadoTiming - 1.7
			else
				delay = FAIO.InvokerLastCastedSkillTime + 0.05
			end
		elseif Ability.GetName(FAIO.InvokerLastCastedSkill) == "item_rod_of_atos" then
			delay = FAIO.InvokerLastCastedSkillTime + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1500
		elseif Ability.GetName(FAIO.InvokerLastCastedSkill) == "item_cyclone" then
			if Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_cyclone", true)) > -1 and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_cyclone", true)) < 2.55 then
				delay = curTime - Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_cyclone", true)) + 2.5 - 1.7
			else
				delay = FAIO.InvokerLastCastedSkillTime + 0.05
			end

		else
			if FAIO.invokerSunstrikeKSdisabledTargetProcess(myHero, enemy) ~= nil and FAIO.invokerSunstrikeKSdisabledTargetProcess(myHero, enemy)[1] > 0 then
				local timing = FAIO.invokerSunstrikeKSdisabledTargetProcess(myHero, enemy)[1]
				delay = timing
			elseif not NPC.HasModifier(enemy, "modifier_invoker_tornado") then
				if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_tornado")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_tornado")) < ((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000 + FAIO.invokerTornadoLiftDuration[Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0))] * (1 - (math.ceil(Hero.GetStrengthTotal(enemy) * 0.15)/100)) + 0.5) then
					delay = curTime - Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_tornado")) + tornadoTiming - 1.7
				else
					delay = FAIO.InvokerLastCastedSkillTime + 0.05
				end
			elseif NPC.HasModifier(enemy, "modifier_invoker_tornado") then
				delay = Modifier.GetDieTime(NPC.GetModifier(enemy, "modifier_invoker_tornado")) - 1.7
			else
				delay = FAIO.InvokerLastCastedSkillTime + 0.05
			end
		end
	end

	local position = Vector()
	if NPC.HasModifier(enemy, "modifier_invoker_deafening_blast_knockback") then
		position = (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(250))
--	elseif FAIO.InvokerLastCastedSkill ~= nil and Ability.GetName(FAIO.InvokerLastCastedSkill) == "invoker_deafening_blast" then
--		position = (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(300 - (curTime - FAIO.InvokerLastCastedSkillTime)*150))
	elseif Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_deafening_blast")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_deafening_blast")) < ((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1100 + 0.25) then
		position = (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(300))
	elseif NPC.HasModifier(enemy, "modifier_invoker_tornado") then
		position = Entity.GetAbsOrigin(enemy)
	else
		if FAIO.invokerSunstrikeKSdisabledTargetProcess(myHero, enemy) ~= nil and FAIO.invokerSunstrikeKSdisabledTargetProcess(myHero, enemy)[1] > 0 then
			position = Entity.GetAbsOrigin(enemy)
		else
			position = FAIO.castPrediction(myHero, enemy, Ability.GetCastPoint(NPC.GetAbility(myHero, "invoker_sun_strike")) + 1.7 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2))
		end
	end

	return { delay, position }

end

function FAIO.InvokerSkillProcessingIcewall(myHero, myMana, enemy)

	if not enemy then return end

	local iceWall = NPC.GetAbility(myHero, "invoker_ice_wall")
		if not iceWall then return end

	local tornadoTravelTime = (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000
	local tornadoLiftDuration = FAIO.invokerTornadoLiftDuration[Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0))] * (1 - (math.ceil(Hero.GetStrengthTotal(enemy) * 0.15)/100))
	local tornadoTiming = tornadoTravelTime + tornadoLiftDuration

	local curTime = GameRules.GetGameTime()

	local delay
	if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_tornado")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_tornado")) < ((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000 + FAIO.invokerTornadoLiftDuration[Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0))] * (1 - (math.ceil(Hero.GetStrengthTotal(enemy) * 0.15)/100)) + 0.1) then
		delay = curTime - Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_tornado")) + tornadoTiming - 0.5
	else
		delay = FAIO.InvokerLastCastedSkillTime + 0.05
	end

	return { delay, nil }

end

function FAIO.InvokerSkillProcessingEuls(myHero, myMana, enemy)

	if not enemy then return end

	local euls = NPC.GetItem(myHero, "item_cyclone", true)
		if not euls then return { 0.05, nil } end

	local tornadoTravelTime = (Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000
	local tornadoLiftDuration = FAIO.invokerTornadoLiftDuration[Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0))] * (1 - (math.ceil(Hero.GetStrengthTotal(enemy) * 0.15)/100))
	local tornadoTiming = tornadoTravelTime + tornadoLiftDuration

	local curTime = GameRules.GetGameTime()

	local delay
	if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_tornado")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_tornado")) < ((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000 + FAIO.invokerTornadoLiftDuration[Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0))] * (1 - (math.ceil(Hero.GetStrengthTotal(enemy) * 0.15)/100)) + 0.1) then
		delay = curTime - Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_tornado")) + tornadoTiming + 0.15
	elseif Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_emp")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_emp")) < 2.95 then
		delay = curTime - Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_emp")) + 2.95
	elseif Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_sun_strike")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_sun_strike")) < 1.8 then
		delay = curTime - Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_sun_strike")) + 1.8
	elseif Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_chaos_meteor")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_chaos_meteor")) < 2.5 then
		delay = curTime - Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_chaos_meteor")) + 2.5
	elseif Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_cold_snap")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_cold_snap")) < 4 then
		delay = curTime - Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_chaos_meteor")) + 4
	else
		delay = FAIO.InvokerLastCastedSkillTime + 0.05
	end

	return { delay, enemy }
	

end

function FAIO.InvokerComboCustomMode(myHero, myMana, enemy, blink, invoke)

	if not myHero then return end
	if not enemy then return end
	if not NPC.IsEntityInRange(myHero, enemy, 1500) then return end
	if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) < 0.25 then return end
	if NPC.HasModifier(myHero, "modifier_invoker_ghost_walk_self") then return end

	local skillTranslator = {
		"invoker_tornado",
		"invoker_emp",
		"invoker_chaos_meteor", 
		"invoker_deafening_blast",
		"invoker_sun_strike",
		"invoker_ice_wall",
		"invoker_cold_snap",
		"invoker_forge_spirit",
		"invoker_alacrity",
		"item_cyclone",
		"item_rod_of_atos",
		"item_refresher"
			}
		
	local skillOrder = {}
	if FAIO.InvokerComboSelector == 12 then
		if Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill1) > 0 then
			table.insert(skillOrder, skillTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill1)])
		end
		if Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill2) > 0 then
			table.insert(skillOrder, skillTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill2)])
		end
		if Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill3) > 0 then
			table.insert(skillOrder, skillTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill3)])
		end
		if Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill4) > 0 then
			table.insert(skillOrder, skillTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill4)])
		end
		if Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill5) > 0 then
			table.insert(skillOrder, skillTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill5)])
		end
		if Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill6) > 0 then
			table.insert(skillOrder, skillTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill6)])
		end
	elseif FAIO.InvokerComboSelector == 13 then
		if Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill1) > 0 then
			table.insert(skillOrder, skillTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill1)])
		end
		if Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill2) > 0 then
			table.insert(skillOrder, skillTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill2)])
		end
		if Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill3) > 0 then
			table.insert(skillOrder, skillTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill3)])
		end
		if Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill4) > 0 then
			table.insert(skillOrder, skillTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill4)])
		end
		if Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill5) > 0 then
			table.insert(skillOrder, skillTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill5)])
		end
		if Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill6) > 0 then
			table.insert(skillOrder, skillTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill6)])
		end
	elseif FAIO.InvokerComboSelector == 14 then
		if Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill1) > 0 then
			table.insert(skillOrder, skillTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill1)])
		end
		if Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill2) > 0 then
			table.insert(skillOrder, skillTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill2)])
		end
		if Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill3) > 0 then
			table.insert(skillOrder, skillTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill3)])
		end
		if Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill4) > 0 then
			table.insert(skillOrder, skillTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill4)])
		end
		if Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill5) > 0 then
			table.insert(skillOrder, skillTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill5)])
		end
		if Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill6) > 0 then
			table.insert(skillOrder, skillTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill6)])
		end
	end

	local skillProcessing = { 
		["invoker_tornado"] = { "position", FAIO.InvokerSkillProcessingTornado(myHero, myMana, enemy) }, 
		["invoker_emp"] = { "position", FAIO.InvokerSkillProcessingEMP(myHero, myMana, enemy) },
		["invoker_chaos_meteor"] = { "position", FAIO.InvokerSkillProcessingMeteor(myHero, myMana, enemy) },
		["invoker_deafening_blast"] = { "position", FAIO.InvokerSkillProcessingBlast(myHero, myMana, enemy) },
		["invoker_sun_strike"] = { "position", FAIO.InvokerSkillProcessingSunstrike(myHero, myMana, enemy) },
		["invoker_ice_wall"] = { "no target", FAIO.InvokerSkillProcessingIcewall(myHero, myMana, enemy) },
		["invoker_cold_snap"] = { "target", enemy },
		["invoker_forge_spirit"] = { "no target", nil },
		["invoker_alacrity"] = { "target", myHero },
		["item_cyclone"] = { "target", FAIO.InvokerSkillProcessingEuls(myHero, myMana, enemy) },
		["item_rod_of_atos"] = { "target", enemy },
		["item_refresher"] = { "no target", nil }
				}

	local readyTable = {}
	for i = 1, #skillOrder do
		if skillOrder[i] == "item_refresher" then
			if NPC.HasItem(myHero, skillOrder[i], true) then
				if Ability.IsReady(NPC.GetItem(myHero, skillOrder[i], true)) then
					table.insert(readyTable, NPC.GetItem(myHero, skillOrder[i], true))
				end
			else
				break	
			end
		elseif skillOrder[i] == "item_cyclone" then
			if NPC.HasItem(myHero, skillOrder[i], true) then
				if Ability.IsReady(NPC.GetItem(myHero, skillOrder[i], true)) then
					table.insert(readyTable, NPC.GetItem(myHero, skillOrder[i], true))
				end
			end
		elseif skillOrder[i] == "item_rod_of_atos" then
			if NPC.HasItem(myHero, skillOrder[i], true) then
				if Ability.IsReady(NPC.GetItem(myHero, skillOrder[i], true)) then
					table.insert(readyTable, NPC.GetItem(myHero, skillOrder[i], true))
				end
			end
		else
			if Ability.IsReady(NPC.GetAbility(myHero, skillOrder[i])) then
				table.insert(readyTable, NPC.GetAbility(myHero, skillOrder[i]))
			end
		end
	end

	if NPC.HasItem(myHero, "item_refresher", true) then
		if Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_refresher", true)) > -1 and Ability.SecondsSinceLastUse(NPC.GetItem(myHero, "item_refresher", true)) < 7 then
			for a, b in ipairs(skillOrder) do
				if b == "item_refresher" then
					readyTable = {}
					for i = a+1, #skillOrder do
						if Ability.IsReady(NPC.GetAbilityByIndex(myHero, 4)) then
							table.insert(readyTable, NPC.GetAbilityByIndex(myHero, 4))
						end
						if Ability.IsReady(NPC.GetAbilityByIndex(myHero, 3)) then
							table.insert(readyTable, NPC.GetAbilityByIndex(myHero, 3))
						end
						if skillOrder[i] == "item_cyclone" then
							if NPC.HasItem(myHero, "item_cyclone", true) then
								if Ability.IsReady(NPC.GetItem(myHero, "item_cyclone", true)) then
									table.insert(readyTable, NPC.GetItem(myHero, "item_cyclone", true))
								end
							end
						else
							if Ability.IsReady(NPC.GetAbility(myHero, skillOrder[i])) then
								table.insert(readyTable, NPC.GetAbility(myHero, skillOrder[i]))
							end
						end
					end
				end
			end
		end
	end

	local skill
		if #readyTable > 0 then
			skill = readyTable[1]
		else
			skill = nil
		end

	local invokeSkill
		if not Ability.IsReady(NPC.GetAbilityByIndex(myHero, 4)) and Ability.IsReady(NPC.GetAbilityByIndex(myHero, 3)) then
			if #readyTable > 1 then
				invokeSkill = readyTable[2]
			else
				invokeSkill = nil
			end
		elseif not Ability.IsReady(NPC.GetAbilityByIndex(myHero, 4)) and not Ability.IsReady(NPC.GetAbilityByIndex(myHero, 3)) then
			if #readyTable > 0 then
				invokeSkill = readyTable[1]
			else
				invokeSkill = nil
			end
		end

	if invokeSkill then
		if not FAIO.InvokerIsAbilityInvoked(myHero, invokeSkill) then
			if GameRules.GetGameTime() - FAIO.lastCastTime3 > 0.05 and invoke and Ability.IsCastable(invoke, myMana) and FAIO.InvokerIsSkillInvokable(myHero, invokeSkill) then
				FAIO.invokerInvokeAbility(myHero, invokeSkill)
				FAIO.lastCastTime3 = GameRules.GetGameTime()
				return
			end
		end
	end

	local processingTempTable = {}
		if skill then
			if Ability.GetName(skill) == "invoker_tornado" or Ability.GetName(skill) == "invoker_emp" or Ability.GetName(skill) == "invoker_chaos_meteor" or Ability.GetName(skill) == "invoker_deafening_blast" or Ability.GetName(skill) == "invoker_sun_strike" or Ability.GetName(skill) == "invoker_ice_wall" then
				table.insert(processingTempTable, skillProcessing[Ability.GetName(skill)][2])
			elseif NPC.HasItem(myHero, "item_cyclone", true) and Ability.GetName(skill) == "item_cyclone" then
				table.insert(processingTempTable, skillProcessing[Ability.GetName(skill)][2])
			else
				processingTempTable = {}
			end
		end

	local targetingStyle
		if skill then
			targetingStyle = skillProcessing[Ability.GetName(skill)][1]
		end

	local targetingDelay
		if skill then
			if FAIO.InvokerLastCastedSkill == nil then
				targetingDelay = FAIO.InvokerLastCastedSkillTime + 0.05
			elseif Ability.GetName(skill) == "invoker_tornado" or Ability.GetName(skill) == "invoker_emp" or Ability.GetName(skill) == "invoker_chaos_meteor" or Ability.GetName(skill) == "invoker_deafening_blast" or Ability.GetName(skill) == "invoker_sun_strike" or Ability.GetName(skill) == "invoker_ice_wall" then
				targetingDelay = processingTempTable[1][1]
			elseif NPC.HasItem(myHero, "item_cyclone", true) and Ability.GetName(skill) == "item_cyclone" then
				targetingDelay = processingTempTable[1][1]
			else
				targetingDelay = FAIO.InvokerLastCastedSkillTime + 0.05
			end
		end

	local targetingTarget	
		if skill then
			if Ability.GetName(skill) == "invoker_tornado" or Ability.GetName(skill) == "invoker_emp" or Ability.GetName(skill) == "invoker_chaos_meteor" or Ability.GetName(skill) == "invoker_deafening_blast" or Ability.GetName(skill) == "invoker_sun_strike" then
				targetingTarget = processingTempTable[1][2]
			elseif NPC.HasItem(myHero, "item_cyclone", true) and Ability.GetName(skill) == "item_cyclone" then
				targetingTarget = processingTempTable[1][2]
			else
				targetingTarget = skillProcessing[Ability.GetName(skill)][2]
			end
		end

	if skill and Ability.GetName(skill) == "invoker_tornado" then
		if Menu.IsEnabled(FAIO.optionHeroInvokerTornadoItems) then
			FAIO.itemUsage(myHero, enemy)
		else
			if not Ability.IsReady(skill) then
				FAIO.itemUsage(myHero, enemy)
			end
		end
	else
		FAIO.itemUsage(myHero, enemy)
	end

	if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_INVULNERABLE) then
		FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
		FAIO.invokerForgedSpiritController(myHero, enemy)
	end

	if skill then
		if not NPC.IsEntityInRange(myHero, enemy, NPC.GetAttackRange(myHero)+200) then
			if blink and Ability.IsReady(blink) then
				if NPC.IsEntityInRange(myHero, enemy, 1150 + NPC.GetAttackRange(myHero)) then
					Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(NPC.GetAttackRange(myHero)-100))
					return
				end
			end
		else
			if FAIO.InvokerIsAbilityInvoked(myHero, skill) or Ability.GetName(skill) == "item_refresher" or Ability.GetName(skill) == "item_cyclone" or Ability.GetName(skill) == "item_rod_of_atos" then
			FAIO.InvokerCanComboStart = true
				if GameRules.GetGameTime() > targetingDelay then
					if Ability.IsCastable(skill, myMana) then
						if skillProcessing[Ability.GetName(skill)][1] == "position" then
							if Ability.GetName(skill) == "invoker_tornado" then
								Ability.CastPosition(skill, targetingTarget)
								FAIO.noItemCastFor(((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000) + 0.5)
								FAIO.InvokerLastCastedSkillTime = GameRules.GetGameTime()
								FAIO.InvokerLastCastedSkill = skill
								return
							else
								Ability.CastPosition(skill, targetingTarget)
								FAIO.InvokerLastCastedSkillTime = GameRules.GetGameTime()
								FAIO.InvokerLastCastedSkill = skill
								return
							end
						end
						if skillProcessing[Ability.GetName(skill)][1] == "target" then
							if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_INVULNERABLE) then
								Ability.CastTarget(skill, targetingTarget)
								FAIO.InvokerLastCastedSkillTime = GameRules.GetGameTime()
								FAIO.InvokerLastCastedSkill = skill
								return
							end
						end
						if skillProcessing[Ability.GetName(skill)][1] == "no target" then
							if Ability.GetName(skill) == "invoker_ice_wall" then
								if not NPC.IsEntityInRange(myHero, enemy, 600) then
									FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
									return
								else
									FAIO.InvokerIceWallHelper(myHero, enemy, skill, myMana)
									FAIO.InvokerLastCastedSkillTime = GameRules.GetGameTime() + 0.1
									FAIO.InvokerLastCastedSkill = skill
									return
								end
							else
								Ability.CastNoTarget(skill)
								FAIO.InvokerLastCastedSkillTime = GameRules.GetGameTime()
								FAIO.InvokerLastCastedSkill = skill
								return
							end			
						end
					end
				end
			else
				if Menu.IsEnabled(FAIO.optionHeroInvokerForceDynamic) then
					if not FAIO.InvokerCanComboStart then
						FAIO.InvokerComboDynamicMode(myHero, myMana, enemy, blink, invoke)
						return
					end
				end
			end
		end
	else
		if Menu.IsEnabled(FAIO.optionHeroInvokerForceDynamic) then
			FAIO.InvokerComboDynamicMode(myHero, myMana, enemy, blink, invoke)
			return
		end
	end

	if Menu.IsEnabled(FAIO.optionHeroInvokerSwitch) then
		if next(readyTable) == nil then
			FAIO.InvokerComboSelector = 11
		end
	end
	FAIO.invokerProcessInstancesWhileComboing(myHero)

		
end

function FAIO.InvokerComboDynamicMode(myHero, myMana, enemy, blink, invoke)

	if not myHero then return end
	if not enemy then return end
	if not NPC.IsEntityInRange(myHero, enemy, 1500) then return end
	if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) < 0.25 then return end
	if NPC.HasModifier(myHero, "modifier_invoker_ghost_walk_self") then return end

	local InvokerDynamicSpellsOrder = {}
	if Menu.GetValue(FAIO.optionHeroInvokerDynCS) > 0 then
		table.insert(InvokerDynamicSpellsOrder, { Menu.GetValue(FAIO.optionHeroInvokerDynCS), "invoker_cold_snap" })
	end
	if Menu.GetValue(FAIO.optionHeroInvokerDynFS) > 0 then
		table.insert(InvokerDynamicSpellsOrder, { Menu.GetValue(FAIO.optionHeroInvokerDynFS), "invoker_forge_spirit" })
	end
	if Menu.GetValue(FAIO.optionHeroInvokerDynAL) > 0 then
		table.insert(InvokerDynamicSpellsOrder, { Menu.GetValue(FAIO.optionHeroInvokerDynAL), "invoker_alacrity" })
	end
	if Menu.GetValue(FAIO.optionHeroInvokerDynIW) > 0 then
		table.insert(InvokerDynamicSpellsOrder, { Menu.GetValue(FAIO.optionHeroInvokerDynIW), "invoker_ice_wall" })
	end
	if Menu.GetValue(FAIO.optionHeroInvokerDynTO) > 0 then
		table.insert(InvokerDynamicSpellsOrder, { Menu.GetValue(FAIO.optionHeroInvokerDynTO), "invoker_tornado" })
	end
	if Menu.GetValue(FAIO.optionHeroInvokerDynEMP) > 0 then
		table.insert(InvokerDynamicSpellsOrder, { Menu.GetValue(FAIO.optionHeroInvokerDynEMP), "invoker_emp" })
	end
	if Menu.GetValue(FAIO.optionHeroInvokerDynSS) > 0 then
		table.insert(InvokerDynamicSpellsOrder, { Menu.GetValue(FAIO.optionHeroInvokerDynSS), "invoker_sun_strike" })
	end
	if Menu.GetValue(FAIO.optionHeroInvokerDynCM) > 0 then
		table.insert(InvokerDynamicSpellsOrder, { Menu.GetValue(FAIO.optionHeroInvokerDynCM), "invoker_chaos_meteor" })
	end
	if Menu.GetValue(FAIO.optionHeroInvokerDynDB) > 0 then
		table.insert(InvokerDynamicSpellsOrder, { Menu.GetValue(FAIO.optionHeroInvokerDynDB), "invoker_deafening_blast" })
	end

	table.sort(InvokerDynamicSpellsOrder, function(a, b)
        	return a[1] < b[1]
    	end)

	local skillPicker = {}
		if Menu.IsEnabled(FAIO.optionHeroInvokerDynOrder) then
			i = 1
			repeat
				table.insert(skillPicker, InvokerDynamicSpellsOrder[i][2])
				i = i + 1
			until i > #InvokerDynamicSpellsOrder
		else
			skillPicker[1] = "invoker_cold_snap"
			skillPicker[2] = "invoker_forge_spirit"
			skillPicker[3] = "invoker_alacrity" 
			skillPicker[4] = "invoker_ice_wall"
			skillPicker[5] = "invoker_tornado"
			skillPicker[6] = "invoker_emp"
			skillPicker[7] = "invoker_sun_strike"
			skillPicker[8] = "invoker_chaos_meteor" 
			skillPicker[9] = "invoker_deafening_blast"
		end

	

	local skillProcessing = { 
		["invoker_tornado"] = { "position", FAIO.InvokerSkillProcessingTornado(myHero, myMana, enemy) }, 
		["invoker_emp"] = { "position", FAIO.InvokerSkillProcessingEMP(myHero, myMana, enemy) },
		["invoker_chaos_meteor"] = { "position", FAIO.InvokerSkillProcessingMeteor(myHero, myMana, enemy) },
		["invoker_deafening_blast"] = { "position", FAIO.InvokerSkillProcessingBlast(myHero, myMana, enemy) },
		["invoker_sun_strike"] = { "position", FAIO.InvokerSkillProcessingSunstrike(myHero, myMana, enemy) },
		["invoker_ice_wall"] = { "no target", FAIO.InvokerSkillProcessingIcewall(myHero, myMana, enemy) },
		["invoker_cold_snap"] = { "target", enemy },
		["invoker_forge_spirit"] = { "no target", nil },
		["invoker_alacrity"] = { "target", myHero }
				}

	local readyTable = {}
	for i = 1, #skillPicker do
		if Ability.IsReady(NPC.GetAbility(myHero, skillPicker[i])) and not FAIO.InvokerIsAbilityInvoked(myHero, NPC.GetAbility(myHero, skillPicker[i])) and FAIO.InvokerIsSkillInvokable(myHero, NPC.GetAbility(myHero, skillPicker[i])) then
			table.insert(readyTable, NPC.GetAbility(myHero, skillPicker[i]))
		end
	end

	local skill
	local invokeSkill
	if Ability.IsReady(NPC.GetAbilityByIndex(myHero, 3)) and Ability.GetName(NPC.GetAbilityByIndex(myHero, 3)) == "invoker_tornado" and FAIO.TargetDisableTimer(myHero, enemy) == 0 then
		skill = NPC.GetAbilityByIndex(myHero, 3)	
	elseif Ability.IsReady(NPC.GetAbilityByIndex(myHero, 4)) and Ability.GetName(NPC.GetAbilityByIndex(myHero, 4)) == "invoker_ice_wall" then
		if NPC.IsEntityInRange(myHero, enemy, 800) then
			skill = NPC.GetAbilityByIndex(myHero, 4)
		else
			if Ability.IsReady(NPC.GetAbilityByIndex(myHero, 3)) then
				skill = NPC.GetAbilityByIndex(myHero, 3)
			else
				if next(readyTable) ~= nil then
					if #readyTable >= 1 then
						invokeSkill = readyTable[1]
					else
						skill = nil
						invokeSkill = nil
					end
				end
			end
		end
	elseif Ability.IsReady(NPC.GetAbilityByIndex(myHero, 4)) and Ability.GetName(NPC.GetAbilityByIndex(myHero, 4)) == "invoker_ghost_walk" then
		if Ability.IsReady(NPC.GetAbilityByIndex(myHero, 3)) then
			skill = NPC.GetAbilityByIndex(myHero, 3)
		else
			if next(readyTable) ~= nil then
				if #readyTable >= 1 then
					invokeSkill = readyTable[1]
				else
					skill = nil
					invokeSkill = nil
				end
			end
		end
	elseif Ability.IsReady(NPC.GetAbilityByIndex(myHero, 3)) and Ability.GetName(NPC.GetAbilityByIndex(myHero, 3)) == "invoker_ghost_walk" then
		if Ability.IsReady(NPC.GetAbilityByIndex(myHero, 4)) then
			skill = NPC.GetAbilityByIndex(myHero, 4)
		else
			if next(readyTable) ~= nil then
				if #readyTable >= 1 then
					invokeSkill = readyTable[1]
				else
					skill = nil
					invokeSkill = nil
				end
			end
		end
	elseif Ability.IsReady(NPC.GetAbilityByIndex(myHero, 4)) and Ability.GetName(NPC.GetAbilityByIndex(myHero, 4)) == "invoker_tornado" and FAIO.TargetDisableTimer(myHero, enemy) > 0 then
		skill = NPC.GetAbilityByIndex(myHero, 3)
	elseif Ability.IsReady(NPC.GetAbilityByIndex(myHero, 4)) and Ability.GetName(NPC.GetAbilityByIndex(myHero, 4)) ~= "invoker_ghost_walk" and Ability.GetName(NPC.GetAbilityByIndex(myHero, 4)) ~= "invoker_empty2" then
		skill = NPC.GetAbilityByIndex(myHero, 4)
	elseif Ability.IsReady(NPC.GetAbilityByIndex(myHero, 3)) and Ability.GetName(NPC.GetAbilityByIndex(myHero, 3)) ~= "invoker_ghost_walk"  and Ability.GetName(NPC.GetAbilityByIndex(myHero, 3)) ~= "invoker_empty1" then
		skill = NPC.GetAbilityByIndex(myHero, 3)
	end

	
	if not Ability.IsReady(NPC.GetAbilityByIndex(myHero, 4)) then
		if next(readyTable) ~= nil then
			if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_tornado")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_tornado")) < ((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000 + FAIO.invokerTornadoLiftDuration[Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0))] * (1 - (math.ceil(Hero.GetStrengthTotal(enemy) * 0.15)/100))) and NPC.GetCurrentLevel(myHero) >= 10 then
				if Ability.GetName(NPC.GetAbilityByIndex(myHero, 3)) == "invoker_emp" then
					if Ability.IsReady(NPC.GetAbility(myHero, "invoker_chaos_meteor")) then
						invokeSkill = NPC.GetAbility(myHero, "invoker_chaos_meteor")
					else
						if Ability.IsReady(NPC.GetAbility(myHero, "invoker_deafening_blast")) then
							invokeSkill = NPC.GetAbility(myHero, "invoker_deafening_blast")
						else
							invokeSkill = readyTable[1]
						end
					end
				elseif Ability.GetName(NPC.GetAbilityByIndex(myHero, 3)) == "invoker_sun_strike" then
					if Ability.IsReady(NPC.GetAbility(myHero, "invoker_chaos_meteor")) then
						invokeSkill = NPC.GetAbility(myHero, "invoker_chaos_meteor")
					else
						if Ability.IsReady(NPC.GetAbility(myHero, "invoker_deafening_blast")) then
							invokeSkill = NPC.GetAbility(myHero, "invoker_deafening_blast")
						else
							invokeSkill = readyTable[1]
						end
					end
				elseif Ability.GetName(NPC.GetAbilityByIndex(myHero, 3)) == "invoker_chaos_meteor" then
					if Ability.IsReady(NPC.GetAbility(myHero, "invoker_deafening_blast")) then
						invokeSkill = NPC.GetAbility(myHero, "invoker_deafening_blast")
					else
						invokeSkill = readyTable[1]
					end
				else
					invokeSkill = readyTable[1]
				end
			else
				if FAIO.InvokerLastCastedSkill ~= nil and Ability.GetName(FAIO.InvokerLastCastedSkill) == "invoker_deafening_blast" and Ability.GetName(NPC.GetAbilityByIndex(myHero, 3)) == "invoker_chaos_meteor" then
					if Ability.IsReady(NPC.GetAbility(myHero, "invoker_sun_strike")) then
						invokeSkill = NPC.GetAbility(myHero, "invoker_sun_strike")
					else
						invokeSkill = readyTable[1]
					end
				elseif  Ability.GetName(readyTable[1]) == "invoker_ice_wall" and #readyTable >= 1 then
					if NPC.IsEntityInRange(myHero, enemy, 800) then
						invokeSkill = readyTable[1]
					else
						if #readyTable > 1 then
							invokeSkill = readyTable[2]
						else
							invokeSkill = nil
						end
					end
				elseif  Ability.GetName(readyTable[1]) == "invoker_sun_strike" and #readyTable >= 1 then
					if FAIO.invokerSunstrikeKSdisabledTargetProcess(myHero, enemy) ~= nil and FAIO.invokerSunstrikeKSdisabledTargetProcess(myHero, enemy)[1] > 0 then
						invokeSkill = readyTable[1]
					else
						if NPC.HasModifier(enemy, "modifier_sheepstick_debuff") or NPC.HasModifier(enemy, "modifier_invoker_cold_snap") or NPC.HasModifier(enemy, "modifier_invoker_ice_wall_slow_debuff") then
							invokeSkill = readyTable[1]
						else
							if #readyTable > 1 then
								invokeSkill = readyTable[2]
							else
								invokeSkill = nil
							end
						end
					end
				else
					invokeSkill = readyTable[1]
				end
			end
		end
	end

	if invokeSkill then
		if not FAIO.InvokerIsAbilityInvoked(myHero, invokeSkill) then
			if GameRules.GetGameTime() - FAIO.lastCastTime3 > 0.05 and invoke and Ability.IsCastable(invoke, myMana) and FAIO.InvokerIsSkillInvokable(myHero, invokeSkill) then
				FAIO.invokerInvokeAbility(myHero, invokeSkill)
				FAIO.lastCastTime3 = GameRules.GetGameTime()
				return
			end
		end
	end

	local processingTempTable = {}
		if skill then
			if Ability.GetName(skill) == "invoker_tornado" or Ability.GetName(skill) == "invoker_emp" or Ability.GetName(skill) == "invoker_chaos_meteor" or Ability.GetName(skill) == "invoker_deafening_blast" or Ability.GetName(skill) == "invoker_sun_strike" or Ability.GetName(skill) == "invoker_ice_wall" then
				table.insert(processingTempTable, skillProcessing[Ability.GetName(skill)][2])
			else
				processingTempTable = {}
			end
		end

	local targetingStyle
		if skill then
			targetingStyle = skillProcessing[Ability.GetName(skill)][1]
		end

	local targetingDelay
		if skill then
			if Ability.GetName(skill) == "invoker_tornado" or Ability.GetName(skill) == "invoker_emp" or Ability.GetName(skill) == "invoker_chaos_meteor" or Ability.GetName(skill) == "invoker_deafening_blast" or Ability.GetName(skill) == "invoker_sun_strike" or Ability.GetName(skill) == "invoker_ice_wall" then
				targetingDelay = processingTempTable[1][1]
			elseif Ability.GetName(skill) == "invoker_alacrity" or Ability.GetName(skill) == "invoker_forge_spirit" or Ability.GetName(skill) == "invoker_cold_snap" then
				targetingDelay = FAIO.InvokerLastCastedSkillTime + 0.05
			end
		end

	local targetingTarget	
		if skill then
			if Ability.GetName(skill) == "invoker_tornado" or Ability.GetName(skill) == "invoker_emp" or Ability.GetName(skill) == "invoker_chaos_meteor" or Ability.GetName(skill) == "invoker_deafening_blast" or Ability.GetName(skill) == "invoker_sun_strike" then
				targetingTarget = processingTempTable[1][2]
			else
				targetingTarget = skillProcessing[Ability.GetName(skill)][2]
			end
		end

	if skill and Ability.GetName(skill) == "invoker_tornado" then
		if Menu.IsEnabled(FAIO.optionHeroInvokerTornadoItems) then
			FAIO.itemUsage(myHero, enemy)
		else
			if not Ability.IsReady(skill) then
				FAIO.itemUsage(myHero, enemy)
			end
		end
	else
		FAIO.itemUsage(myHero, enemy)
	end

	if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_INVULNERABLE) then
		if skill and not Ability.GetName(skill) == "invoker_ice_wall" then
			FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
			FAIO.invokerForgedSpiritController(myHero, enemy)
		elseif not skill or (skill and not Ability.IsCastable(skill, myMana)) then
			FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
			FAIO.invokerForgedSpiritController(myHero, enemy)
		end
	end

	if skill then
		if not NPC.IsEntityInRange(myHero, enemy, NPC.GetAttackRange(myHero)+200) then
			if blink and Ability.IsReady(blink) then
				if NPC.IsEntityInRange(myHero, enemy, 1150 + NPC.GetAttackRange(myHero)) then
					Ability.CastPosition(blink, Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(NPC.GetAttackRange(myHero)-100))
					return
				end
			end
		else
			if FAIO.InvokerIsAbilityInvoked(myHero, skill) then
				if GameRules.GetGameTime() > targetingDelay then
					if Ability.IsCastable(skill, myMana) then
						if skillProcessing[Ability.GetName(skill)][1] == "position" then
							if Ability.GetName(skill) == "invoker_tornado" then
								Ability.CastPosition(skill, targetingTarget)
								FAIO.noItemCastFor(((Entity.GetAbsOrigin(enemy) - Entity.GetAbsOrigin(myHero)):Length2D() / 1000) + 0.5)
								FAIO.InvokerLastCastedSkillTime = GameRules.GetGameTime()
								FAIO.InvokerLastCastedSkill = skill
								return
							else
								Ability.CastPosition(skill, targetingTarget)
								FAIO.InvokerLastCastedSkillTime = GameRules.GetGameTime()
								FAIO.InvokerLastCastedSkill = skill
								return
							end
						end
						if skillProcessing[Ability.GetName(skill)][1] == "target" then
							if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_INVULNERABLE) then
								Ability.CastTarget(skill, targetingTarget)
								FAIO.InvokerLastCastedSkillTime = GameRules.GetGameTime()
								FAIO.InvokerLastCastedSkill = skill
								return
							end
						end
						if skillProcessing[Ability.GetName(skill)][1] == "no target" then
							if Ability.GetName(skill) == "invoker_ice_wall" then
								if not NPC.IsEntityInRange(myHero, enemy, 600) then
									FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
									return
								else
									FAIO.InvokerIceWallHelper(myHero, enemy, skill, myMana)
									FAIO.InvokerLastCastedSkillTime = GameRules.GetGameTime() + 0.5
									FAIO.InvokerLastCastedSkill = skill
									return
								end
							else
								Ability.CastNoTarget(skill)
								FAIO.InvokerLastCastedSkillTime = GameRules.GetGameTime()
								FAIO.InvokerLastCastedSkill = skill
								return
							end		
						end
					end
				end
			end
		end
	end
	FAIO.invokerProcessInstancesWhileComboing(myHero)
end

function FAIO.InvokerFastIceWall(myHero, myMana, invoke, enemy)

	if not Menu.IsEnabled(FAIO.optionHeroInvokerIcewallEnable) then return end
	if not myHero then return end
	if enemy then
		if not NPC.IsEntityInRange(myHero, enemy, 600) then
			enemy = nil
		end
	end

	if FAIO.heroCanCastSpells(myHero, enemy) == false then return end
	
	if Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0)) < 1 or Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 2)) < 1 then return end
	
	local iceWall = NPC.GetAbility(myHero, "invoker_ice_wall")
		if not iceWall then return end
		if not Ability.IsReady(iceWall) then return end

	if not FAIO.InvokerIsAbilityInvoked(myHero, iceWall) then
		if invoke and Ability.IsCastable(invoke, myMana-175) and FAIO.InvokerIsSkillInvokable(myHero, iceWall) then
			if enemy then
				FAIO.invokerInvokeAbility(myHero, iceWall)
				FAIO.InvokerIceWallHelper(myHero, enemy, iceWall, myMana)
				return
			else
				FAIO.invokerInvokeAbility(myHero, iceWall)
				Ability.CastNoTarget(iceWall, true)
				return
			end
		end
	else
		if Ability.IsCastable(iceWall, myMana) then
			if enemy then
				FAIO.InvokerIceWallHelper(myHero, enemy, iceWall, myMana)
			else
				Ability.CastNoTarget(iceWall)
				return
			end
		end
	end

end

function FAIO.InvokerFastAlacrity(myHero, myMana, invoke, enemy)

	if not Menu.IsEnabled(FAIO.optionHeroInvokerAlacrityEnable) then return end
	if not myHero then return end

	if FAIO.heroCanCastSpells(myHero, enemy) == false then return end
	
	if Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 1)) < 1 or Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 2)) < 1 then return end
	
	local alacrity = NPC.GetAbility(myHero, "invoker_alacrity")
		if not alacrity then return end
		if not Ability.IsReady(alacrity) then return end
	
	if not FAIO.InvokerIsAbilityInvoked(myHero, alacrity) then
		if invoke and Ability.IsCastable(invoke, myMana-60) and FAIO.InvokerIsSkillInvokable(myHero, alacrity) then
			FAIO.invokerInvokeAbility(myHero, alacrity)
			Ability.CastTarget(alacrity, myHero)
			return
		end
	else
		if Ability.IsCastable(alacrity, myMana) then
			Ability.CastTarget(alacrity, myHero)
			return
		end
	end

end

function FAIO.InvokerFastTornado(myHero, myMana, invoke, enemy)

	if not Menu.IsEnabled(FAIO.optionHeroInvokerTornadoEnable) then return end
	if not myHero then return end

	if FAIO.heroCanCastSpells(myHero, enemy) == false then return end
	
	if Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0)) < 1 or Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 1)) < 1 then return end

	local tornado = NPC.GetAbility(myHero, "invoker_tornado")
		if not tornado then return end
		if not Ability.IsReady(tornado) then return end

	local tornadoRange = math.min(400 + 400 * Ability.GetLevel(NPC.GetAbility(myHero, "invoker_wex")), 2000)

	if not FAIO.InvokerIsAbilityInvoked(myHero, tornado) then
		if invoke and Ability.IsCastable(invoke, myMana-150) and FAIO.InvokerIsSkillInvokable(myHero, tornado) then
			FAIO.invokerInvokeAbility(myHero, tornado)
			if Menu.GetValue(FAIO.optionHeroInvokerTornadoStyle) == 0 then
				if NPC.IsEntityInRange(myHero, enemy, tornadoRange) and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
					local tornadoPrediction = Ability.GetCastPoint(tornado) + (Entity.GetAbsOrigin(enemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1000) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
					Ability.CastPosition(tornado, FAIO.castLinearPrediction(myHero, enemy, tornadoPrediction))
					return
				end
			else
				local pos = Entity.GetAbsOrigin(myHero) + (Input.GetWorldCursorPos() - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(500)
				Ability.CastPosition(tornado, pos)
				return
			end
		end
	else
		if Menu.GetValue(FAIO.optionHeroInvokerTornadoStyle) == 0 then
			if NPC.IsEntityInRange(myHero, enemy, tornadoRange) and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
				local tornadoPrediction = Ability.GetCastPoint(tornado) + (Entity.GetAbsOrigin(enemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1000) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
				Ability.CastPosition(tornado, FAIO.castLinearPrediction(myHero, enemy, tornadoPrediction))
				return
			end
		else
			local pos = Entity.GetAbsOrigin(myHero) + (Input.GetWorldCursorPos() - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(500)
			Ability.CastPosition(tornado, pos)
			return
		end
	end

end

function FAIO.InvokerCataclysmKillSteal(myHero, myMana, invoke)

	if not myHero then return false end

	if FAIO.heroCanCastSpells(myHero, enemy) == false then return end
	if FAIO.isHeroChannelling(myHero) == true then return end 
	if FAIO.IsHeroInvisible(myHero) == true then return end
	
	if Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 2)) < 1 then return end

	local cataclysm = NPC.GetAbility(myHero, "special_bonus_unique_invoker_4")
		if not cataclysm then return end
		if Ability.GetLevel(cataclysm) < 1 then return end

	local sunStrike = NPC.GetAbility(myHero, "invoker_sun_strike")
		if not sunStrike then return end
		if not Ability.IsReady(sunStrike) then return end
		if not Ability.IsCastable(sunStrike, myMana) then return end

	local damage = (37.5 + 62.5 * Ability.GetLevel(NPC.GetAbility(myHero, "invoker_exort"))) * 0.95

	local ssSlot = 3
		if FAIO.InvokerIsAbilityInvoked(myHero, sunStrike) then
			if Ability.GetName(NPC.GetAbilityByIndex(myHero, 4)) == "invoker_sun_strike" then
				ssSlot = 4
			end
		end

	local count = 0
	for i = 1, Heroes.Count(), 1 do
		local enemies = Heroes.Get(i)
		if enemies ~= nil and Entity.IsHero(enemies) and not Entity.IsSameTeam(myHero, enemies) then
			local enemy = FAIO.targetChecker(enemies)
			if enemy then
				if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_INVULNERABLE) then
					if Entity.GetHealth(enemy) + NPC.GetHealthRegen(enemy) * 2 <= damage then
						count = count + 1
					end
				end
			end
		end
	end

	if count > 0 then
		if count >= Menu.GetValue(FAIO.optionHeroInvokerCataKSCount) then
			if not FAIO.InvokerIsAbilityInvoked(myHero, sunStrike) then
				if invoke and Ability.IsCastable(invoke, myMana-175) and FAIO.InvokerIsSkillInvokable(myHero, sunStrike) then
					FAIO.invokerInvokeAbility(myHero, sunStrike)
					return
				end
			else
				if os.clock() - FAIO.invokerChannellingKillstealTimer > 0.5 then
					Ability.CastTarget(sunStrike, myHero)
					FAIO.invokerChannellingKillstealTimer = os.clock()
					return
				end
			end	
		end
	end

	return

end

function FAIO.InvokerCancelTPingInFog(myHero, myMana, enemy, invoke, tornado)

	if Menu.IsKeyDownOnce(FAIO.optionComboKey) then return end
	if Menu.IsKeyDown(FAIO.optionComboKey) then return end

	if os.clock() - FAIO.invokerChannellingKillstealTimer <= 3 then return end

	if not myHero then return end

	if FAIO.heroCanCastSpells(myHero, enemy) == false then return end
	if FAIO.isHeroChannelling(myHero) == true then return end 
	if FAIO.IsHeroInvisible(myHero) == true then return end

	if Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0)) < 1 or Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 1)) < 1 or Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 2)) < 1 then return end

	if not tornado then return end
	if not Ability.IsReady(tornado) then return end
	if not FAIO.InvokerIsAbilityInvoked(myHero, tornado) and not Ability.IsCastable(invoke, myMana) then return end

	if FAIO.TPParticleUnit ~= nil and Entity.IsDormant(FAIO.TPParticleUnit) then
		if FAIO.TPParticleTime > 0 and FAIO.TPParticlePosition:__tostring() ~= Vector(0.0, 0.0, 0.0):__tostring() and not FAIO.invokerSunstrikeKSParticleProcess(myHero) then
			if (Entity.GetAbsOrigin(myHero) - FAIO.TPParticlePosition):Length2D() < 2250 then
				if GameRules.GetGameTime() + ((Entity.GetAbsOrigin(myHero) - FAIO.TPParticlePosition):Length2D() / 1000) < FAIO.TPParticleTime + 2.75 then
					if NPC.IsPositionInRange(myHero, FAIO.TPParticlePosition, (400 + Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 1)) * 400), 0) then
						if tornado and Ability.IsReady(tornado) then
							if not FAIO.InvokerIsAbilityInvoked(myHero, tornado) then
								if invoke and Ability.IsCastable(invoke, myMana) and Ability.IsCastable(tornado, myMana - 60) and FAIO.InvokerIsSkillInvokable(myHero, tornado) then
									FAIO.invokerInvokeAbility(myHero, tornado)
									Ability.CastPosition(tornado, Entity.GetAbsOrigin(myHero) + (FAIO.TPParticlePosition - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(250), true)
									FAIO.invokerChannellingKillstealTimer = os.clock()
									return
								end
							else
								if Ability.IsCastable(tornado, myMana) then
									Ability.CastPosition(tornado, Entity.GetAbsOrigin(myHero) + (FAIO.TPParticlePosition - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(250))
									FAIO.invokerChannellingKillstealTimer = os.clock()
									return
								end
							end
						end
					end
				end
			end
		end
	end

end

function FAIO.InvokerCancelBaraCharge(myHero, myMana, enemy, invoke, coldSnap, tornado, deafeningBlast)

	if Menu.IsKeyDownOnce(FAIO.optionComboKey) then return end
	if Menu.IsKeyDown(FAIO.optionComboKey) then return end

	if os.clock() - FAIO.invokerChannellingKillstealTimer <= 3 then return end

	if not myHero then return end

	if FAIO.heroCanCastSpells(myHero, enemy) == false then return end
	if FAIO.isHeroChannelling(myHero) == true then return end 
	if FAIO.IsHeroInvisible(myHero) == true then return end

	if Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0)) < 1 or Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 1)) < 1 or Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 2)) < 1 then return end

	if not coldSnap or not tornado or not deafeningBlast then return end
	if not Ability.IsReady(coldSnap) and not Ability.IsReady(tornado) and not Ability.IsReady(deafeningBlast) then return end
	if not FAIO.InvokerIsAbilityInvoked(myHero, coldSnap) and not FAIO.InvokerIsAbilityInvoked(myHero, tornado) and not FAIO.InvokerIsAbilityInvoked(myHero, deafeningBlast) and not Ability.IsCastable(invoke, myMana) then return end

	local skillSelector
	if Ability.IsReady(coldSnap) then
		skillSelector = coldSnap
	else
		if Ability.IsReady(tornado) then
			skillSelector = tornado
		else
			if Ability.IsReady(deafeningBlast) then
				skillSelector = deafeningBlast
			end
		end
	end

	if not skillSelector then return end

	local castRange = 950
	if skillSelector ~= nil and skillSelector == tornado then
		castRange = 400 + Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 1)) * 400
	end
	if castRange > 1750 then
		castRange = 1750
	end

	local cancelEnemies = Wrap.HeroesInRadius(myHero, castRange, Enum.TeamType.TEAM_ENEMY)
	for _, cancelEnemy in ipairs(cancelEnemies) do
		if cancelEnemy and not Entity.IsDormant(cancelEnemy) and not NPC.IsIllusion(cancelEnemy) and Wrap.EIsAlive(cancelEnemy) then
			if NPC.HasModifier(cancelEnemy, "modifier_spirit_breaker_charge_of_darkness") then
				if not NPC.HasState(cancelEnemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then	
					if not NPC.IsLinkensProtected(cancelEnemy) then
						if skillSelector == coldSnap then
							if not FAIO.InvokerIsAbilityInvoked(myHero, skillSelector) then
								if invoke and Ability.IsCastable(invoke, myMana) and Ability.IsCastable(skillSelector, myMana - 60) and FAIO.InvokerIsSkillInvokable(myHero, skillSelector) then
									FAIO.invokerInvokeAbility(myHero, skillSelector)
									Ability.CastTarget(skillSelector, cancelEnemy, true)
									FAIO.invokerChannellingKillstealTimer = os.clock()
									break
									return
								end
							else
								if Ability.IsCastable(skillSelector, myMana) then
									Ability.CastTarget(skillSelector, cancelEnemy)
									FAIO.invokerChannellingKillstealTimer = os.clock()
									break
									return
								end
							end
						elseif skillSelector == deafeningBlast then
							local deafeningBlastPrediction = Ability.GetCastPoint(skillSelector) + (Entity.GetAbsOrigin(cancelEnemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1100) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2) + NPC.GetTimeToFace(myHero, cancelEnemy) + 1
							if NPC.IsRunning(cancelEnemy) and FAIO.GetMoveSpeed(cancelEnemy) > 500 then
								if not FAIO.InvokerIsAbilityInvoked(myHero, skillSelector) then
									if invoke and Ability.IsCastable(invoke, myMana) and Ability.IsCastable(skillSelector, myMana - 60) and FAIO.InvokerIsSkillInvokable(myHero, skillSelector) then
										FAIO.invokerInvokeAbility(myHero, skillSelector)
										Ability.CastPosition(skillSelector, Entity.GetAbsOrigin(myHero) + (FAIO.castLinearPrediction(myHero, cancelEnemy, deafeningBlastPrediction) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(50), true)
										FAIO.invokerChannellingKillstealTimer = os.clock()
										break
										return
									end
								else
									if Ability.IsCastable(skillSelector, myMana) then
										Ability.CastPosition(deafeningBlast, FAIO.castLinearPrediction(myHero, cancelEnemy, deafeningBlastPrediction))
										FAIO.invokerChannellingKillstealTimer = os.clock()
										break
										return
									end
								end
							end
						end
					end		
					if skillSelector == tornado then
						local tornadoPrediction = Ability.GetCastPoint(tornado) + (Entity.GetAbsOrigin(cancelEnemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1000) * 1.25 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2) + 0.75 + NPC.GetTimeToFace(myHero, cancelEnemy)
						if NPC.IsRunning(cancelEnemy) and FAIO.GetMoveSpeed(cancelEnemy) > 500 and not Entity.IsDormant(cancelEnemy) then
							if not FAIO.InvokerIsAbilityInvoked(myHero, tornado) then
								if invoke and Ability.IsCastable(invoke, myMana) and Ability.IsCastable(skillSelector, myMana - 60) and FAIO.InvokerIsSkillInvokable(myHero, skillSelector) then
									FAIO.invokerInvokeAbility(myHero, tornado)
									Ability.CastPosition(tornado, FAIO.castLinearPrediction(myHero, cancelEnemy, tornadoPrediction), true)
									FAIO.invokerChannellingKillstealTimer = os.clock()
									break
									return
								end
							else
								if Ability.IsCastable(tornado, myMana) then
									Ability.CastPosition(tornado, FAIO.castLinearPrediction(myHero, cancelEnemy, tornadoPrediction))
									FAIO.invokerChannellingKillstealTimer = os.clock()
									break
									return
								end
							end
						end
					end
				end
			end
		end
	end
		
end

function FAIO.InvokerCancelVisibleChannellingAbilities(myHero, myMana, enemy, invoke, coldSnap, tornado)

	if Menu.IsKeyDownOnce(FAIO.optionComboKey) then return end
	if Menu.IsKeyDown(FAIO.optionComboKey) then return end

	if os.clock() - FAIO.invokerChannellingKillstealTimer <= 3 then return end

	if not myHero then return end

	if FAIO.heroCanCastSpells(myHero, enemy) == false then return end
	if FAIO.isHeroChannelling(myHero) == true then return end 
	if FAIO.IsHeroInvisible(myHero) == true then return end

	if Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0)) < 1 or Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 1)) < 1 or Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 2)) < 1 then return end

	if not coldSnap or not tornado then return end
	if not Ability.IsReady(coldSnap) and not Ability.IsReady(tornado) then return end
	if not FAIO.InvokerIsAbilityInvoked(myHero, coldSnap) and not FAIO.InvokerIsAbilityInvoked(myHero, tornado) and not Ability.IsCastable(invoke, myMana) then return end

	local channellingTable = {
		npc_dota_hero_bane = { "bane_fiends_grip", { 5, 5, 5 } },
		npc_dota_hero_crystal_maiden = { "crystal_maiden_freezing_field", { 10, 10, 10} },
		npc_dota_hero_enigma = { "enigma_black_hole", { 4, 4, 4 } },
		npc_dota_hero_oracle = { "oracle_fortunes_end", { 2.5, 2.5, 2.5, 2.5 } },
		npc_dota_hero_pudge = { "pudge_dismember", { 3, 3, 3 } },
		npc_dota_hero_pugna = { "pugna_life_drain", { 10, 10, 10 } },
		npc_dota_hero_sand_king = { "sandking_epicenter", { 2, 2, 2} },
		npc_dota_hero_shadow_shaman = { "shadow_shaman_shackles", { 2.75, 3.5, 4.25, 5 } },
		npc_dota_hero_tinker = { "tinker_rearm", { 3, 1.5, 0.75 } },
		npc_dota_hero_warlock = { "warlock_upheaval", { 16, 16, 16, 16 } },
		npc_dota_hero_witch_doctor = { "witch_doctor_death_ward", { 8, 8, 8} }
				}

	local cancelEnemies = Wrap.HeroesInRadius(myHero, 1750, Enum.TeamType.TEAM_ENEMY)
	for _, cancelEnemy in ipairs(cancelEnemies) do
		if cancelEnemy and not Entity.IsDormant(cancelEnemy) and not NPC.IsIllusion(cancelEnemy) and Wrap.EIsAlive(cancelEnemy) then
			if not NPC.HasState(cancelEnemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
				for i, v in pairs(channellingTable) do
					if (NPC.GetUnitName(cancelEnemy) == i and Ability.IsChannelling(NPC.GetAbility(cancelEnemy, v[1]))) or NPC.HasModifier(cancelEnemy, "modifier_teleporting") then
						local enemyRange = (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(cancelEnemy)):Length2D()
						local skillSelector
							if FAIO.InvokerIsAbilityInvoked(myHero, coldSnap) then
								if Ability.IsReady(coldSnap) and enemyRange < 950 then
									skillSelector = coldSnap
								else
									if Ability.IsReady(tornado) and enemyRange < 400 + Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 1)) * 400 then
										if not FAIO.InvokerIsAbilityInvoked(myHero, tornado) then
											if Ability.IsReady(invoke) then
												skillSelector = tornado
											end
										else
											skillSelector = tornado
										end
									end
								end
							elseif FAIO.InvokerIsAbilityInvoked(myHero, tornado) then
								if Ability.IsReady(tornado) and enemyRange < 400 + Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 1)) * 400 then
									skillSelector = tornado
								else
									if Ability.IsReady(coldSnap) and enemyRange < 950 then
										if not FAIO.InvokerIsAbilityInvoked(myHero, coldSnap) then
											if Ability.IsReady(invoke) then
												skillSelector = coldSnap
											end
										else
											skillSelector = coldSnap
										end
									end
								end
							elseif not FAIO.InvokerIsAbilityInvoked(myHero, coldSnap) and not FAIO.InvokerIsAbilityInvoked(myHero, tornado) then
								if Ability.IsReady(invoke) then
									if Ability.IsReady(coldSnap) and enemyRange < 950 then
										skillSelector = coldSnap
									else
										if Ability.IsReady(tornado) and enemyRange < 400 + Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 1)) * 400 then
											skillSelector = tornado
										end
									end
								end
							end
						if skillSelector == nil then
							break
							return
						end

						if skillSelector == coldSnap then
							if not NPC.IsLinkensProtected(cancelEnemy) then
								if not FAIO.InvokerIsAbilityInvoked(myHero, skillSelector) then
									if invoke and Ability.IsCastable(invoke, myMana) and Ability.IsCastable(skillSelector, myMana - 60) and FAIO.InvokerIsSkillInvokable(myHero, skillSelector) then
										FAIO.invokerInvokeAbility(myHero, skillSelector)
										Ability.CastTarget(skillSelector, cancelEnemy, true)
										FAIO.invokerChannellingKillstealTimer = os.clock()
										break
										return
									end
								else
									if Ability.IsCastable(skillSelector, myMana) then
										Ability.CastTarget(coldSnap, cancelEnemy)
										FAIO.invokerChannellingKillstealTimer = os.clock()
										break
										return
									end
								end
							end
						elseif skillSelector == tornado then
							if NPC.GetUnitName(cancelEnemy) == i and Ability.IsChannelling(NPC.GetAbility(cancelEnemy, v[1])) then
								if Ability.GetChannelStartTime(NPC.GetAbility(cancelEnemy, v[1])) + v[2][Ability.GetLevel(NPC.GetAbility(cancelEnemy, v[1]))] > GameRules.GetGameTime() + ((Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Length2D() / 1000) then
									if not FAIO.InvokerIsAbilityInvoked(myHero, skillSelector) then
										if invoke and Ability.IsCastable(invoke, myMana) and Ability.IsCastable(skillSelector, myMana - 60) and FAIO.InvokerIsSkillInvokable(myHero, skillSelector) then
											FAIO.invokerInvokeAbility(myHero, skillSelector)
											Ability.CastPosition(skillSelector, Entity.GetAbsOrigin(cancelEnemy), true)
											FAIO.invokerChannellingKillstealTimer = os.clock()
											break
											return
										end
									else
										if Ability.IsCastable(skillSelector, myMana) then
											Ability.CastPosition(skillSelector, Entity.GetAbsOrigin(cancelEnemy))
											FAIO.invokerChannellingKillstealTimer = os.clock()
											break
											return
										end
									end
								end
							elseif NPC.HasModifier(cancelEnemy, "modifier_teleporting") then
								if GameRules.GetGameTime() + ((Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Length2D() / 1000) < Modifier.GetDieTime(NPC.GetModifier(cancelEnemy, "modifier_teleporting")) and Ability.IsReady(tornado) then
									if not FAIO.InvokerIsAbilityInvoked(myHero, skillSelector) then
										if invoke and Ability.IsCastable(invoke, myMana) and Ability.IsCastable(skillSelector, myMana - 60) and FAIO.InvokerIsSkillInvokable(myHero, skillSelector) then
											FAIO.invokerInvokeAbility(myHero, skillSelector)
											Ability.CastPosition(skillSelector, Entity.GetAbsOrigin(cancelEnemy), true)
											FAIO.invokerChannellingKillstealTimer = os.clock()
											break
											return
										end
									else
										if Ability.IsCastable(skillSelector, myMana) then
											Ability.CastPosition(skillSelector, Entity.GetAbsOrigin(cancelEnemy))
											FAIO.invokerChannellingKillstealTimer = os.clock()
											break
											return
										end
									end
								end
							end
						end
					end
				end
			end
		end
	end

end

function FAIO.InvokerIsSkillInvokable(myHero, skill)

	if not myHero then return false end
	if not skill then return false end

	local skillName = Ability.GetName(skill)

	for i, v in pairs(FAIO.invokerInvokeOrder) do
		if i == skillName then
			for k, l in ipairs(v) do
				if not NPC.GetAbilityByIndex(myHero, l) or (NPC.GetAbilityByIndex(myHero, l) and Ability.GetLevel(NPC.GetAbilityByIndex(myHero, l)) < 1) then
					return false
				end
			end
		end
	end

	return true

end

function FAIO.InvokerPreInvoke(myHero, myMana, invoke)

	if not myHero then return end
	if FAIO.heroCanCastSpells(myHero, enemy) == false then return end
	if FAIO.isHeroChannelling(myHero) == true then return end 
	if FAIO.IsHeroInvisible(myHero) == true then return end

	if os.clock() - FAIO.lastTick < 0.5 then return end

	if Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0)) < 1 and Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 1)) < 1 and Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 2)) < 1 then
		FAIO.PreInvokeSkills = {}
		return
	end

	local skill1
	local skill2
	for _, v in ipairs(FAIO.PreInvokeSkills) do
		if v then
			skill1 = v[1]
			skill2 = v[2]
		end
	end

	if not FAIO.InvokerIsSkillInvokable(myHero, skill1) or not FAIO.InvokerIsSkillInvokable(myHero, skill2) then
		FAIO.PreInvokeSkills = {}
		return
	end
		
	local invokeChecker = FAIO.InvokerInvokedChecker(myHero, Ability.GetName(skill1), Ability.GetName(skill2))

	if invokeChecker then
		FAIO.PreInvokeSkills = {}
		return
	end

	if next(FAIO.PreInvokeSkills) == nil then return end

	if Ability.GetName(NPC.GetAbilityByIndex(myHero, 4)) == Ability.GetName(skill1) or Ability.GetName(NPC.GetAbilityByIndex(myHero, 4)) == Ability.GetName(skill1) then
		if invoke and Ability.IsCastable(invoke, myMana) then
			FAIO.invokerInvokeAbility(myHero, NPC.GetAbilityByIndex(myHero, 4))
			FAIO.lastTick = os.clock()
			return
		end
	end

	if Ability.GetName(NPC.GetAbilityByIndex(myHero, 3)) ~= Ability.GetName(skill2) then
		if invoke and Ability.IsCastable(invoke, myMana) then
			FAIO.invokerInvokeAbility(myHero, skill2)
			FAIO.lastTick = os.clock()
			return
		end
	end

	if Ability.GetName(NPC.GetAbilityByIndex(myHero, 3)) == Ability.GetName(skill2) then
		if invoke and Ability.IsCastable(invoke, myMana) then
			FAIO.invokerInvokeAbility(myHero, skill1)
			FAIO.lastTick = os.clock()
			return
		end
	end
end
			
function FAIO.InvokerIsAbilityInvoked(myHero, skill)

	for i = 3, 4 do
		if Ability.GetName(NPC.GetAbilityByIndex(myHero, i)) == Ability.GetName(skill) then
			return true
		end
	end
	
	return false

end
	

function FAIO.InvokerInvokedChecker(myHero, skill1, skill2)

	if Ability.GetName(NPC.GetAbilityByIndex(myHero,3)) == skill1 and Ability.GetName(NPC.GetAbilityByIndex(myHero,4)) == skill2 then
		return true
	end
	
	return false

end

function FAIO.invokerInvokeAbility(myHero, ability)
	
	if not myHero then return end
	if not ability then return end

	if FAIO.heroCanCastSpells(myHero, enemy) == false then return end
	if FAIO.isHeroChannelling(myHero) == true then return end 
	if FAIO.IsHeroInvisible(myHero) == true then return end

	if not FAIO.InvokerIsSkillInvokable(myHero, ability) then return end

	local skillName = Ability.GetName(ability)
    		if not skillName then return end

	local invokeOrder = FAIO.invokerInvokeOrder[skillName]
    		if not invokeOrder then return end

	local invoke = NPC.GetAbility(myHero, "invoker_invoke")
		if not invoke then return end

	for i, v in ipairs(invokeOrder) do
        	local orb = NPC.GetAbilityByIndex(myHero, v)

        	if orb then
			Ability.CastNoTarget(orb)
		end
	end

	Ability.CastNoTarget(invoke)

end

function FAIO.invokerProcessInstancesWhileComboing(myHero)

	if not myHero then return end
	if os.clock() - FAIO.invokerCaptureGhostwalkActivation < 1.5 then return end
	if FAIO.heroCanCastSpells(myHero, enemy) == false then return end
	if FAIO.isHeroChannelling(myHero) == true then return end 
	if FAIO.IsHeroInvisible(myHero) == true then return end

	if Ability.GetCooldownTimeLeft(NPC.GetAbility(myHero, "invoker_invoke")) < 0.25 then return end
	if Ability.IsReady(NPC.GetAbility(myHero, "invoker_invoke")) then return end
	
	if os.clock() - FAIO.InvokerCaptureManualInstances < 2.5 then return end

	if Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) > -1 and Ability.SecondsSinceLastUse(NPC.GetAbility(myHero, "invoker_ghost_walk")) < 1 then return end
	if NPC.HasModifier(myHero, "modifier_invoker_ghost_walk_self") then return end
	
	if os.clock() - FAIO.InvokerLastChangedInstance < 0.75 then return end

	local instanceTable = {}
	local modifiers = NPC.GetModifiers(myHero)
	for _, modifier in ipairs(modifiers) do
		if modifier then
			local modifierName = Modifier.GetName(modifier)
			if modifierName == "modifier_invoker_quas_instance" or modifierName == "modifier_invoker_wex_instance" or modifierName == "modifier_invoker_exort_instance" then
				table.insert(instanceTable, modifierName)
			end
		end
	end

	if #instanceTable < 3 then return end

	if Entity.GetHealth(myHero) < Entity.GetMaxHealth(myHero) * 0.25 then
		if instanceTable[1] ~= "modifier_invoker_quas_instance" or instanceTable[2] ~= "modifier_invoker_quas_instance" or instanceTable[3] ~= "modifier_invoker_quas_instance" then
			FAIO.invokerChangeInstances(myHero, "QQQ")
			FAIO.InvokerLastChangedInstance = os.clock()
		end
	else
		if instanceTable[1] ~= "modifier_invoker_exort_instance" or instanceTable[2] ~= "modifier_invoker_exort_instance" or instanceTable[3] ~= "modifier_invoker_exort_instance" then
			FAIO.invokerChangeInstances(myHero, "EEE")
			FAIO.InvokerLastChangedInstance = os.clock()
		end
	end

end

function FAIO.invokerProcessInstances(myHero, order)

	if not myHero then return end
	if not order then return end
	if os.clock() - FAIO.invokerCaptureGhostwalkActivation < 1.5 then return end
	if os.clock() - FAIO.InvokerCaptureManualInstances < 2.5 then return end
	if next(FAIO.PreInvokeSkills) ~= nil then return end

	if FAIO.heroCanCastSpells(myHero, enemy) == false then return end
	if FAIO.isHeroChannelling(myHero) == true then return end 
	if FAIO.IsHeroInvisible(myHero) == true then return end

	if Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0)) < 1 and Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 2)) < 1 and Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 2)) < 1 then
		return
	end

	if os.clock() - FAIO.InvokerLastChangedInstance < Menu.GetValue(FAIO.optionHeroInvokerInstanceDelay) * 0.25 then return end

	local instanceTable = {}
	local modifiers = NPC.GetModifiers(myHero)
	for _, modifier in ipairs(modifiers) do
		if modifier then
			local modifierName = Modifier.GetName(modifier)
			if modifierName == "modifier_invoker_quas_instance" or modifierName == "modifier_invoker_wex_instance" or modifierName == "modifier_invoker_exort_instance" then
				table.insert(instanceTable, modifierName)
			end
		end
	end

	if #instanceTable < 3 then return end

	if order == Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION or order == Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_TARGET then
		if Entity.GetHealth(myHero) < Entity.GetMaxHealth(myHero) then
			if instanceTable[1] ~= "modifier_invoker_quas_instance" or instanceTable[2] ~= "modifier_invoker_quas_instance" or instanceTable[3] ~= "modifier_invoker_quas_instance" then
				FAIO.invokerChangeInstances(myHero, "QQQ")
				FAIO.InvokerLastChangedInstance = os.clock()
			end
		else
			if instanceTable[1] ~= "modifier_invoker_wex_instance" or instanceTable[2] ~= "modifier_invoker_wex_instance" or instanceTable[3] ~= "modifier_invoker_wex_instance" then
				FAIO.invokerChangeInstances(myHero, "WWW")
				FAIO.InvokerLastChangedInstance = os.clock()
			end
		end
	end

	if order == Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_MOVE or order == Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET then
		local exort = NPC.GetAbilityByIndex(myHero, 2)
		if exort and Ability.GetLevel(exort) > 0 then
			if instanceTable[1] ~= "modifier_invoker_exort_instance" or instanceTable[2] ~= "modifier_invoker_exort_instance" or instanceTable[3] ~= "modifier_invoker_exort_instance" then
				FAIO.invokerChangeInstances(myHero, "EEE")
				FAIO.InvokerLastChangedInstance = os.clock()
			end
		else
			if instanceTable[1] ~= "modifier_invoker_wex_instance" or instanceTable[2] ~= "modifier_invoker_wex_instance" or instanceTable[3] ~= "modifier_invoker_wex_instance" then
				FAIO.invokerChangeInstances(myHero, "WWW")
				FAIO.InvokerLastChangedInstance = os.clock()
			end
		end
	end

end		

function FAIO.invokerChangeInstances(myHero, instance)

	if not myHero then return end
	if not instance then return end

	if os.clock() - FAIO.invokerCaptureGhostwalkActivation < 1.5 then return end
	
	if FAIO.heroCanCastSpells(myHero, enemy) == false then return end
	if FAIO.isHeroChannelling(myHero) == true then return end 
	if FAIO.IsHeroInvisible(myHero) == true then return end

	if Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 0)) < 1 and Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 2)) < 1 and Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 2)) < 1 then
		return
	end

	local invokeOrder = {}
	if instance == "QQQ" then
		local quas = NPC.GetAbilityByIndex(myHero, 0)
		if quas and Ability.GetLevel(quas) > 0 then
			invokeOrder = {0,0,0}
		end
	elseif instance == "WWW" then
		local wex = NPC.GetAbilityByIndex(myHero, 1)
		if wex and Ability.GetLevel(wex) > 0 then
			invokeOrder = {1,1,1}
		end
	elseif instance == "EEE" then
		local exort = NPC.GetAbilityByIndex(myHero, 2)
		if exort and Ability.GetLevel(exort) > 0 then
			invokeOrder = {2,2,2}
		end
	end

	for i, v in ipairs(invokeOrder) do
        	local orb = NPC.GetAbilityByIndex(myHero, v)

        	if orb then
			Ability.CastNoTarget(orb)
		end
	end

end

function FAIO.invokerSunstrikeKSdisabledTargetProcess(myHero, enemy)

	if not myHero then return end
	if not enemy then return end

	local sunStrike = NPC.GetAbility(myHero, "invoker_sun_strike")
	if not sunStrike or (sunStrike and not Ability.IsReady(sunStrike)) then return end
	local aghanims = NPC.GetItem(myHero, "item_ultimate_scepter", true)
	local sunStrikeDMG = 37.5 + (62.5 * Ability.GetLevel(NPC.GetAbility(myHero, "invoker_exort")))
		if aghanims or NPC.HasModifier(myHero, "modifier_item_ultimate_scepter_consumed") then
			sunStrikeDMG = 37.5 + (62.5 * (Ability.GetLevel(NPC.GetAbility(myHero, "invoker_exort")) + 1))
		end

	local curTime = GameRules.GetGameTime()

	local stunRootList = {
		"modifier_stunned",
		"modifier_bashed",
		"modifier_alchemist_unstable_concoction", 
		"modifier_ancientapparition_coldfeet_freeze", 
		"modifier_axe_berserkers_call",
		"modifier_bane_fiends_grip",
		"modifier_bane_nightmare",
		"modifier_bloodseeker_rupture",
		"modifier_rattletrap_hookshot", 
		"modifier_earthshaker_fissure_stun", 
		"modifier_earth_spirit_boulder_smash",
		"modifier_enigma_black_hole_pull",
		"modifier_faceless_void_chronosphere_freeze",
		"modifier_jakiro_ice_path_stun", 
		"modifier_keeper_of_the_light_mana_leak_stun", 
		"modifier_kunkka_torrent", 
		"modifier_legion_commander_duel", 
		"modifier_lion_impale", 
		"modifier_magnataur_reverse_polarity", 
		"modifier_medusa_stone_gaze_stone", 
		"modifier_morphling_adaptive_strike", 
		"modifier_naga_siren_ensnare", 
		"modifier_nyx_assassin_impale", 
		"modifier_pudge_dismember", 
		"modifier_sandking_impale", 
		"modifier_shadow_shaman_shackles", 
		"modifier_techies_stasis_trap_stunned", 
		"modifier_tidehunter_ravage", 
		"modifier_treant_natures_guise",
		"modifier_windrunner_shackle_shot",
		"modifier_rooted", 
		"modifier_crystal_maiden_frostbite", 
		"modifier_ember_spirit_searing_chains", 
		"modifier_meepo_earthbind",
		"modifier_lone_druid_spirit_bear_entangle_effect",
		"modifier_slark_pounce_leash",
		"modifier_storm_spirit_electric_vortex_pull",
		"modifier_treant_overgrowth", 
		"modifier_abyssal_underlord_pit_of_malice_ensare", 
		"modifier_rod_of_atos_debuff",
		"modifier_eul_cyclone",
		"modifier_obsidian_destroyer_astral_imprisonment_prison",
		"modifier_shadow_demon_disruption",
		"modifier_teleporting",
		"modifier_invoker_tornado"
			}
	
	local searchMod
	for _, modifier in ipairs(stunRootList) do
		if NPC.HasModifier(enemy, modifier) then
			searchMod = NPC.GetModifier(enemy, modifier)
			break
		end
	end

	if not searchMod then return { 0, 0 } end

	local timing = 0
	local HPtreshold = 0
	if searchMod then
		if NPC.HasModifier(enemy, Modifier.GetName(searchMod)) then
			if Modifier.GetName(searchMod) == "modifier_enigma_black_hole_pull" then
				if Modifier.GetCreationTime(searchMod) + 4 - curTime >= 1.5 then
					timing = Modifier.GetCreationTime(searchMod) + 0.3
					HPtreshold = sunStrikeDMG + 2 * FAIO.GetTeammateAbilityLevel(myHero, "enigma_black_hole") * 37
				else
					timing = 0
					HPtreshold = 0
				end
			elseif Modifier.GetName(searchMod) == "modifier_faceless_void_chronosphere_freeze" then
				if Modifier.GetCreationTime(searchMod) + (3.5 + FAIO.GetTeammateAbilityLevel(myHero, "faceless_void_chronosphere") * 0.5) - curTime >= 1.5 then
					timing = Modifier.GetCreationTime(searchMod)
					HPtreshold = sunStrikeDMG * 1.25
				else
					timing = 0
					HPtreshold = 0
				end
			elseif Modifier.GetName(searchMod) == "modifier_axe_berserkers_call" then
				if Modifier.GetDieTime(searchMod) - curTime >= 1.5 then
					timing = Modifier.GetCreationTime(searchMod)
					HPtreshold = sunStrikeDMG * 1.35
				else
					timing = 0
					HPtreshold = 0
				end
			elseif Modifier.GetName(searchMod) == "modifier_bane_fiends_grip" then
				if Modifier.GetDieTime(searchMod) - curTime >= 1.5 then
					timing = Modifier.GetCreationTime(searchMod) + 0.3
					HPtreshold = sunStrikeDMG + 2 * (45 + FAIO.GetTeammateAbilityLevel(myHero, "bane_fiends_grip") * 55)
				else
					timing = 0
					HPtreshold = 0
				end
			elseif Modifier.GetName(searchMod) == "modifier_legion_commander_duel" then
				if Modifier.GetDieTime(searchMod) - curTime >= 1.5 then
					timing = Modifier.GetCreationTime(searchMod)
					HPtreshold = sunStrikeDMG * 1.35
				else
					timing = 0
					HPtreshold = 0
				end
			elseif Modifier.GetName(searchMod) == "modifier_pudge_dismember" then
				if Modifier.GetDieTime(searchMod) - curTime >= 1.5 then
					timing = Modifier.GetCreationTime(searchMod) + 0.3
					HPtreshold = sunStrikeDMG + 2 * (22 + FAIO.GetTeammateAbilityLevel(myHero, "pudge_dismember") * 22)
				else
					timing = 0
					HPtreshold = 0
				end
			elseif Modifier.GetName(searchMod) == "modifier_crystal_maiden_frostbite" then
				if Modifier.GetDieTime(searchMod) - curTime >= 1.5 then
					timing = Modifier.GetCreationTime(searchMod) + 0.3
					HPtreshold = sunStrikeDMG + 75
				else
					timing = 0
					HPtreshold = 0
				end
			elseif Modifier.GetName(searchMod) == "modifier_ember_spirit_searing_chains" then
				if Modifier.GetDieTime(searchMod) - curTime >= 1.5 then
					timing = Modifier.GetCreationTime(searchMod) + 0.3
					HPtreshold = sunStrikeDMG + 85
				else
					timing = 0
					HPtreshold = 0
				end
			elseif Modifier.GetName(searchMod) == "modifier_eul_cyclone" then
				if Modifier.GetDieTime(searchMod) - curTime >= 1.5 then
					timing = Modifier.GetDieTime(searchMod) - 1.7 + 0.05
					HPtreshold = sunStrikeDMG - 10
				else
					timing = 0
					HPtreshold = 0
				end
			elseif Modifier.GetName(searchMod) == "modifier_obsidian_destroyer_astral_imprisonment_prison" then
				if Modifier.GetDieTime(searchMod) - curTime >= 1.5 then
					timing = Modifier.GetDieTime(searchMod) - 1.7 + 0.15
					HPtreshold = sunStrikeDMG + (25 + FAIO.GetTeammateAbilityLevel(myHero, "obsidian_destroyer_astral_imprisonment") * 75) * 0.75
				else
					timing = 0
					HPtreshold = 0
				end
			elseif Modifier.GetName(searchMod) == "modifier_shadow_demon_disruption" then
				if Modifier.GetDieTime(searchMod) - curTime >= 1.5 then
					timing = Modifier.GetDieTime(searchMod) - 1.7 + 0.1
					HPtreshold = sunStrikeDMG - 10
				else
					timing = 0
					HPtreshold = 0
				end
			elseif Modifier.GetName(searchMod) == "modifier_invoker_tornado" then
				if Modifier.GetDieTime(searchMod) - curTime >= 1.5 then
					timing = Modifier.GetDieTime(searchMod) - 1.7 + 0.05
					HPtreshold = sunStrikeDMG - 10
				else
					timing = 0
					HPtreshold = 0
				end
			elseif Modifier.GetName(searchMod) == "modifier_teleporting" then
				if Modifier.GetDieTime(searchMod) - curTime >= 1.5 then
					timing = Modifier.GetCreationTime(searchMod)
					HPtreshold = sunStrikeDMG - 10
				else
					timing = 0
					HPtreshold = 0
				end
			else
				if Modifier.GetDieTime(searchMod) - curTime >= 1.5 then
					timing = Modifier.GetCreationTime(searchMod)
					HPtreshold = sunStrikeDMG * (1 + Menu.GetValue(FAIO.optionKillStealInvokerTreshold) / 100)
				else
					timing = 0
					HPtreshold = 0
				end
			end
		else
			timing = 0
			HPtreshold = 0
		end
	else
		timing = 0
		HPtreshold = 0
	end

	return { timing, HPtreshold }

end

function FAIO.invokerSunstrikeKSParticleProcess(myHero)

	if not myHero then return false end
	if FAIO.TPParticlePosition:__tostring() == Vector(0.0, 0.0, 0.0):__tostring() then return false end
	if NPC.GetMana(myHero) < 175 then return false end	

	local sunStrike = NPC.GetAbility(myHero, "invoker_sun_strike")
	if not sunStrike or (sunStrike and not Ability.IsReady(sunStrike)) then return false end
	if not FAIO.InvokerIsAbilityInvoked(myHero, sunStrike) and not Ability.IsReady(NPC.GetAbility(myHero, "invoker_invoke")) then return false end
	
	local aghanims = NPC.GetItem(myHero, "item_ultimate_scepter", true)
	local sunStrikeDMG = 37.5 + (62.5 * Ability.GetLevel(NPC.GetAbility(myHero, "invoker_exort")))
		if aghanims or NPC.HasModifier(myHero, "modifier_item_ultimate_scepter_consumed") then
			sunStrikeDMG = 37.5 + (62.5 * (Ability.GetLevel(NPC.GetAbility(myHero, "invoker_exort")) + 1))
		end

	if FAIO.TPParticleTime > 0 and FAIO.TPParticleUnit ~= nil then
		for hero, data in pairs(FAIO.enemyHeroTable) do
			local heroHP = data[1]
			local heroHPreg = data[2]
			local timeStamp = data[3]
			if hero and Entity.IsDormant(hero) and hero == FAIO.TPParticleUnit then
				if GameRules.GetGameTime() - timeStamp <= 10 then
					if heroHP + heroHPreg * (math.ceil(GameRules.GetGameTime() - timeStamp)) <= sunStrikeDMG and heroHP > 0 then
						return true
					end
				end
			end
		end
	end
	return false

end

function FAIO.InvokerDrawShort(myHero)

	if not myHero then return end
	if not Menu.IsEnabled(FAIO.optionHeroInvoker) then return end
	if not Menu.IsEnabled(FAIO.optionHeroInvokerPanelShort) then return end
	if FAIO.Toggler then return end

	local w, h = Renderer.GetScreenSize()
	Renderer.SetDrawColor(255, 255, 255)

	local startX = w/2 + Menu.GetValue(FAIO.optionHeroInvokerPanelShortXPos)
	local startY = h/2 + Menu.GetValue(FAIO.optionHeroInvokerPanelShortYPos)

	local numberCombos = 1
	local maxSkills = 6

	local invokeTranslator = {
		"invoker_tornado",
		"invoker_emp",
		"invoker_chaos_meteor", 
		"invoker_deafening_blast",
		"invoker_sun_strike",
		"invoker_ice_wall",
		"invoker_cold_snap",
		"invoker_forge_spirit",
		"invoker_alacrity",
		"item_cyclone",
		"item_rod_of_atos",
		"item_refresher"
			}

	local imageHandleSnap = FAIO.invokerCachedIcons["invoker_cold_snap"]
	local imageHandleSunStrike = FAIO.invokerCachedIcons["invoker_sun_strike"]
	local imageHandleEmp = FAIO.invokerCachedIcons["invoker_emp"]
	local imageHandleTornado = FAIO.invokerCachedIcons["invoker_tornado"]
	local imageHandleAlacrity = FAIO.invokerCachedIcons["invoker_alacrity"]
	local imageHandleBlast = FAIO.invokerCachedIcons["invoker_deafening_blast"]
	local imageHandleMeteor = FAIO.invokerCachedIcons["invoker_chaos_meteor"]
	local imageHandleIcewall = FAIO.invokerCachedIcons["invoker_ice_wall"]
	local imageHandleSpirit = FAIO.invokerCachedIcons["invoker_forge_spirit"]
	local imageHandleGhost = FAIO.invokerCachedIcons["invoker_ghost_walk"]
	local imageHandleAgha = FAIO.invokerCachedIcons["item_ultimate_scepter"]
	local imageHandleRefresher = FAIO.invokerCachedIcons["item_refresher"]
	local imageHandleDagger = FAIO.invokerCachedIcons["item_blink"]
	local imageHandleEul = FAIO.invokerCachedIcons["item_cyclone"]
	local imageHandleAtos = FAIO.invokerCachedIcons["item_rod_of_atos"]

	local skillTranslator = {
		imageHandleTornado,
		imageHandleEmp,
		imageHandleMeteor, 
		imageHandleBlast,
		imageHandleSunStrike,
		imageHandleIcewall,
		imageHandleSnap,
		imageHandleSpirit,
		imageHandleAlacrity,
		imageHandleEul,
		imageHandleAtos,
		imageHandleRefresher
			}

		-- custom mode 1
	if FAIO.InvokerComboSelector == 12 then
		if FAIO.InvokerInvokedChecker(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill2)], invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill1)]) and Ability.IsReady(NPC.GetAbility(myHero, "invoker_invoke")) then
			Renderer.SetDrawColor(0, 205, 0, 255)
		else
			Renderer.SetDrawColor(255, 255, 0, 255)
		end
		if Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill1) > 0 then
			Renderer.DrawImage(skillTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill1)], startX+2+25*0, startY+2, 25, 25)
		end
		if Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill2) > 0 then
			Renderer.DrawImage(skillTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill2)], startX+2+25*1, startY+2, 25, 25)
		end
		if Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill3) > 0 then
			Renderer.DrawImage(skillTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill3)], startX+2+25*2, startY+2, 25, 25)
		end
		if Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill4) > 0 then
			Renderer.DrawImage(skillTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill4)], startX+2+25*3, startY+2, 25, 25)
		end
		if Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill5) > 0 then
			Renderer.DrawImage(skillTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill5)], startX+2+25*4, startY+2, 25, 25)
		end
		if Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill6) > 0 then
			Renderer.DrawImage(skillTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill6)], startX+2+25*5, startY+2, 25, 25)
		end
		Renderer.SetDrawColor(255, 255, 255, 150)
		Renderer.DrawText(FAIO.font, startX-20, startY+1, "1", 0)
	end
		-- custom mode 2
	if FAIO.InvokerComboSelector == 13 then
		if FAIO.InvokerInvokedChecker(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill2)], invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill1)]) and Ability.IsReady(NPC.GetAbility(myHero, "invoker_invoke")) then
			Renderer.SetDrawColor(0, 205, 0, 255)
		else
			Renderer.SetDrawColor(255, 255, 0, 255)
		end
		if Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill1) > 0 then
			Renderer.DrawImage(skillTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill1)], startX+2+25*0, startY+2, 25, 25)
		end
		if Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill2) > 0 then
			Renderer.DrawImage(skillTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill2)], startX+2+25*1, startY+2, 25, 25)
		end
		if Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill3) > 0 then
			Renderer.DrawImage(skillTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill3)], startX+2+25*2, startY+2, 25, 25)
		end
		if Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill4) > 0 then
			Renderer.DrawImage(skillTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill4)], startX+2+25*3, startY+2, 25, 25)
		end
		if Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill5) > 0 then
			Renderer.DrawImage(skillTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill5)], startX+2+25*4, startY+2, 25, 25)
		end
		if Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill6) > 0 then
			Renderer.DrawImage(skillTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill6)], startX+2+25*5, startY+2, 25, 25)
		end
		Renderer.SetDrawColor(255, 255, 255, 150)
		Renderer.DrawText(FAIO.font, startX-20, startY+1, "2", 0)
	end
		-- custom mode 3
	if FAIO.InvokerComboSelector == 14 then
		if FAIO.InvokerInvokedChecker(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill2)], invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill1)]) and Ability.IsReady(NPC.GetAbility(myHero, "invoker_invoke")) then
			Renderer.SetDrawColor(0, 205, 0, 255)
		else
			Renderer.SetDrawColor(255, 255, 0, 255)
		end
		if Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill1) > 0 then
			Renderer.DrawImage(skillTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill1)], startX+2+25*0, startY+2, 25, 25)
		end
		if Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill2) > 0 then
			Renderer.DrawImage(skillTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill2)], startX+2+25*1, startY+2, 25, 25)
		end
		if Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill3) > 0 then
			Renderer.DrawImage(skillTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill3)], startX+2+25*2, startY+2, 25, 25)
		end
		if Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill4) > 0 then
			Renderer.DrawImage(skillTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill4)], startX+2+25*3, startY+2, 25, 25)
		end
		if Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill5) > 0 then
			Renderer.DrawImage(skillTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill5)], startX+2+25*4, startY+2, 25, 25)
		end
		if Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill6) > 0 then
			Renderer.DrawImage(skillTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill6)], startX+2+25*5, startY+2, 25, 25)
		end
		Renderer.SetDrawColor(255, 255, 255, 150)
		Renderer.DrawText(FAIO.font, startX-20, startY+1, "3", 0)
	end

	if FAIO.InvokerComboSelector == 11 then
		Renderer.SetDrawColor(255, 255, 255, 150)
		Renderer.DrawText(FAIO.font, startX+2+25*2, startY+1, "dyn", 0)
		Renderer.SetDrawColor(0, 0, 0, 100)
		Renderer.DrawFilledRect(startX, startY, (25 * maxSkills) + 4, (25 * numberCombos) + 4)
	end

end

function FAIO.InvokerDraw(myHero)

	if not myHero then return end
	if not Menu.IsEnabled(FAIO.optionHeroInvoker) then return end

	if FAIO.invokerPanelNeedsInit then
        	FAIO.invokerPanelInit()
        	FAIO.invokerPanelNeedsInit = false
    	end

	local w, h = Renderer.GetScreenSize()
	Renderer.SetDrawColor(255, 255, 255)

	local startX = w - 300 - Menu.GetValue(FAIO.optionHeroInvokerPanelXPos)
	local startY = 300 + Menu.GetValue(FAIO.optionHeroInvokerPanelYPos)

	local numberCombos = 11
	local maxSkills = 6

	local imageSize = FAIO.invokerPanelBoxSize

	if Menu.IsKeyDownOnce(FAIO.optionHeroInvokerToggleKey) then
		FAIO.Toggler = not FAIO.Toggler
	end

	if not FAIO.Toggler then return end
		
	 -- black background
	Renderer.SetDrawColor(0, 0, 0, 150)
	Renderer.DrawFilledRect(startX, startY, (imageSize * maxSkills) + 4, ((imageSize+2) * numberCombos) + 12)
	Renderer.DrawFilledRect(startX, startY+(imageSize+2)*12+12, (imageSize * maxSkills) + 4, (imageSize+2)*3 + 4)

	-- black border
	Renderer.SetDrawColor(0, 0, 0, 255)
	Renderer.DrawOutlineRect(startX, startY, (imageSize * maxSkills) + 4, ((imageSize+2) * numberCombos) + 12)
	Renderer.DrawOutlineRect(startX, startY+(imageSize+2)*12+12, (imageSize * maxSkills) + 4, (imageSize+2)*3 + 4)

	local hoveringOverCombo1 = Input.IsCursorInRect(startX+1, startY+1+(imageSize+2)*0 + 0, (imageSize * maxSkills)+2 , (imageSize+2))
	local hoveringOverCombo2 = Input.IsCursorInRect(startX+1, startY+1+(imageSize+2)*1 + 1, (imageSize * maxSkills)+2 , (imageSize+2))
	local hoveringOverCombo3 = Input.IsCursorInRect(startX+1, startY+1+(imageSize+2)*2 + 2, (imageSize * maxSkills)+2 , (imageSize+2))
	local hoveringOverCombo4 = Input.IsCursorInRect(startX+1, startY+1+(imageSize+2)*3 + 3, (imageSize * maxSkills)+2 , (imageSize+2))
	local hoveringOverCombo5 = Input.IsCursorInRect(startX+1, startY+1+(imageSize+2)*4 + 4, (imageSize * maxSkills)+2 , (imageSize+2))
	local hoveringOverCombo6 = Input.IsCursorInRect(startX+1, startY+1+(imageSize+2)*5 + 5, (imageSize * maxSkills)+2 , (imageSize+2))
	local hoveringOverCombo7 = Input.IsCursorInRect(startX+1, startY+1+(imageSize+2)*6 + 6, (imageSize * maxSkills)+2 , (imageSize+2))
	local hoveringOverCombo8 = Input.IsCursorInRect(startX+1, startY+1+(imageSize+2)*7 + 7, (imageSize * maxSkills)+2 , (imageSize+2))
	local hoveringOverCombo9 = Input.IsCursorInRect(startX+1, startY+1+(imageSize+2)*8 + 8, (imageSize * maxSkills)+2 , (imageSize+2))
	local hoveringOverCombo10 = Input.IsCursorInRect(startX+1, startY+1+(imageSize+2)*9 + 9, (imageSize * maxSkills)+2 , (imageSize+2))
	local hoveringOverCombo11 = Input.IsCursorInRect(startX+1, startY+1+(imageSize+2)*10 + 10, (imageSize * maxSkills)+2 , (imageSize+2))
	local hoveringOverCombo12 = Input.IsCursorInRect(startX+1, startY+1+(imageSize+2)*12 + 12, (imageSize * maxSkills)+2 , (imageSize+2))
	local hoveringOverCombo13 = Input.IsCursorInRect(startX+1, startY+1+(imageSize+2)*13 + 13, (imageSize * maxSkills)+2 , (imageSize+2))
	local hoveringOverCombo14 = Input.IsCursorInRect(startX+1, startY+1+(imageSize+2)*14 + 14, (imageSize * maxSkills)+2 , (imageSize+2))

	local sunStrike = NPC.GetAbility(myHero, "invoker_sun_strike")
	local emp = NPC.GetAbility(myHero, "invoker_emp")
	local tornado = NPC.GetAbility(myHero, "invoker_tornado")
	local deafeningBlast = NPC.GetAbility(myHero, "invoker_deafening_blast")
	local chaosMeteor = NPC.GetAbility(myHero, "invoker_chaos_meteor")
	local coldSnap = NPC.GetAbility(myHero, "invoker_cold_snap")
	local forgeSpirit = NPC.GetAbility(myHero, "invoker_forge_spirit")
	local alacrity = NPC.GetAbility(myHero, "invoker_alacrity")
	local iceWall = NPC.GetAbility(myHero, "invoker_ice_wall")
	local euls = NPC.GetItem(myHero, "item_cyclone", true)
	local refresher = NPC.GetItem(myHero, "item_refresher", true)

	local invokeTranslator = {
		"invoker_tornado",
		"invoker_emp",
		"invoker_chaos_meteor", 
		"invoker_deafening_blast",
		"invoker_sun_strike",
		"invoker_ice_wall",
		"invoker_cold_snap",
		"invoker_forge_spirit",
		"invoker_alacrity",
		"item_cyclone",
		"item_rod_of_atos",
		"item_refresher"
			}

	if hoveringOverCombo1 and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) then
		if Menu.IsEnabled(FAIO.optionHeroInvokerAutoInvoke) then
			if FAIO.InvokerComboSelector ~= 1 then
				FAIO.PreInvokeSkills = {{coldSnap, forgeSpirit}}
				FAIO.InvokerComboSelector = 1
			else
				FAIO.InvokerComboSelector = 0
			end
		else
			if FAIO.InvokerComboSelector ~= 1 then
				FAIO.InvokerComboSelector = 1
			else
				FAIO.InvokerComboSelector = 0
			end
		end
	elseif hoveringOverCombo2 and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) then
		if Menu.IsEnabled(FAIO.optionHeroInvokerAutoInvoke) then
			if FAIO.InvokerComboSelector ~= 2 then
				FAIO.PreInvokeSkills = {{coldSnap, forgeSpirit}}
				FAIO.InvokerComboSelector = 2
			else
				FAIO.InvokerComboSelector = 0
			end
		else
			if FAIO.InvokerComboSelector ~= 2 then
				FAIO.InvokerComboSelector = 2
			else
				FAIO.InvokerComboSelector = 0
			end
		end
	elseif hoveringOverCombo3 and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) then
		if Menu.IsEnabled(FAIO.optionHeroInvokerAutoInvoke) then
			if FAIO.InvokerComboSelector ~= 3 then
				FAIO.PreInvokeSkills = {{emp, tornado}}
				FAIO.InvokerComboSelector = 3
			else
				FAIO.InvokerComboSelector = 0
			end
		else
			if FAIO.InvokerComboSelector ~= 3 then
				FAIO.InvokerComboSelector = 3
			else
				FAIO.InvokerComboSelector = 0
			end
		end
	elseif hoveringOverCombo4 and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) then
		if Menu.IsEnabled(FAIO.optionHeroInvokerAutoInvoke) then
			if FAIO.InvokerComboSelector ~= 4 then
				FAIO.PreInvokeSkills = {{chaosMeteor, tornado}}
				FAIO.InvokerComboSelector = 4
			else
				FAIO.InvokerComboSelector = 0
			end
		else
			if FAIO.InvokerComboSelector ~= 4 then
				FAIO.InvokerComboSelector = 4
			else
				FAIO.InvokerComboSelector = 0
			end
		end
	elseif hoveringOverCombo5 and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) then
		if Menu.IsEnabled(FAIO.optionHeroInvokerAutoInvoke) then
			if FAIO.InvokerComboSelector ~= 5 then
				FAIO.PreInvokeSkills = {{chaosMeteor, sunStrike}}
				FAIO.InvokerComboSelector = 5
			else
				FAIO.InvokerComboSelector = 0
			end
		else
			if FAIO.InvokerComboSelector ~= 5 then
				FAIO.InvokerComboSelector = 5
			else
				FAIO.InvokerComboSelector = 0
			end
		end
	elseif hoveringOverCombo6 and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) then
		if Menu.IsEnabled(FAIO.optionHeroInvokerAutoInvoke) then
			if FAIO.InvokerComboSelector ~= 6 then
				FAIO.PreInvokeSkills = {{emp, tornado}}
				FAIO.InvokerComboSelector = 6
			else
				FAIO.InvokerComboSelector = 0
			end
		else
			if FAIO.InvokerComboSelector ~= 6 then
				FAIO.InvokerComboSelector = 6
			else
				FAIO.InvokerComboSelector = 0
			end
		end
	elseif hoveringOverCombo7 and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) then
		if Menu.IsEnabled(FAIO.optionHeroInvokerAutoInvoke) then
			if FAIO.InvokerComboSelector ~= 7 then
				FAIO.PreInvokeSkills = {{sunStrike, tornado}}
				FAIO.InvokerComboSelector = 7
			else
				FAIO.InvokerComboSelector = 0
			end
		else
			if FAIO.InvokerComboSelector ~= 7 then
				FAIO.InvokerComboSelector = 7
			else
				FAIO.InvokerComboSelector = 0
			end
		end
	elseif hoveringOverCombo8 and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) then
		if Menu.IsEnabled(FAIO.optionHeroInvokerAutoInvoke) then
			if FAIO.InvokerComboSelector ~= 8 then
				FAIO.PreInvokeSkills = {{sunStrike, tornado}}
				FAIO.InvokerComboSelector = 8
			else
				FAIO.InvokerComboSelector = 0
			end
		else
			if FAIO.InvokerComboSelector ~= 8 then
				FAIO.InvokerComboSelector = 8
			else
				FAIO.InvokerComboSelector = 0
			end
		end
	elseif hoveringOverCombo9 and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) then
		if Menu.IsEnabled(FAIO.optionHeroInvokerAutoInvoke) then
			if FAIO.InvokerComboSelector ~= 9 then
				FAIO.PreInvokeSkills = {{emp, tornado}}
				FAIO.InvokerComboSelector = 9
			else
				FAIO.InvokerComboSelector = 0
			end
		else
			if FAIO.InvokerComboSelector ~= 9 then
				FAIO.InvokerComboSelector = 9
			else
				FAIO.InvokerComboSelector = 0
			end
		end
	elseif hoveringOverCombo10 and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) then
		if Menu.IsEnabled(FAIO.optionHeroInvokerAutoInvoke) then
			if FAIO.InvokerComboSelector ~= 10 then
				FAIO.PreInvokeSkills = {{deafeningBlast, chaosMeteor}}
				FAIO.InvokerComboSelector = 10
			else
				FAIO.InvokerComboSelector = 0
			end
		else
			if FAIO.InvokerComboSelector ~= 10 then
				FAIO.InvokerComboSelector = 10
			else
				FAIO.InvokerComboSelector = 0
			end
		end
	elseif hoveringOverCombo11 and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) then
		if FAIO.InvokerComboSelector ~= 11 then
			FAIO.InvokerComboSelector = 11
		else
			FAIO.InvokerComboSelector = 0
		end
	elseif hoveringOverCombo12 and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) then
		if Menu.IsEnabled(FAIO.optionHeroInvokerAutoInvoke) then
			if FAIO.InvokerComboSelector ~= 12 then
				if Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill1) > 0 and Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill2) > 0 then
					if Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill1) > 9 and Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill2) <= 9 then
						FAIO.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill3)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill2)])}}
						FAIO.InvokerComboSelector = 12
					elseif Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill1) <= 9 and Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill2) > 9 then
						FAIO.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill3)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill1)])}}
						FAIO.InvokerComboSelector = 12
					elseif Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill1) > 9 and Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill2) > 9 then
						FAIO.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill4)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill3)])}}
						FAIO.InvokerComboSelector = 12
					else
						FAIO.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill2)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill1)])}}
						FAIO.InvokerComboSelector = 12
					end
				else
					FAIO.InvokerComboSelector = 0
				end	
			else
				FAIO.InvokerComboSelector = 0
			end
		else
			if FAIO.InvokerComboSelector ~= 12 then
				FAIO.InvokerComboSelector = 12
			else
				FAIO.InvokerComboSelector = 0
			end
		end
	elseif hoveringOverCombo13 and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) then
		if Menu.IsEnabled(FAIO.optionHeroInvokerAutoInvoke) then
			if FAIO.InvokerComboSelector ~= 13 then
				if Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill1) > 0 and Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill2) > 0 then
					if Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill1) > 9 and Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill2) <= 9 then
						FAIO.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill3)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill2)])}}
						FAIO.InvokerComboSelector = 13
					elseif Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill1) <= 9 and Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill2) > 9 then
						FAIO.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill3)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill1)])}}
						FAIO.InvokerComboSelector = 13
					elseif Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill1) > 9 and Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill2) > 9 then
						FAIO.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill4)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill3)])}}
						FAIO.InvokerComboSelector = 13
					else
						FAIO.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill2)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill1)])}}
						FAIO.InvokerComboSelector = 13
					end
				else
					FAIO.InvokerComboSelector = 0
				end	
			else
				FAIO.InvokerComboSelector = 0
			end
		else
			if FAIO.InvokerComboSelector ~= 13 then
				FAIO.InvokerComboSelector = 13
			else
				FAIO.InvokerComboSelector = 0
			end
		end
	elseif hoveringOverCombo14 and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) then
		if Menu.IsEnabled(FAIO.optionHeroInvokerAutoInvoke) then
			if FAIO.InvokerComboSelector ~= 14 then
				if Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill1) > 0 and Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill2) > 0 then
					if Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill1) > 9 and Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill2) <= 9 then
						FAIO.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill3)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill2)])}}
						FAIO.InvokerComboSelector = 14
					elseif Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill1) <= 9 and Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill2) > 9 then
						FAIO.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill3)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill1)])}}
						FAIO.InvokerComboSelector = 14
					elseif Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill1) > 9 and Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill2) > 9 then
						FAIO.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill4)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill3)])}}
						FAIO.InvokerComboSelector = 14
					else
						FAIO.PreInvokeSkills = {{NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill2)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill1)])}}
						FAIO.InvokerComboSelector = 14
					end
				else
					FAIO.InvokerComboSelector = 0
				end	
			else
				FAIO.InvokerComboSelector = 0
			end
		else
			if FAIO.InvokerComboSelector ~= 14 then
				FAIO.InvokerComboSelector = 14
			else
				FAIO.InvokerComboSelector = 0
			end
		end
	end

	-- border
	if FAIO.InvokerComboSelector == 1 then
		Renderer.SetDrawColor(0, 255, 0, 255)
		Renderer.DrawOutlineRect(startX+1, startY+1+(imageSize+2)*0 + 0, (imageSize * maxSkills)+2 , (imageSize+2))
	end
	if FAIO.InvokerComboSelector == 2 then
		Renderer.SetDrawColor(0, 255, 0, 255)
		Renderer.DrawOutlineRect(startX+1, startY+1+(imageSize+2)*1 + 1, (imageSize * maxSkills)+2 , (imageSize+2))
	end
	if FAIO.InvokerComboSelector == 3 then
		Renderer.SetDrawColor(0, 255, 0, 255)
		Renderer.DrawOutlineRect(startX+1, startY+1+(imageSize+2)*2 + 2, (imageSize * maxSkills)+2 , (imageSize+2))
	end
	if FAIO.InvokerComboSelector == 4 then
		Renderer.SetDrawColor(0, 255, 0, 255)
		Renderer.DrawOutlineRect(startX+1, startY+1+(imageSize+2)*3 + 3, (imageSize * maxSkills)+2 , (imageSize+2))
	end
	if FAIO.InvokerComboSelector == 5 then
		Renderer.SetDrawColor(0, 255, 0, 255)
		Renderer.DrawOutlineRect(startX+1, startY+1+(imageSize+2)*4 + 4, (imageSize * maxSkills)+2 , (imageSize+2))
	end
	if FAIO.InvokerComboSelector == 6 then
		Renderer.SetDrawColor(0, 255, 0, 255)
		Renderer.DrawOutlineRect(startX+1, startY+1+(imageSize+2)*5 + 5, (imageSize * maxSkills)+2 , (imageSize+2))
	end
	if FAIO.InvokerComboSelector == 7 then
		Renderer.SetDrawColor(0, 255, 0, 255)
		Renderer.DrawOutlineRect(startX+1, startY+1+(imageSize+2)*6 + 6, (imageSize * maxSkills)+2 , (imageSize+2))
	end
	if FAIO.InvokerComboSelector == 8 then
		Renderer.SetDrawColor(0, 255, 0, 255)
		Renderer.DrawOutlineRect(startX+1, startY+1+(imageSize+2)*7 + 7, (imageSize * maxSkills)+2 , (imageSize+2))
	end
	if FAIO.InvokerComboSelector == 9 then
		Renderer.SetDrawColor(0, 255, 0, 255)
		Renderer.DrawOutlineRect(startX+1, startY+1+(imageSize+2)*8 + 8, (imageSize * maxSkills)+2 , (imageSize+2))
	end
	if FAIO.InvokerComboSelector == 10 then
		Renderer.SetDrawColor(0, 255, 0, 255)
		Renderer.DrawOutlineRect(startX+1, startY+1+(imageSize+2)*9 + 9, (imageSize * maxSkills)+2 , (imageSize+2))
	end
	if FAIO.InvokerComboSelector == 11 then
		Renderer.SetDrawColor(0, 255, 0, 255)
		Renderer.DrawOutlineRect(startX+1, startY+1+(imageSize+2)*10 + 10, (imageSize * maxSkills)+2 , (imageSize+2))
	end
	if FAIO.InvokerComboSelector == 12 then
		Renderer.SetDrawColor(0, 255, 0, 255)
		Renderer.DrawOutlineRect(startX+1, startY+1+(imageSize+2)*12 + 12, (imageSize * maxSkills)+2 , (imageSize+2))
	end
	if FAIO.InvokerComboSelector == 13 then
		Renderer.SetDrawColor(0, 255, 0, 255)
		Renderer.DrawOutlineRect(startX+1, startY+1+(imageSize+2)*13 + 13, (imageSize * maxSkills)+2 , (imageSize+2))
	end
	if FAIO.InvokerComboSelector == 14 then
		Renderer.SetDrawColor(0, 255, 0, 255)
		Renderer.DrawOutlineRect(startX+1, startY+1+(imageSize+2)*14 + 14, (imageSize * maxSkills)+2 , (imageSize+2))
	end

	local imageHandleSnap = FAIO.invokerCachedIcons["invoker_cold_snap"]
	local imageHandleSunStrike = FAIO.invokerCachedIcons["invoker_sun_strike"]
	local imageHandleEmp = FAIO.invokerCachedIcons["invoker_emp"]
	local imageHandleTornado = FAIO.invokerCachedIcons["invoker_tornado"]
	local imageHandleAlacrity = FAIO.invokerCachedIcons["invoker_alacrity"]
	local imageHandleBlast = FAIO.invokerCachedIcons["invoker_deafening_blast"]
	local imageHandleMeteor = FAIO.invokerCachedIcons["invoker_chaos_meteor"]
	local imageHandleIcewall = FAIO.invokerCachedIcons["invoker_ice_wall"]
	local imageHandleSpirit = FAIO.invokerCachedIcons["invoker_forge_spirit"]
	local imageHandleGhost = FAIO.invokerCachedIcons["invoker_ghost_walk"]
	local imageHandleAgha = FAIO.invokerCachedIcons["item_ultimate_scepter"]
	local imageHandleRefresher = FAIO.invokerCachedIcons["item_refresher"]
	local imageHandleDagger = FAIO.invokerCachedIcons["item_blink"]
	local imageHandleEul = FAIO.invokerCachedIcons["item_cyclone"]
	local imageHandleAtos = FAIO.invokerCachedIcons["item_rod_of_atos"]

	

	-- combo CS, Forge, Alacrity
	if FAIO.InvokerComboSelector == 1 then
		if FAIO.InvokerInvokedChecker(myHero, "invoker_cold_snap", "invoker_forge_spirit") and Ability.IsReady(NPC.GetAbility(myHero, "invoker_invoke")) then
			Renderer.SetDrawColor(0, 205, 0, 255)
		else
			Renderer.SetDrawColor(255, 255, 0, 255)
		end
	else	
		Renderer.SetDrawColor(255, 255, 255, 150)
	end
	Renderer.DrawImage(imageHandleSnap, startX+2+imageSize*0, startY+2, imageSize, imageSize)
		if Menu.GetValue(FAIO.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(coldSnap) > 0 then
				Renderer.DrawText(FAIO.invokerPanelFont, startX+2+imageSize*0+4, startY+2+4, math.floor(Ability.GetCooldownTimeLeft(coldSnap)), 0)
			end
		end
	Renderer.DrawImage(imageHandleSpirit, startX+2+imageSize*1, startY+2, imageSize, imageSize)
		if Menu.GetValue(FAIO.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(forgeSpirit) > 0 then
				Renderer.DrawText(FAIO.invokerPanelFont, startX+2+imageSize*1+4, startY+2+4, math.floor(Ability.GetCooldownTimeLeft(forgeSpirit)), 0)
			end
		end
	Renderer.DrawImage(imageHandleAlacrity, startX+2+imageSize*2, startY+2, imageSize, imageSize)
		if Menu.GetValue(FAIO.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(alacrity) > 0 then
				Renderer.DrawText(FAIO.invokerPanelFont, startX+2+imageSize*2+4, startY+2+4, math.floor(Ability.GetCooldownTimeLeft(alacrity)), 0)
			end
		end

	-- combo CS, Forge, SS
	if FAIO.InvokerComboSelector == 2 then
		if FAIO.InvokerInvokedChecker(myHero, "invoker_cold_snap", "invoker_forge_spirit") and Ability.IsReady(NPC.GetAbility(myHero, "invoker_invoke")) then
			Renderer.SetDrawColor(0, 205, 0, 255)
		else
			Renderer.SetDrawColor(255, 255, 0, 255)
		end
	else	
		Renderer.SetDrawColor(255, 255, 255, 150)
	end
	Renderer.DrawImage(imageHandleSnap, startX+2+imageSize*0, startY+3+(imageSize+2)*1, imageSize, imageSize)
		if Menu.GetValue(FAIO.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(coldSnap) > 0 then
				Renderer.DrawText(FAIO.invokerPanelFont, startX+2+imageSize*0+4, startY+3+(imageSize+2)*1+4, math.floor(Ability.GetCooldownTimeLeft(coldSnap)), 0)
			end
		end
	Renderer.DrawImage(imageHandleSpirit, startX+2+imageSize*1, startY+3+(imageSize+2)*1, imageSize, imageSize)
		if Menu.GetValue(FAIO.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(forgeSpirit) > 0 then
				Renderer.DrawText(FAIO.invokerPanelFont, startX+2+imageSize*1+4, startY+3+(imageSize+2)*1+4, math.floor(Ability.GetCooldownTimeLeft(forgeSpirit)), 0)
			end
		end
	Renderer.DrawImage(imageHandleSunStrike, startX+2+imageSize*2, startY+3+(imageSize+2)*1, imageSize, imageSize)
		if Menu.GetValue(FAIO.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(sunStrike) > 0 then
				Renderer.DrawText(FAIO.invokerPanelFont, startX+2+imageSize*2+4, startY+3+(imageSize+2)*1+4, math.floor(Ability.GetCooldownTimeLeft(sunStrike)), 0)
			end
		end

	-- combo Tornado, EMP, Icewall
	if FAIO.InvokerComboSelector == 3 then
		if FAIO.InvokerInvokedChecker(myHero, "invoker_emp", "invoker_tornado") and Ability.IsReady(NPC.GetAbility(myHero, "invoker_invoke")) then
			Renderer.SetDrawColor(0, 205, 0, 255)
		else
			Renderer.SetDrawColor(255, 255, 0, 255)
		end
	else	
		Renderer.SetDrawColor(255, 255, 255, 150)
	end
	Renderer.DrawImage(imageHandleTornado, startX+2+imageSize*0, startY+4+(imageSize+2)*2, imageSize, imageSize)
		if Menu.GetValue(FAIO.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(tornado) > 0 then
				Renderer.DrawText(FAIO.invokerPanelFont, startX+2+imageSize*0+4, startY+4+(imageSize+2)*2+4, math.floor(Ability.GetCooldownTimeLeft(tornado)), 0)
			end
		end
	Renderer.DrawImage(imageHandleEmp, startX+2+imageSize*1, startY+4+(imageSize+2)*2, imageSize, imageSize)
		if Menu.GetValue(FAIO.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(emp) > 0 then
				Renderer.DrawText(FAIO.invokerPanelFont, startX+2+imageSize*1+4, startY+4+(imageSize+2)*2+4, math.floor(Ability.GetCooldownTimeLeft(emp)), 0)
			end
		end
	Renderer.DrawImage(imageHandleIcewall, startX+2+imageSize*2, startY+4+(imageSize+2)*2, imageSize, imageSize)
		if Menu.GetValue(FAIO.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(iceWall) > 0 then
				Renderer.DrawText(FAIO.invokerPanelFont, startX+2+imageSize*2+4, startY+4+(imageSize+2)*2+4, math.floor(Ability.GetCooldownTimeLeft(iceWall)), 0)
			end
		end
	Renderer.DrawText(FAIO.invokerPanelFont, startX+math.floor(imageSize/3)+imageSize*3, startY+4+(imageSize+2)*2+math.floor(imageSize/5), "or", 1)
	Renderer.DrawImage(imageHandleSnap, startX+2+imageSize*4, startY+4+(imageSize+2)*2, imageSize, imageSize)
		if Menu.GetValue(FAIO.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(coldSnap) > 0 then
				Renderer.DrawText(FAIO.invokerPanelFont, startX+2+imageSize*4+4, startY+4+(imageSize+2)*2+4, math.floor(Ability.GetCooldownTimeLeft(coldSnap)), 0)
			end
		end

	-- combo Tornado, Meteor, Blast
	if FAIO.InvokerComboSelector == 4 then
		if FAIO.InvokerInvokedChecker(myHero, "invoker_chaos_meteor", "invoker_tornado") and Ability.IsReady(NPC.GetAbility(myHero, "invoker_invoke")) then
			Renderer.SetDrawColor(0, 205, 0, 255)
		else
			Renderer.SetDrawColor(255, 255, 0, 255)
		end
	else	
		Renderer.SetDrawColor(255, 255, 255, 150)
	end
	Renderer.DrawImage(imageHandleTornado, startX+2+imageSize*0, startY+5+(imageSize+2)*3, imageSize, imageSize)
		if Menu.GetValue(FAIO.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(tornado) > 0 then
				Renderer.DrawText(FAIO.invokerPanelFont, startX+2+imageSize*0+4, startY+5+(imageSize+2)*3+4, math.floor(Ability.GetCooldownTimeLeft(tornado)), 0)
			end
		end
	Renderer.DrawImage(imageHandleMeteor, startX+2+imageSize*1, startY+5+(imageSize+2)*3, imageSize, imageSize)
		if Menu.GetValue(FAIO.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(chaosMeteor) > 0 then
				Renderer.DrawText(FAIO.invokerPanelFont, startX+2+imageSize*1+4, startY+5+(imageSize+2)*3+4, math.floor(Ability.GetCooldownTimeLeft(chaosMeteor)), 0)
			end
		end
	Renderer.DrawImage(imageHandleBlast, startX+2+imageSize*2, startY+5+(imageSize+2)*3, imageSize, imageSize)
		if Menu.GetValue(FAIO.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(deafeningBlast) > 0 then
				Renderer.DrawText(FAIO.invokerPanelFont, startX+2+imageSize*2+4, startY+5+(imageSize+2)*3+4, math.floor(Ability.GetCooldownTimeLeft(deafeningBlast)), 0)
			end
		end

	-- combo Eul, Sunstrike, Meteor, Blast
	if FAIO.InvokerComboSelector == 5 then
		if FAIO.InvokerInvokedChecker(myHero, "invoker_chaos_meteor", "invoker_sun_strike") and Ability.IsReady(NPC.GetAbility(myHero, "invoker_invoke")) then
			Renderer.SetDrawColor(0, 205, 0, 255)
		else
			Renderer.SetDrawColor(255, 255, 0, 255)
		end
	else	
		Renderer.SetDrawColor(255, 255, 255, 150)
	end
	Renderer.DrawImage(imageHandleEul, startX+2+imageSize*0, startY+6+(imageSize+2)*4, imageSize, imageSize)
	Renderer.DrawImage(imageHandleSunStrike, startX+2+imageSize*1, startY+6+(imageSize+2)*4, imageSize, imageSize)
		if Menu.GetValue(FAIO.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(sunStrike) > 0 then
				Renderer.DrawText(FAIO.invokerPanelFont, startX+2+imageSize*1+4, startY+6+(imageSize+2)*4+4, math.floor(Ability.GetCooldownTimeLeft(sunStrike)), 0)
			end
		end
	Renderer.DrawImage(imageHandleMeteor, startX+2+imageSize*2, startY+6+(imageSize+2)*4, imageSize, imageSize)
		if Menu.GetValue(FAIO.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(chaosMeteor) > 0 then
				Renderer.DrawText(FAIO.invokerPanelFont, startX+2+imageSize*2+4, startY+6+(imageSize+2)*4+4, math.floor(Ability.GetCooldownTimeLeft(chaosMeteor)), 0)
			end
		end
	Renderer.DrawImage(imageHandleBlast, startX+2+imageSize*3, startY+6+(imageSize+2)*4, imageSize, imageSize)
		if Menu.GetValue(FAIO.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(deafeningBlast) > 0 then
				Renderer.DrawText(FAIO.invokerPanelFont, startX+2+imageSize*3+4, startY+6+(imageSize+2)*4+4, math.floor(Ability.GetCooldownTimeLeft(deafeningBlast)), 0)
			end
		end

	-- combo Tornado, EMP, Meteor, Blast
	if FAIO.InvokerComboSelector == 6 then
		if FAIO.InvokerInvokedChecker(myHero, "invoker_emp", "invoker_tornado") and Ability.IsReady(NPC.GetAbility(myHero, "invoker_invoke")) then
			Renderer.SetDrawColor(0, 205, 0, 255)
		else
			Renderer.SetDrawColor(255, 255, 0, 255)
		end
	else	
		Renderer.SetDrawColor(255, 255, 255, 150)
	end
	Renderer.DrawImage(imageHandleAgha, startX+2+imageSize*0, startY+7+(imageSize+2)*5, imageSize, imageSize)
	Renderer.DrawImage(imageHandleTornado, startX+2+imageSize*1, startY+7+(imageSize+2)*5, imageSize, imageSize)
		if Menu.GetValue(FAIO.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(tornado) > 0 then
				Renderer.DrawText(FAIO.invokerPanelFont, startX+2+imageSize*1+4, startY+7+(imageSize+2)*5+4, math.floor(Ability.GetCooldownTimeLeft(tornado)), 0)
			end
		end
	Renderer.DrawImage(imageHandleEmp, startX+2+imageSize*2, startY+7+(imageSize+2)*5, imageSize, imageSize)
		if Menu.GetValue(FAIO.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(emp) > 0 then
				Renderer.DrawText(FAIO.invokerPanelFont, startX+2+imageSize*2+4, startY+7+(imageSize+2)*5+4, math.floor(Ability.GetCooldownTimeLeft(emp)), 0)
			end
		end
	Renderer.DrawImage(imageHandleMeteor, startX+2+imageSize*3, startY+7+(imageSize+2)*5, imageSize, imageSize)
		if Menu.GetValue(FAIO.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(chaosMeteor) > 0 then
				Renderer.DrawText(FAIO.invokerPanelFont, startX+2+imageSize*3+4, startY+7+(imageSize+2)*5+4, math.floor(Ability.GetCooldownTimeLeft(chaosMeteor)), 0)
			end
		end
	Renderer.DrawImage(imageHandleBlast, startX+2+imageSize*4, startY+7+(imageSize+2)*5, imageSize, imageSize)
		if Menu.GetValue(FAIO.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(deafeningBlast) > 0 then
				Renderer.DrawText(FAIO.invokerPanelFont, startX+2+imageSize*4+4, startY+7+(imageSize+2)*5+4, math.floor(Ability.GetCooldownTimeLeft(deafeningBlast)), 0)
			end
		end

	-- combo Tornado, Sunstrike, Meteor, Blast
	if FAIO.InvokerComboSelector == 7 then
		if FAIO.InvokerInvokedChecker(myHero, "invoker_sun_strike", "invoker_tornado") and Ability.IsReady(NPC.GetAbility(myHero, "invoker_invoke")) then
			Renderer.SetDrawColor(0, 205, 0, 255)
		else
			Renderer.SetDrawColor(255, 255, 0, 255)
		end
	else	
		Renderer.SetDrawColor(255, 255, 255, 150)
	end
	Renderer.DrawImage(imageHandleAgha, startX+2+imageSize*0, startY+8+(imageSize+2)*6, imageSize, imageSize)
	Renderer.DrawImage(imageHandleTornado, startX+2+imageSize*1, startY+8+(imageSize+2)*6, imageSize, imageSize)
		if Menu.GetValue(FAIO.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(tornado) > 0 then
				Renderer.DrawText(FAIO.invokerPanelFont, startX+2+imageSize*1+4, startY+8+(imageSize+2)*6+4, math.floor(Ability.GetCooldownTimeLeft(tornado)), 0)
			end
		end
	Renderer.DrawImage(imageHandleSunStrike, startX+2+imageSize*2, startY+8+(imageSize+2)*6, imageSize, imageSize)
		if Menu.GetValue(FAIO.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(sunStrike) > 0 then
				Renderer.DrawText(FAIO.invokerPanelFont, startX+2+imageSize*2+4, startY+8+(imageSize+2)*6+4, math.floor(Ability.GetCooldownTimeLeft(sunStrike)), 0)
			end
		end
	Renderer.DrawImage(imageHandleMeteor, startX+2+imageSize*3, startY+8+(imageSize+2)*6, imageSize, imageSize)
		if Menu.GetValue(FAIO.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(chaosMeteor) > 0 then
				Renderer.DrawText(FAIO.invokerPanelFont, startX+2+imageSize*3+4, startY+8+(imageSize+2)*6+4, math.floor(Ability.GetCooldownTimeLeft(chaosMeteor)), 0)
			end
		end
	Renderer.DrawImage(imageHandleBlast, startX+2+imageSize*4, startY+8+(imageSize+2)*6, imageSize, imageSize)
		if Menu.GetValue(FAIO.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(deafeningBlast) > 0 then
				Renderer.DrawText(FAIO.invokerPanelFont, startX+2+imageSize*4+4, startY+8+(imageSize+2)*6+4, math.floor(Ability.GetCooldownTimeLeft(deafeningBlast)), 0)
			end
		end

	-- combo Tornado, Sunstrike, Meteor, Blast, Refresher
	if FAIO.InvokerComboSelector == 8 then
		if FAIO.InvokerInvokedChecker(myHero, "invoker_sun_strike", "invoker_tornado") and Ability.IsReady(NPC.GetAbility(myHero, "invoker_invoke")) then
			Renderer.SetDrawColor(0, 205, 0, 255)
		else
			Renderer.SetDrawColor(255, 255, 0, 255)
		end
	else	
		Renderer.SetDrawColor(255, 255, 255, 150)
	end
	Renderer.DrawImage(imageHandleRefresher, startX+2+imageSize*0, startY+9+(imageSize+2)*7, imageSize, imageSize)
	Renderer.DrawImage(imageHandleAgha, startX+2+imageSize*1, startY+9+(imageSize+2)*7, imageSize, imageSize)
	Renderer.DrawImage(imageHandleTornado, startX+2+imageSize*2, startY+9+(imageSize+2)*7, imageSize, imageSize)
		if Menu.GetValue(FAIO.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(tornado) > 0 then
				Renderer.DrawText(FAIO.invokerPanelFont, startX+2+imageSize*2+4, startY+9+(imageSize+2)*7+4, math.floor(Ability.GetCooldownTimeLeft(tornado)), 0)
			end
		end
	Renderer.DrawImage(imageHandleSunStrike, startX+2+imageSize*3, startY+9+(imageSize+2)*7, imageSize, imageSize)
		if Menu.GetValue(FAIO.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(sunStrike) > 0 then
				Renderer.DrawText(FAIO.invokerPanelFont, startX+2+imageSize*3+4, startY+9+(imageSize+2)*7+4, math.floor(Ability.GetCooldownTimeLeft(sunStrike)), 0)
			end
		end
	Renderer.DrawImage(imageHandleMeteor, startX+2+imageSize*4, startY+9+(imageSize+2)*7, imageSize, imageSize)
		if Menu.GetValue(FAIO.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(chaosMeteor) > 0 then
				Renderer.DrawText(FAIO.invokerPanelFont, startX+2+imageSize*4+4, startY+9+(imageSize+2)*7+4, math.floor(Ability.GetCooldownTimeLeft(chaosMeteor)), 0)
			end
		end
	Renderer.DrawImage(imageHandleBlast, startX+2+imageSize*5, startY+9+(imageSize+2)*7, imageSize, imageSize)
		if Menu.GetValue(FAIO.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(deafeningBlast) > 0 then
				Renderer.DrawText(FAIO.invokerPanelFont, startX+2+imageSize*5+4, startY+9+(imageSize+2)*7+4, math.floor(Ability.GetCooldownTimeLeft(deafeningBlast)), 0)
			end
		end

	-- combo Tornado, Sunstrike, Meteor, Blast, Refresher
	if FAIO.InvokerComboSelector == 9 then
		if FAIO.InvokerInvokedChecker(myHero, "invoker_emp", "invoker_tornado") and Ability.IsReady(NPC.GetAbility(myHero, "invoker_invoke")) then
			Renderer.SetDrawColor(0, 205, 0, 255)
		else
			Renderer.SetDrawColor(255, 255, 0, 255)
		end
	else	
		Renderer.SetDrawColor(255, 255, 255, 150)
	end
	Renderer.DrawImage(imageHandleRefresher, startX+2+imageSize*0, startY+10+(imageSize+2)*8, imageSize, imageSize)
	Renderer.DrawImage(imageHandleAgha, startX+2+imageSize*1, startY+10+(imageSize+2)*8, imageSize, imageSize)
	Renderer.DrawImage(imageHandleTornado, startX+2+imageSize*2, startY+10+(imageSize+2)*8, imageSize, imageSize)
		if Menu.GetValue(FAIO.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(tornado) > 0 then
				Renderer.DrawText(FAIO.invokerPanelFont, startX+2+imageSize*2+4, startY+10+(imageSize+2)*8+4, math.floor(Ability.GetCooldownTimeLeft(tornado)), 0)
			end
		end
	Renderer.DrawImage(imageHandleEmp, startX+2+imageSize*3, startY+10+(imageSize+2)*8, imageSize, imageSize)
		if Menu.GetValue(FAIO.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(emp) > 0 then
				Renderer.DrawText(FAIO.invokerPanelFont, startX+2+imageSize*3+4, startY+10+(imageSize+2)*8+4, math.floor(Ability.GetCooldownTimeLeft(emp)), 0)
			end
		end
	Renderer.DrawImage(imageHandleMeteor, startX+2+imageSize*4, startY+10+(imageSize+2)*8, imageSize, imageSize)
		if Menu.GetValue(FAIO.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(chaosMeteor) > 0 then
				Renderer.DrawText(FAIO.invokerPanelFont, startX+2+imageSize*4+4, startY+10+(imageSize+2)*8+4, math.floor(Ability.GetCooldownTimeLeft(chaosMeteor)), 0)
			end
		end
	Renderer.DrawImage(imageHandleBlast, startX+2+imageSize*5, startY+10+(imageSize+2)*8, imageSize, imageSize)
		if Menu.GetValue(FAIO.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(deafeningBlast) > 0 then
				Renderer.DrawText(FAIO.invokerPanelFont, startX+2+imageSize*5+4, startY+10+(imageSize+2)*8+4, math.floor(Ability.GetCooldownTimeLeft(deafeningBlast)), 0)
			end
		end

	-- combo Dagger, Blast, Meteor, Sunstrike
	if FAIO.InvokerComboSelector == 10 then
		if FAIO.InvokerInvokedChecker(myHero, "invoker_deafening_blast", "invoker_chaos_meteor") and Ability.IsReady(NPC.GetAbility(myHero, "invoker_invoke")) then
			Renderer.SetDrawColor(0, 205, 0, 255)
		else
			Renderer.SetDrawColor(255, 255, 0, 255)
		end
	else	
		Renderer.SetDrawColor(255, 255, 255, 150)
	end
	Renderer.DrawImage(imageHandleRefresher, startX+2+imageSize*0, startY+11+(imageSize+2)*9, imageSize, imageSize)
	Renderer.DrawImage(imageHandleAgha, startX+2+imageSize*1, startY+11+(imageSize+2)*9, imageSize, imageSize)
	Renderer.DrawImage(imageHandleDagger, startX+2+imageSize*2, startY+11+(imageSize+2)*9, imageSize, imageSize)
	Renderer.DrawImage(imageHandleBlast, startX+2+imageSize*3, startY+11+(imageSize+2)*9, imageSize, imageSize)
		if Menu.GetValue(FAIO.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(deafeningBlast) > 0 then
				Renderer.DrawText(FAIO.invokerPanelFont, startX+2+imageSize*3+4, startY+11+(imageSize+2)*9+4, math.floor(Ability.GetCooldownTimeLeft(deafeningBlast)), 0)
			end
		end
	Renderer.DrawImage(imageHandleMeteor, startX+2+imageSize*4, startY+11+(imageSize+2)*9, imageSize, imageSize)
		if Menu.GetValue(FAIO.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(chaosMeteor) > 0 then
				Renderer.DrawText(FAIO.invokerPanelFont, startX+2+imageSize*4+4, startY+11+(imageSize+2)*9+4, math.floor(Ability.GetCooldownTimeLeft(chaosMeteor)), 0)
			end
		end
	Renderer.DrawImage(imageHandleSunStrike, startX+2+imageSize*5, startY+11+(imageSize+2)*9, imageSize, imageSize)
		if Menu.GetValue(FAIO.optionHeroInvokerPanelCD) == 2 then
			if Ability.GetCooldownTimeLeft(sunStrike) > 0 then
				Renderer.DrawText(FAIO.invokerPanelFont, startX+2+imageSize*5+4, startY+11+(imageSize+2)*9+4, math.floor(Ability.GetCooldownTimeLeft(sunStrike)), 0)
			end
		end

	-- dynamic mode
	if FAIO.InvokerComboSelector == 11 then
		Renderer.SetDrawColor(0, 205, 0, 255)
	else	
		Renderer.SetDrawColor(255, 255, 255, 150)
	end
	Renderer.DrawImage(imageHandleBlast, startX+2+(imageSize/2)*0, startY+12+(imageSize+2)*10, (imageSize/2), (imageSize/2))
	Renderer.DrawImage(imageHandleMeteor, startX+2+(imageSize/2)*1, startY+12+(imageSize+2)*10, (imageSize/2), (imageSize/2))
	
	Renderer.DrawImage(imageHandleSunStrike, startX+2+(imageSize/2)*0, startY+12+(imageSize+2)*10+(imageSize/2), (imageSize/2), (imageSize/2))
	Renderer.DrawImage(imageHandleTornado, startX+2+(imageSize/2)*1, startY+12+(imageSize+2)*10+(imageSize/2), (imageSize/2), (imageSize/2))
	
	Renderer.DrawImage(imageHandleEmp, startX+2+(imageSize/2)*2, startY+12+(imageSize+2)*10, (imageSize/2), (imageSize/2))
	Renderer.DrawImage(imageHandleSnap, startX+2+(imageSize/2)*3, startY+12+(imageSize+2)*10, (imageSize/2), (imageSize/2))
	
	Renderer.DrawImage(imageHandleSpirit, startX+2+(imageSize/2)*2, startY+12+(imageSize+2)*10+(imageSize/2), (imageSize/2), (imageSize/2))
	Renderer.DrawImage(imageHandleAlacrity, startX+2+(imageSize/2)*3, startY+12+(imageSize+2)*10+(imageSize/2), (imageSize/2), (imageSize/2))
	
	Renderer.DrawImage(imageHandleIcewall, startX+2+(imageSize/2)*4, startY+12+(imageSize+2)*10, (imageSize/2), (imageSize/2))
	Renderer.DrawImage(imageHandleGhost, startX+2+(imageSize/2)*4, startY+12+(imageSize+2)*10+(imageSize/2), (imageSize/2), (imageSize/2))

	Renderer.DrawText(FAIO.invokerPanelFont, startX+2+(imageSize/2)*6, startY+12+(imageSize+2)*10+math.floor(imageSize/6), "dynamic", 1)


	-- custom mode
	local skillTranslator = {
		imageHandleTornado,
		imageHandleEmp,
		imageHandleMeteor, 
		imageHandleBlast,
		imageHandleSunStrike,
		imageHandleIcewall,
		imageHandleSnap,
		imageHandleSpirit,
		imageHandleAlacrity,
		imageHandleEul,
		imageHandleAtos,
		imageHandleRefresher
			}
		-- custom mode 1
	if FAIO.InvokerComboSelector == 12 then
		if FAIO.InvokerInvokedChecker(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill2)], invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill1)]) and Ability.IsReady(NPC.GetAbility(myHero, "invoker_invoke")) then
			Renderer.SetDrawColor(0, 205, 0, 255)
		else
			Renderer.SetDrawColor(255, 255, 0, 255)
		end
	else	
		Renderer.SetDrawColor(255, 255, 255, 150)
	end
	if Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill1) > 0 then
		Renderer.DrawImage(skillTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill1)], startX+2+imageSize*0, startY+14+(imageSize+2)*12, imageSize, imageSize)
	end
	if Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill2) > 0 then
		Renderer.DrawImage(skillTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill2)], startX+2+imageSize*1, startY+14+(imageSize+2)*12, imageSize, imageSize)
	end
	if Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill3) > 0 then
		Renderer.DrawImage(skillTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill3)], startX+2+imageSize*2, startY+14+(imageSize+2)*12, imageSize, imageSize)
	end
	if Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill4) > 0 then
		Renderer.DrawImage(skillTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill4)], startX+2+imageSize*3, startY+14+(imageSize+2)*12, imageSize, imageSize)
	end
	if Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill5) > 0 then
		Renderer.DrawImage(skillTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill5)], startX+2+imageSize*4, startY+14+(imageSize+2)*12, imageSize, imageSize)
	end
	if Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill6) > 0 then
		Renderer.DrawImage(skillTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill6)], startX+2+imageSize*5, startY+14+(imageSize+2)*12, imageSize, imageSize)
	end
		-- custom mode 2
	if FAIO.InvokerComboSelector == 13 then
		if FAIO.InvokerInvokedChecker(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill2)], invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill1)]) and Ability.IsReady(NPC.GetAbility(myHero, "invoker_invoke")) then
			Renderer.SetDrawColor(0, 205, 0, 255)
		else
			Renderer.SetDrawColor(255, 255, 0, 255)
		end
	else	
		Renderer.SetDrawColor(255, 255, 255, 150)
	end
	if Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill1) > 0 then
		Renderer.DrawImage(skillTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill1)], startX+2+imageSize*0, startY+15+(imageSize+2)*13, imageSize, imageSize)
	end
	if Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill2) > 0 then
		Renderer.DrawImage(skillTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill2)], startX+2+imageSize*1, startY+15+(imageSize+2)*13, imageSize, imageSize)
	end
	if Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill3) > 0 then
		Renderer.DrawImage(skillTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill3)], startX+2+imageSize*2, startY+15+(imageSize+2)*13, imageSize, imageSize)
	end
	if Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill4) > 0 then
		Renderer.DrawImage(skillTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill4)], startX+2+imageSize*3, startY+15+(imageSize+2)*13, imageSize, imageSize)
	end
	if Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill5) > 0 then
		Renderer.DrawImage(skillTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill5)], startX+2+imageSize*4, startY+15+(imageSize+2)*13, imageSize, imageSize)
	end
	if Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill6) > 0 then
		Renderer.DrawImage(skillTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill6)], startX+2+imageSize*5, startY+15+(imageSize+2)*13, imageSize, imageSize)
	end
		-- custom mode 3
	if FAIO.InvokerComboSelector == 14 then
		if FAIO.InvokerInvokedChecker(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill2)], invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill1)]) and Ability.IsReady(NPC.GetAbility(myHero, "invoker_invoke")) then
			Renderer.SetDrawColor(0, 205, 0, 255)
		else
			Renderer.SetDrawColor(255, 255, 0, 255)
		end
	else	
		Renderer.SetDrawColor(255, 255, 255, 150)
	end
	if Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill1) > 0 then
		Renderer.DrawImage(skillTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill1)], startX+2+imageSize*0, startY+16+(imageSize+2)*14, imageSize, imageSize)
	end
	if Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill2) > 0 then
		Renderer.DrawImage(skillTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill2)], startX+2+imageSize*1, startY+16+(imageSize+2)*14, imageSize, imageSize)
	end
	if Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill3) > 0 then
		Renderer.DrawImage(skillTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill3)], startX+2+imageSize*2, startY+16+(imageSize+2)*14, imageSize, imageSize)
	end
	if Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill4) > 0 then
		Renderer.DrawImage(skillTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill4)], startX+2+imageSize*3, startY+16+(imageSize+2)*14, imageSize, imageSize)
	end
	if Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill5) > 0 then
		Renderer.DrawImage(skillTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill5)], startX+2+imageSize*4, startY+16+(imageSize+2)*14, imageSize, imageSize)
	end
	if Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill6) > 0 then
		Renderer.DrawImage(skillTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill6)], startX+2+imageSize*5, startY+16+(imageSize+2)*14, imageSize, imageSize)
	end
		-- custom combo text
	Renderer.SetDrawColor(255, 50, 0, 150)
	Renderer.DrawText(FAIO.invokerPanelFont, startX+2+imageSize*1, startY+11+math.floor(imageSize/3)+(imageSize+2)*11, "custom combo", 1)
	
	-- longest CDs
	if Menu.GetValue(FAIO.optionHeroInvokerPanelCD) == 1 then
		Renderer.SetDrawColor(255, 0, 0, 150)
		if FAIO.GetLongestCooldown(myHero, coldSnap, forgeSpirit, alacrity) > 0 then
			Renderer.DrawText(FAIO.invokerPanelFont, startX+1-imageSize, startY+2+(imageSize+2)*0+math.floor(imageSize/9), FAIO.GetLongestCooldown(myHero, coldSnap, forgeSpirit, alacrity), 1)
		end
		if FAIO.GetLongestCooldown(myHero, coldSnap, forgeSpirit, sunStrike) > 0 then
			Renderer.DrawText(FAIO.invokerPanelFont, startX+1-imageSize, startY+3+(imageSize+2)*1+math.floor(imageSize/9), FAIO.GetLongestCooldown(myHero, coldSnap, forgeSpirit, sunStrike), 1)
		end
		if FAIO.GetLongestCooldown(myHero, coldSnap, iceWall, tornado, emp) > 0 then
		Renderer.DrawText(FAIO.invokerPanelFont, startX+1-imageSize, startY+4+(imageSize+2)*2+math.floor(imageSize/9), FAIO.GetLongestCooldown(myHero, coldSnap, iceWall, tornado, emp), 1)
		end
		if FAIO.GetLongestCooldown(myHero, tornado, chaosMeteor, deafeningBlast) > 0 then
			Renderer.DrawText(FAIO.invokerPanelFont, startX+1-imageSize, startY+5+(imageSize+2)*3+math.floor(imageSize/9), FAIO.GetLongestCooldown(myHero, tornado, chaosMeteor, deafeningBlast), 1)
		end
		if FAIO.GetLongestCooldown(myHero, euls, sunStrike, chaosMeteor, deafeningBlast) > 0 then
		Renderer.DrawText(FAIO.invokerPanelFont, startX+1-imageSize, startY+6+(imageSize+2)*4+math.floor(imageSize/9), FAIO.GetLongestCooldown(myHero, euls, sunStrike, chaosMeteor, deafeningBlast), 1)
		end
		if FAIO.GetLongestCooldown(myHero, tornado, emp, chaosMeteor, deafeningBlast) > 0 then
			Renderer.DrawText(FAIO.invokerPanelFont, startX+1-imageSize, startY+7+(imageSize+2)*5+math.floor(imageSize/9), FAIO.GetLongestCooldown(myHero, tornado, emp, chaosMeteor, deafeningBlast), 1)
		end
		if FAIO.GetLongestCooldown(myHero, tornado, sunStrike, chaosMeteor, deafeningBlast) > 0 then
			Renderer.DrawText(FAIO.invokerPanelFont, startX+1-imageSize, startY+8+(imageSize+2)*6+math.floor(imageSize/9), FAIO.GetLongestCooldown(myHero, tornado, sunStrike, chaosMeteor, deafeningBlast), 1)
		end
		if FAIO.GetLongestCooldown(myHero, tornado, sunStrike, chaosMeteor, deafeningBlast, refresher) > 0 then
			Renderer.DrawText(FAIO.invokerPanelFont, startX+1-imageSize, startY+9+(imageSize+2)*7+math.floor(imageSize/9), FAIO.GetLongestCooldown(myHero, tornado, sunStrike, chaosMeteor, deafeningBlast, refresher), 1)
		end
		if FAIO.GetLongestCooldown(myHero, tornado, emp, chaosMeteor, deafeningBlast, refresher) > 0 then
			Renderer.DrawText(FAIO.invokerPanelFont, startX+1-imageSize, startY+10+(imageSize+2)*8+math.floor(imageSize/9), FAIO.GetLongestCooldown(myHero, tornado, emp, chaosMeteor, deafeningBlast, refresher), 1)
		end
		if FAIO.GetLongestCooldown(myHero, sunStrike, chaosMeteor, deafeningBlast, refresher) > 0 then
			Renderer.DrawText(FAIO.invokerPanelFont, startX+1-imageSize, startY+11+(imageSize+2)*9+math.floor(imageSize/9), FAIO.GetLongestCooldown(myHero, sunStrike, chaosMeteor, deafeningBlast, refresher), 1)
		end
		if Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill1) > 0 and Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill2) > 0 and Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill3) > 0 then
			if FAIO.GetLongestCooldown(myHero, NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill1)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill2)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill3)])) > 0 then
				Renderer.DrawText(FAIO.invokerPanelFont, startX+1-imageSize, startY+14+(imageSize+2)*12+math.floor(imageSize/9), FAIO.GetLongestCooldown(myHero, NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill1)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill2)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo1Skill3)])), 1)
			end
		end
		if Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill1) > 0 and Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill2) > 0 and Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill3) > 0 then
			if FAIO.GetLongestCooldown(myHero, NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill1)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill2)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill3)])) > 0 then
				Renderer.DrawText(FAIO.invokerPanelFont, startX+1-imageSize, startY+15+(imageSize+2)*13+math.floor(imageSize/9), FAIO.GetLongestCooldown(myHero, NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill1)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill2)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo2Skill3)])), 1)
			end
		end
		if Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill1) > 0 and Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill2) > 0 and Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill3) > 0 then
			if FAIO.GetLongestCooldown(myHero, NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill1)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill2)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill3)])) > 0 then
				Renderer.DrawText(FAIO.invokerPanelFont, startX+1-imageSize, startY+16+(imageSize+2)*14+math.floor(imageSize/9), FAIO.GetLongestCooldown(myHero, NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill1)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill2)]), NPC.GetAbility(myHero, invokeTranslator[Menu.GetValue(FAIO.optionHeroInvokerCombo3Skill3)])), 1)
			end
		end
	end

end

function FAIO.invokerPanelInit()

	FAIO.invokerPanelBoxSize = Menu.GetValue(FAIO.invokerPanelSizeOption)

	FAIO.invokerPanelFont = Renderer.LoadFont("Tahoma", math.floor(FAIO.invokerPanelBoxSize * 0.6), Enum.FontWeight.BOLD)

	local iconsTempTable = {
		"invoker_tornado",
		"invoker_emp",
		"invoker_chaos_meteor", 
		"invoker_deafening_blast",
		"invoker_sun_strike",
		"invoker_ice_wall",
		"invoker_cold_snap",
		"invoker_forge_spirit",
		"invoker_alacrity",
		"item_cyclone",
		"item_rod_of_atos",
		"item_refresher",
		"item_blink",
		"item_ultimate_scepter",
		"invoker_ghost_walk"
			}

	for i = 1, #iconsTempTable do
		local imageHandle = FAIO.invokerCachedIcons[iconsTempTable[i]]
		if imageHandle == nil then
			if iconsTempTable[i] ~= "item_cyclone" and iconsTempTable[i] ~= "item_rod_of_atos" and iconsTempTable[i] ~= "item_refresher" and iconsTempTable[i] ~= "item_blink" and iconsTempTable[i] ~= "item_ultimate_scepter" then
				imageHandle = Renderer.LoadImage("resource/flash3/images/spellicons/" .. iconsTempTable[i] .. ".png")	
				FAIO.invokerCachedIcons[iconsTempTable[i]] = imageHandle
			else
				imageHandle = Renderer.LoadImage("resource/flash3/images/items/" .. string.gsub(iconsTempTable[i], "item_", "") .. ".png")
				FAIO.invokerCachedIcons[iconsTempTable[i]] = imageHandle
			end
		end
	end
	
end

function FAIO.invokerDisplayInit()

	FAIO.invokerDisplayBoxSize = Menu.GetValue(FAIO.invokerDisplaySizeOption)
	FAIO.invokerDisplayInnerBoxSize = FAIO.invokerDisplayBoxSize - 2

	FAIO.invokerDisplayFont = Renderer.LoadFont("Tahoma", math.floor(FAIO.invokerDisplayInnerBoxSize * 0.643), Enum.FontWeight.BOLD)

	local iconsTempTable = {
		"invoker_tornado",
		"invoker_emp",
		"invoker_chaos_meteor", 
		"invoker_deafening_blast",
		"invoker_sun_strike",
		"invoker_ice_wall",
		"invoker_cold_snap",
		"invoker_forge_spirit",
		"invoker_alacrity",
		"item_cyclone",
		"item_rod_of_atos",
		"item_refresher",
		"item_blink",
		"item_ultimate_scepter",
		"invoker_ghost_walk"
			}

	for i = 1, #iconsTempTable do
		local imageHandle = FAIO.invokerCachedIcons[iconsTempTable[i]]
		if imageHandle == nil then
			if iconsTempTable[i] ~= "item_cyclone" and iconsTempTable[i] ~= "item_rod_of_atos" and iconsTempTable[i] ~= "item_refresher" and iconsTempTable[i] ~= "item_blink" and iconsTempTable[i] ~= "item_ultimate_scepter" then
				imageHandle = Renderer.LoadImage("resource/flash3/images/spellicons/" .. iconsTempTable[i] .. ".png")	
				FAIO.invokerCachedIcons[iconsTempTable[i]] = imageHandle
			else
				imageHandle = Renderer.LoadImage("resource/flash3/images/items/" .. string.gsub(iconsTempTable[i], "item_", "") .. ".png")
				FAIO.invokerCachedIcons[iconsTempTable[i]] = imageHandle
			end
		end
	end

end

function FAIO.invokerDisplayDrawDisplay(myHero)

	if not Menu.IsEnabled(FAIO.invokerDisplayOption) then return end

	if FAIO.invokerDisplayNeedsInit then
        	FAIO.invokerDisplayInit()
        	FAIO.invokerDisplayNeedsInit = false
    	end

	local w, h = Renderer.GetScreenSize()
	x = math.floor(w/2);
	y = math.floor(h/5*3);
	y = y+Menu.GetValue(FAIO.invokerDisplayY)
	x = x+Menu.GetValue(FAIO.invokerDisplayX)

	local abilities = {}

	for i = 3, 15 do
        	local ability = NPC.GetAbilityByIndex(myHero, i)
		local name = Ability.GetName(ability)
        	if ability ~= nil and Entity.IsAbility(ability) and not Ability.IsAttributes(ability) and name~="invoker_invoke" and name ~= "invoker_empty1" and name~= "invoker_empty2"then
            		if Ability.GetCooldownTimeLeft(ability)==0 then
               			table.insert(abilities, 1, ability)
            		else 
                		table.insert(abilities, #abilities+1, ability)
            		end 
        	end
    	end

    	if Menu.IsEnabled(FAIO.invokerDisplaySortAbilitiesOption) then
        	table.sort(abilities, function(a, b) return Ability.GetName(a) < Ability.GetName(b) end)
    	end

    	local startX = x - math.floor(((#abilities) / 2) * FAIO.invokerDisplayBoxSize)

    	Renderer.SetDrawColor(0, 0, 0, 150)
    	Renderer.DrawFilledRect(startX + 1, y - 1, (FAIO.invokerDisplayBoxSize * #abilities) + 2, FAIO.invokerDisplayBoxSize + 2)

   	for i, ability in ipairs(abilities) do
        	FAIO.invokerDisplayDrawAbilitySquare(myHero, ability, startX, y, i - 1)
    	end


    	Renderer.SetDrawColor(0, 0, 0, 255)
    	Renderer.DrawOutlineRect(startX + 1, y - 1, (FAIO.invokerDisplayBoxSize * #abilities) + 2, FAIO.invokerDisplayBoxSize + 2)

end

function FAIO.invokerDisplayDrawAbilitySquare(myHero, ability, x, y, index)

    	local abilityName = Ability.GetName(ability)
    	local imageHandle = FAIO.invokerCachedIcons[abilityName]
		if imageHandle == nil then
			FAIO.invokerPanelInit()
		end
			

    	local realX = x + (index * FAIO.invokerDisplayBoxSize) + 2

    	local castable = Ability.IsCastable(ability, NPC.GetMana(myHero), true)

    	local imageColor = { 255, 255, 255 }
    	local outlineColor = { 0, 255 , 0 }

    	if not castable then
        	if Ability.GetLevel(ability) == 0 then
            		imageColor = { 125, 125, 125 }
            		outlineColor = { 255, 0, 0 }
        	elseif Ability.GetManaCost(ability) > NPC.GetMana(myHero) then
            		imageColor = { 150, 150, 255 }
            		outlineColor = { 0, 0, 255 }
        	else
            		imageColor = { 255, 150, 150 }
            		outlineColor = { 255, 0, 0 }
        	end
    	end

    	local hoveringOver = Input.IsCursorInRect(realX, y, FAIO.invokerDisplayBoxSize, FAIO.invokerDisplayBoxSize)

    	local boxSize = FAIO.invokerDisplayBoxSize

    	if hoveringOver then
        	boxSize = math.floor(boxSize * 1.25)
    	end

    	Renderer.SetDrawColor(imageColor[1], imageColor[2], imageColor[3], 255)
    	Renderer.DrawImage(imageHandle, realX, y, FAIO.invokerDisplayBoxSize, FAIO.invokerDisplayBoxSize)

    	Renderer.SetDrawColor(outlineColor[1], outlineColor[2], outlineColor[3], 255)
    	Renderer.DrawOutlineRect(realX, y, FAIO.invokerDisplayBoxSize, FAIO.invokerDisplayBoxSize)

    	local cdLength = Ability.GetCooldownLength(ability)

    	if not Ability.IsReady(ability) and cdLength > 0.0 then
        	local cooldownRatio = Ability.GetCooldown(ability) / cdLength
        	local cooldownSize = math.floor(FAIO.invokerDisplayBoxSize * cooldownRatio)

        	Renderer.SetDrawColor(255, 255, 255, 50)
        	Renderer.DrawFilledRect(realX + 1, y + (FAIO.invokerDisplayInnerBoxSize - cooldownSize) + 1, FAIO.invokerDisplayInnerBoxSize, cooldownSize)

        	Renderer.SetDrawColor(255, 255, 255)
        	Renderer.DrawText(FAIO.invokerDisplayFont, realX + 1, y, math.floor(Ability.GetCooldown(ability)), 0)
    	elseif hoveringOver and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) then
        	FAIO.invokerInvokeAbility(myHero, ability)
    	end

end
				
-- killsteal functions
function FAIO.AutoNukeKillSteal(myHero)

	if not myHero then return end
	local myMana = NPC.GetMana(myHero)

	if FAIO.heroCanCastSpells(myHero, enemy) == false then return end
	if FAIO.isHeroChannelling(myHero) == true then return end 
	if FAIO.IsHeroInvisible(myHero) == true then return end
	
	for _, stealEnemyEntity in ipairs(Wrap.HeroesInRadius(myHero, 2000, Enum.TeamType.TEAM_ENEMY)) do
		if not stealEnemyEntity then return end
	
	local stealEnemy = FAIO.targetChecker(stealEnemyEntity)
		
		if not stealEnemy then return end
		if NPC.HasState(stealEnemy, Enum.ModifierState.MODIFIER_STATE_INVULNERABLE) then return end

		for n, v in ipairs(FAIO.AbilityList) do
			local heroName = v[1]
	      		local skillName = v[2]
			local skillType = v[3]
			local targetMode = v[4]
			local specialAttribute = v[5]
		
			if FAIO.myUnitName == heroName then
				if skillType == "nuke" and NPC.GetAbility(myHero, skillName) ~= nil and not Ability.IsUltimate(NPC.GetAbility(myHero, skillName)) and Ability.IsCastable(NPC.GetAbility(myHero, skillName), myMana) then
					if Entity.GetHealth(stealEnemy) > 0 and not NPC.HasModifier(stealEnemy, "modifier_templar_assassin_refraction_absorb") then
						if NPC.IsEntityInRange(myHero, stealEnemy, Ability.GetCastRange(NPC.GetAbility(myHero, skillName))) or skillName == "rattletrap_rocket_flare" then
							local skillDamage = Ability.GetDamage(NPC.GetAbility(myHero, skillName), 0)
							if skillDamage < 1 then
								if skillName == "skywrath_mage_arcane_bolt" then
									skillDamage = Ability.GetLevelSpecialValueFor(NPC.GetAbility(myHero, skillName), specialAttribute) + (1.6 * Hero.GetIntellectTotal(myHero))
								else
									skillDamage = Ability.GetLevelSpecialValueFor(NPC.GetAbility(myHero, skillName), specialAttribute)
								end
							end
							if Entity.GetHealth(stealEnemy) + NPC.GetHealthRegen(stealEnemy) <= (((1 - NPC.GetMagicalArmorValue(stealEnemy)) * skillDamage) + (skillDamage * (Hero.GetIntellectTotal(myHero) / 14 / 100))) then
								if NPC.GetAbility(myHero, skillName) and not NPC.HasState(stealEnemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
									if targetMode == "target" and not NPC.IsLinkensProtected(stealEnemy) then
										Ability.CastTarget(NPC.GetAbility(myHero, skillName), stealEnemy)
										break
										return
									end
									if targetMode == "position" then
										Ability.CastPosition(NPC.GetAbility(myHero, skillName), Entity.GetAbsOrigin(stealEnemy))
										break
										return
									end
									if targetMode == "no target" then
										Ability.CastNoTarget(NPC.GetAbility(myHero, skillName))
										break
										return
									end
									if targetMode == "skillshot" then
										if skillName == "windrunner_powershot" then
											local powershotPrediction = 1 + (Entity.GetAbsOrigin(stealEnemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 3000) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
											Ability.CastPosition(NPC.GetAbility(myHero, skillName), FAIO.castLinearPrediction(myHero, stealEnemy, powershotPrediction))
											break
											return
										end
										if skillName == "death_prophet_carrion_swarm" then
											local carrionPrediction = 0.5 + (Entity.GetAbsOrigin(stealEnemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1100) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
											Ability.CastPosition(NPC.GetAbility(myHero, skillName), FAIO.castLinearPrediction(myHero, stealEnemy, carrionPrediction))
											break
											return
										end
										if skillName == "kunkka_torrent" then
											local kunkkaPrediction = 2 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
											Ability.CastPosition(NPC.GetAbility(myHero, skillName), FAIO.castPrediction(myHero, stealEnemy, kunkkaPrediction))
											break
											return
										end
										if skillName == "lina_dragon_slave" then
											local dragonSlavePrediction = Ability.GetCastPoint(NPC.GetAbility(myHero, skillName)) + (Entity.GetAbsOrigin(stealEnemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1200) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
											Ability.CastPosition(NPC.GetAbility(myHero, skillName), FAIO.castLinearPrediction(myHero, stealEnemy, dragonSlavePrediction))
											break
											return
										end
										if skillName == "magnataur_shockwave" then
											local shockwavePrediction = Ability.GetCastPoint(NPC.GetAbility(myHero, skillName)) + (Entity.GetAbsOrigin(stealEnemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1050) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
											Ability.CastPosition(NPC.GetAbility(myHero, skillName), FAIO.castLinearPrediction(myHero, stealEnemy, shockwavePrediction))
											break
											return
										end
										if skillName == "pugna_nether_blast" then
											local blastPrediction = Ability.GetCastPoint(NPC.GetAbility(myHero, skillName)) + 0.9 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
											Ability.CastPosition(NPC.GetAbility(myHero, skillName), FAIO.castPrediction(myHero, stealEnemy, blastPrediction))
											break
											return
										end
										if skillName == "rattletrap_rocket_flare" then
											local flairPrediction = Ability.GetCastPoint(NPC.GetAbility(myHero, skillName)) + (Entity.GetAbsOrigin(stealEnemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1750) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
											Ability.CastPosition(NPC.GetAbility(myHero, skillName), FAIO.castLinearPrediction(myHero, stealEnemy, flairPrediction))
											break
											return
										end
										if skillName == "tusk_ice_shards" then
											local shardsPrediction = Ability.GetCastPoint(NPC.GetAbility(myHero, skillName)) + (Entity.GetAbsOrigin(stealEnemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1100) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
											Ability.CastPosition(NPC.GetAbility(myHero, skillName), FAIO.castLinearPrediction(myHero, stealEnemy, shardsPrediction))
											break
											return
										end
										if skillName == "vengefulspirit_wave_of_terror" then
											local wavePrediction = Ability.GetCastPoint(NPC.GetAbility(myHero, skillName)) + (Entity.GetAbsOrigin(stealEnemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 2000) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
											Ability.CastPosition(NPC.GetAbility(myHero, skillName), FAIO.castLinearPrediction(myHero, stealEnemy, wavePrediction))
											break
											return
										end
									end
								end
							end	
						end
						if NPC.IsEntityInRange(myHero, stealEnemy, Ability.GetCastRange(NPC.GetAbility(myHero, skillName))) and targetMode == "special" then
							if skillName == "nyx_assassin_mana_burn" then
								local skillDamage = Ability.GetLevelSpecialValueForFloat(NPC.GetAbility(myHero, skillName), "float_multiplier") * Hero.GetIntellectTotal(stealEnemy) * (1 + Hero.GetIntellectTotal(myHero) / 14 / 100)
								if Entity.GetHealth(stealEnemy) <= (((1 - NPC.GetMagicalArmorValue(stealEnemy)) * skillDamage) + (skillDamage * (Hero.GetIntellectTotal(myHero) / 14 / 100))) and NPC.GetMana(stealEnemy) >= Entity.GetHealth(stealEnemy) then
									if NPC.GetAbility(myHero, skillName) and not NPC.IsLinkensProtected(stealEnemy) and not NPC.HasState(stealEnemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
										Ability.CastTarget(NPC.GetAbility(myHero, skillName), stealEnemy)
										break
										return
									end
								end
							end
						end
						if skillName == "queenofpain_scream_of_pain" then
							if NPC.IsEntityInRange(myHero, stealEnemy, Ability.GetLevelSpecialValueFor(NPC.GetAbility(myHero, skillName), "area_of_effect")) and targetMode == "special" then
								if Entity.GetHealth(stealEnemy) <= (1 - NPC.GetMagicalArmorValue(stealEnemy))*Ability.GetDamage(NPC.GetAbility(myHero, skillName), 0) + (Ability.GetDamage(NPC.GetAbility(myHero, skillName), 0) * (Hero.GetIntellectTotal(myHero) / 14 / 100)) then
									if NPC.GetAbility(myHero, skillName) and not NPC.HasState(stealEnemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
										Ability.CastNoTarget(NPC.GetAbility(myHero, skillName))
										break
										return
									end
								end
							end
						end
						if skillName == "nevermore_shadowraze1" and targetMode == "special" then
							local razePos = Entity.GetAbsOrigin(myHero) + Entity.GetRotation(myHero):GetForward():Normalized():Scaled(200)
							local razePrediction = 0.55 + 0.1 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)			
							local predictedPos = FAIO.castPrediction(myHero, stealEnemy, razePrediction)
							local disRazePOSpredictedPOS = (razePos - predictedPos):Length2D()
							if disRazePOSpredictedPOS <= 200 and not NPC.IsTurning(myHero) then
								local skillDamage = Ability.GetLevelSpecialValueFor(NPC.GetAbility(myHero, skillName), "shadowraze_damage")
								if Entity.GetHealth(stealEnemy) <= (((1 - NPC.GetMagicalArmorValue(stealEnemy)) * skillDamage) + (skillDamage * (Hero.GetIntellectTotal(myHero) / 14 / 100))) then
									if NPC.GetAbility(myHero, skillName) and not NPC.HasState(stealEnemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
										if os.clock() - FAIO.lastCastTime2 >= 0.55 then
											Ability.CastNoTarget(NPC.GetAbility(myHero, skillName))
											FAIO.lastCastTime2 = os.clock()
											break
											return
										end
									end
								end
							end
						end
						if skillName == "nevermore_shadowraze2" and targetMode == "special" then
							local razePos = Entity.GetAbsOrigin(myHero) + Entity.GetRotation(myHero):GetForward():Normalized():Scaled(450)
							local razePrediction = 0.55 + 0.1 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)			
							local predictedPos = FAIO.castPrediction(myHero, stealEnemy, razePrediction)
							local disRazePOSpredictedPOS = (razePos - predictedPos):Length2D()
							if disRazePOSpredictedPOS <= 200 and not NPC.IsTurning(myHero) then
								local skillDamage = Ability.GetLevelSpecialValueFor(NPC.GetAbility(myHero, skillName), "shadowraze_damage")
								if Entity.GetHealth(stealEnemy) <= (((1 - NPC.GetMagicalArmorValue(stealEnemy)) * skillDamage) + (skillDamage * (Hero.GetIntellectTotal(myHero) / 14 / 100))) then
									if NPC.GetAbility(myHero, skillName) and not NPC.HasState(stealEnemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
										if os.clock() - FAIO.lastCastTime2 >= 0.55 then
											Ability.CastNoTarget(NPC.GetAbility(myHero, skillName))
											FAIO.lastCastTime2 = os.clock()
											break
											return
										end
									end
								end
							end
						end
						if skillName == "nevermore_shadowraze3" and targetMode == "special" then
							local razePos = Entity.GetAbsOrigin(myHero) + Entity.GetRotation(myHero):GetForward():Normalized():Scaled(700)
							local razePrediction = 0.55 + 0.1 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)			
							local predictedPos = FAIO.castPrediction(myHero, stealEnemy, razePrediction)
							local disRazePOSpredictedPOS = (razePos - predictedPos):Length2D()
							if disRazePOSpredictedPOS <= 200 and not NPC.IsTurning(myHero) then
								local skillDamage = Ability.GetLevelSpecialValueFor(NPC.GetAbility(myHero, skillName), "shadowraze_damage")
								if Entity.GetHealth(stealEnemy) <= (((1 - NPC.GetMagicalArmorValue(stealEnemy)) * skillDamage) + (skillDamage * (Hero.GetIntellectTotal(myHero) / 14 / 100))) then
									if NPC.GetAbility(myHero, skillName) and not NPC.HasState(stealEnemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
										if os.clock() - FAIO.lastCastTime2 >= 0.55 then
											Ability.CastNoTarget(NPC.GetAbility(myHero, skillName))
											FAIO.lastCastTime2 = os.clock()
											break
											return
										end
									end
								end
							end
						end
						if skillName == "skywrath_mage_concussive_shot" and targetMode == "special" then
							local skillDamage = Ability.GetLevelSpecialValueFor(NPC.GetAbility(myHero, skillName), specialAttribute)
							if NPC.IsEntityInRange(myHero, stealEnemy, 1600, 0) and not NPC.HasState(stealEnemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
								if Entity.GetHealth(stealEnemy) <= (((1 - NPC.GetMagicalArmorValue(stealEnemy)) * skillDamage) + (skillDamage * (Hero.GetIntellectTotal(myHero) / 14 / 100))) then
									local enemyDis = (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(stealEnemy)):Length2D()
									local aghanimsBuffed = false
										if NPC.HasItem(myHero, "item_ultimate_scepter", true) or NPC.HasModifier(myHero, "modifier_item_ultimate_scepter_consumed") then
											aghanimsBuffed = true
										end
									if not aghanimsBuffed then
										if #Wrap.HeroesInRadius(myHero, enemyDis, Enum.TeamType.TEAM_ENEMY) <= 1 then
											Ability.CastNoTarget(NPC.GetAbility(myHero, skillName))
											break
											return
										end
									else
										if #Wrap.HeroesInRadius(myHero, enemyDis, Enum.TeamType.TEAM_ENEMY) <= 2 then
											Ability.CastNoTarget(NPC.GetAbility(myHero, skillName))
											break
											return
										end
									end
								end
							end
						end
						if skillName == "pangolier_swashbuckle" and targetMode == "special" and not NPC.HasModifier(myHero, "modifier_pangolier_gyroshell") then
							local skillDamage = Ability.GetLevelSpecialValueFor(NPC.GetAbility(myHero, skillName), specialAttribute)
								if NPC.HasAbility(myHero, "special_bonus_unique_pangolier_3") then
									if Ability.GetLevel(NPC.GetAbility(myHero, "special_bonus_unique_pangolier_3")) > 0 then
										skillDamage = skillDamage + 30
									end
								end
							local trueSkillDamage = NPC.GetDamageMultiplierVersus(myHero, stealEnemy) * (skillDamage * NPC.GetArmorDamageMultiplier(stealEnemy)) * 4
							local castRange = 1000
							local slashRange = 900
							if NPC.IsEntityInRange(myHero, stealEnemy, castRange + slashRange, 0) then
								if Entity.GetHealth(stealEnemy) + NPC.GetHealthRegen(stealEnemy) <= trueSkillDamage then
									if NPC.IsEntityInRange(myHero, stealEnemy, castRange, 0) then
										local swashPrediction = 0.2 + ((Entity.GetAbsOrigin(stealEnemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() - 100) / 2000) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
										local pos = FAIO.castPrediction(myHero, stealEnemy, swashPrediction) + (Entity.GetAbsOrigin(myHero) - FAIO.castPrediction(myHero, stealEnemy, swashPrediction)):Normalized():Scaled(100)
									    	Player.PrepareUnitOrders(Players.GetLocal(), 30, nil, pos, NPC.GetAbility(myHero, skillName), Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_HERO_ONLY, myHero)
										Ability.CastPosition(NPC.GetAbility(myHero, skillName), Entity.GetAbsOrigin(myHero), true)
										break
										return
									else
										local swashPrediction = 0.2 + ((Entity.GetAbsOrigin(stealEnemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() - 100) / 2000) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
										local pos = Entity.GetAbsOrigin(myHero) + (FAIO.castPrediction(myHero, stealEnemy, swashPrediction) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(999)
									    	Player.PrepareUnitOrders(Players.GetLocal(), 30, nil, pos, NPC.GetAbility(myHero, skillName), Enum.PlayerOrderIssuer.DOTA_ORDER_ISSUER_HERO_ONLY, myHero)
										Ability.CastPosition(NPC.GetAbility(myHero, skillName), Entity.GetAbsOrigin(myHero), true)
										break
										return
									end
								end
							end
						end
						if skillName == "winter_wyvern_splinter_blast" and targetMode == "special" then	
							local skillDamage = Ability.GetDamage(NPC.GetAbility(myHero, skillName))
							local skillTrueDamage = ((1 - NPC.GetMagicalArmorValue(stealEnemy)) * skillDamage) + (skillDamage * (Hero.GetIntellectTotal(myHero) / 14 / 100))
							if Entity.GetHealth(stealEnemy) + NPC.GetHealthRegen(stealEnemy) < skillTrueDamage then
								if NPC.IsEntityInRange(myHero, stealEnemy, 1600, 0) and not NPC.HasState(stealEnemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
									local target
									for _, possibleTargets in ipairs(Wrap.HInRadius(Entity.GetAbsOrigin(stealEnemy), 499, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_ENEMY)) do
										if possibleTargets and possibleTargets ~= stealEnemy and Entity.IsHero(possibleTargets) and Wrap.EIsAlive(possibleTargets) and not NPC.HasState(possibleTargets, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and not NPC.IsLinkensProtected(possibleTargets) then
											if NPC.IsEntityInRange(myHero, possibleTargets, 1199) then
												target = possibleTargets
												break
											end
										end
									end
									if target ~= nil then
										Ability.CastTarget(NPC.GetAbility(myHero, skillName), target)
										break
										return
									end
								end
							end
						end
					end
				end
				if skillType == "pure" and NPC.GetAbility(myHero, skillName) ~= nil and not Ability.IsUltimate(NPC.GetAbility(myHero, skillName)) and Ability.IsCastable(NPC.GetAbility(myHero, skillName), myMana) then
					if Entity.GetHealth(stealEnemy) > 0 then
						if NPC.IsEntityInRange(myHero, stealEnemy, Ability.GetCastRange(NPC.GetAbility(myHero, skillName))) then
							local skillDamage = Ability.GetDamage(NPC.GetAbility(myHero, skillName), 0)
							if  skillDamage < 1 then
								if skillName == "skywrath_mage_arcane_bolt" then
									skillDamage = Ability.GetLevelSpecialValueFor(NPC.GetAbility(myHero, skillName), specialAttribute) + (1.6 * Hero.GetIntellectTotal(myHero))
								else
									skillDamage = Ability.GetLevelSpecialValueFor(NPC.GetAbility(myHero, skillName), specialAttribute)
								end
							end
							if Entity.GetHealth(stealEnemy) + NPC.GetHealthRegen(stealEnemy) <= skillDamage then
								if NPC.GetAbility(myHero, skillName) and Ability.IsCastable(NPC.GetAbility(myHero, skillName), myMana) then
									if targetMode == "target" and not NPC.IsLinkensProtected(stealEnemy) then
										Ability.CastTarget(NPC.GetAbility(myHero, skillName), stealEnemy)
										break
										return
									end
									if targetMode == "position" then
										Ability.CastPosition(NPC.GetAbility(myHero, skillName), Entity.GetAbsOrigin(stealEnemy))
										break
										return
									end
									if targetMode == "no target" then
										Ability.CastNoTarget(NPC.GetAbility(myHero, skillName))
										break
										return
									end
								end
							end
						end
					end
				end
			end
		end
	end
end

function FAIO.AutoSunstrikeKillStealNew(myHero)

	if not myHero then return end
	if os.clock() - FAIO.invokerChannellingKillstealTimer <= 3 then return end
	
	if Ability.GetLevel(NPC.GetAbilityByIndex(myHero, 2)) < 1 then return end
	if FAIO.heroCanCastSpells(myHero, enemy) == false then return end
	if FAIO.isHeroChannelling(myHero) == true then return end 
	if FAIO.IsHeroInvisible(myHero) == true then return end

	if Menu.IsKeyDownOnce(FAIO.optionComboKey) then return end
	if Menu.IsKeyDown(FAIO.optionComboKey) then return end

	local myMana = NPC.GetMana(myHero)

	local exort = NPC.GetAbility(myHero, "invoker_exort")
	local invoke = NPC.GetAbility(myHero, "invoker_invoke")
	local aghanims = NPC.GetItem(myHero, "item_ultimate_scepter", true)
	local sunStrike = NPC.GetAbility(myHero, "invoker_sun_strike")
	local sunStrikeDMG = 37.5 + (62.5 * Ability.GetLevel(exort))
		if aghanims or NPC.HasModifier(myHero, "modifier_item_ultimate_scepter_consumed") then
			sunStrikeDMG = 37.5 + (62.5 * (Ability.GetLevel(exort) + 1))
		end
	
	if not sunStrike then return end
	if not Ability.IsReady(sunStrike) then return end
	if not Ability.IsCastable(sunStrike, myMana) then return end

	if Menu.IsEnabled(FAIO.optionKillStealInvokerTPpartice) then
		if FAIO.invokerSunstrikeKSParticleProcess(myHero) == true then
			if not FAIO.InvokerIsAbilityInvoked(myHero, sunStrike) then
				if Menu.IsEnabled(FAIO.optionKillStealAutoInvoke) then
					if invoke and Ability.IsCastable(invoke, myMana) and FAIO.InvokerIsSkillInvokable(myHero, sunStrike) then
						FAIO.invokerInvokeAbility(myHero, sunStrike)
						Ability.CastPosition(sunStrike, FAIO.TPParticlePosition, true)
						FAIO.invokerChannellingKillstealTimer = os.clock()
						return
					end
				else
					return
				end
			else
				Ability.CastPosition(sunStrike, FAIO.TPParticlePosition)
				FAIO.invokerChannellingKillstealTimer = os.clock()
				return
			end
		end
	end

	if Menu.IsEnabled(FAIO.optionKillStealInvokerImmobil) then
		for _, immobilizedEntity in ipairs(Wrap.HeroesInRadius(myHero, 99999, Enum.TeamType.TEAM_ENEMY)) do
			if immobilizedEntity then
				local immobilizedEnemy = FAIO.targetChecker(immobilizedEntity)
				if immobilizedEnemy and Wrap.EIsAlive(immobilizedEnemy) and not NPC.HasModifier(immobilizedEnemy, "modifier_templar_assassin_refraction_absorb") then
					local enemyProcessing = FAIO.invokerSunstrikeKSdisabledTargetProcess(myHero, immobilizedEnemy)
					if next(enemyProcessing) ~= nil then
						if enemyProcessing[1] > 0 and enemyProcessing[2] > 0 then
							local timing = enemyProcessing[1]
							local HPthreshold = enemyProcessing[2]
							if Entity.GetHealth(immobilizedEnemy) < HPthreshold then
								if GameRules.GetGameTime() >= timing then
									if not FAIO.InvokerIsAbilityInvoked(myHero, sunStrike) then
										if Menu.IsEnabled(FAIO.optionKillStealAutoInvoke) then
											if invoke and Ability.IsCastable(invoke, myMana) and FAIO.InvokerIsSkillInvokable(myHero, sunStrike) then
												FAIO.invokerInvokeAbility(myHero, sunStrike)
												Ability.CastPosition(sunStrike, Entity.GetAbsOrigin(immobilizedEnemy), true)
												FAIO.invokerChannellingKillstealTimer = os.clock()
												return
											end
										else
											return
										end
									else
										Ability.CastPosition(sunStrike, Entity.GetAbsOrigin(immobilizedEnemy))
										FAIO.invokerChannellingKillstealTimer = os.clock()
										return
									end
								end
							end
						end
					end
				end
			end
		end
	end

	if FAIO.InvokerKSparticleProcess[1][5]:__tostring() ~= Vector():__tostring() then
		local processData = table.remove(FAIO.InvokerKSparticleProcess, 1)
		FAIO.InvokerKSparticleProcess = {{nil, nil, 0, nil, Vector()}}
		local name = processData[2]
		local time = processData[3]
		local pos = processData[5]

		for _, v in ipairs(Wrap.HInRadius(pos, 175, Entity.GetTeamNum(myHero), Enum.UnitType.TEAM_ENEMY)) do
			if v and Entity.IsHero(v) and not NPC.IsIllusion(v) and Wrap.EIsAlive(v) and not not NPC.HasModifier(v, "modifier_templar_assassin_refraction_absorb") then
				if Entity.GetHealth(v) < sunStrikeDMG * (1 + Menu.GetValue(FAIO.optionKillStealInvokerTreshold) / 100) then
					local duration
					if name == "rattletrap_cog_deploy" then
						duration = 2 + FAIO.GetTeammateAbilityLevel(myHero, "rattletrap_cog")
					elseif name == "furion_sprout" then
						duration = 2 + FAIO.GetTeammateAbilityLevel(myHero, "furion_sprout")
					end
					if GameRules.GetGameTime() + 1.5 < time + duration then
						if not FAIO.InvokerIsAbilityInvoked(myHero, sunStrike) then
							if Menu.IsEnabled(FAIO.optionKillStealAutoInvoke) then
								if invoke and Ability.IsCastable(invoke, myMana) and FAIO.InvokerIsSkillInvokable(myHero, sunStrike) then
									FAIO.invokerInvokeAbility(myHero, sunStrike)
									Ability.CastPosition(sunStrike, pos, true)
									FAIO.invokerChannellingKillstealTimer = os.clock()
									return
								end
							else
								return
							end
						else
							Ability.CastPosition(sunStrike, pos)
							FAIO.invokerChannellingKillstealTimer = os.clock()
							return
						end
					end
				end
			end
		end
	end		
	
	if FAIO.GlimpseParticleTime > 0 and FAIO.GlimpseParticleUnit ~= nil and FAIO.GlimpseParticlePosition ~= Vector() and FAIO.GlimpseParticlePositionStart ~= Vector() then
		if not NPC.IsIllusion(FAIO.GlimpseParticleUnit) and Wrap.EIsAlive(FAIO.GlimpseParticleUnit) and not NPC.HasModifier(FAIO.GlimpseParticleUnit, "modifier_templar_assassin_refraction_absorb") then
			if Entity.GetHealth(FAIO.GlimpseParticleUnit) < sunStrikeDMG - 25 then
				local glimpseTiming
					if (FAIO.GlimpseParticlePositionStart - FAIO.GlimpseParticlePosition):Length2D() / 600 >= 1.8 then
						glimpseTiming = 1.8
					else
						glimpseTiming = (FAIO.GlimpseParticlePositionStart - FAIO.GlimpseParticlePosition):Length2D() / 600
					end
				if glimpseTiming > 1.5 then
					if GameRules.GetGameTime() >= FAIO.GlimpseParticleTime + glimpseTiming - 1.65 then
						if not FAIO.InvokerIsAbilityInvoked(myHero, sunStrike) then
							if Menu.IsEnabled(FAIO.optionKillStealAutoInvoke) then
								if invoke and Ability.IsCastable(invoke, myMana) and FAIO.InvokerIsSkillInvokable(myHero, sunStrike) then
									FAIO.invokerInvokeAbility(myHero, sunStrike)
									Ability.CastPosition(sunStrike, FAIO.GlimpseParticlePosition, true)
									FAIO.invokerChannellingKillstealTimer = os.clock()
									FAIO.GlimpseParticleUnit = nil
									return
								end
							else
								return
							end
						else
							Ability.CastPosition(sunStrike, FAIO.GlimpseParticlePosition)
							FAIO.invokerChannellingKillstealTimer = os.clock()
							FAIO.GlimpseParticleUnit = nil
							return
						end
					end
				end
			end
		end
	end

	if Menu.IsEnabled(FAIO.optionKillStealInvokerRunning) then
		for _, stealEnemyEntity in ipairs(Wrap.HeroesInRadius(myHero, 99999, Enum.TeamType.TEAM_ENEMY)) do
			local sunStrikeEnemy = FAIO.targetChecker(stealEnemyEntity)
			if sunStrikeEnemy and Wrap.EIsAlive(sunStrikeEnemy) and not NPC.HasModifier(sunStrikeEnemy, "modifier_templar_assassin_refraction_absorb") then
				local bestTarget
				local maxAgi = 0
				if Entity.GetHealth(sunStrikeEnemy) <= sunStrikeDMG and Hero.GetAgilityTotal(sunStrikeEnemy) > maxAgi then
					bestTarget = sunStrikeEnemy
					maxAgi = Hero.GetAgilityTotal(sunStrikeEnemy)
				end
				if Entity.GetHealth(sunStrikeEnemy) > sunStrikeDMG or Entity.GetHealth(sunStrikeEnemy) < 1  then
					bestTarget = nil
					maxAgi = 0
				end
				if bestTarget then
					if not NPC.IsRunning(bestTarget) then
						return
					else
						if FAIO.isEnemyTurning(bestTarget) == false then
							if Ability.IsReady(sunStrike) and Ability.IsCastable(sunStrike, myMana) then
								if not FAIO.InvokerIsAbilityInvoked(myHero, sunStrike) then
									if Menu.IsEnabled(FAIO.optionKillStealAutoInvoke) then
										if invoke and Ability.IsCastable(invoke, myMana) and FAIO.InvokerIsSkillInvokable(myHero, sunStrike) then
											FAIO.invokerInvokeAbility(myHero, sunStrike)
											Ability.CastPosition(sunStrike, FAIO.castPrediction(myHero, bestTarget, Ability.GetCastPoint(NPC.GetAbility(myHero, "invoker_sun_strike")) + 1.7 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)), true)
											return
										end
									else
										return
									end
								else
									Ability.CastPosition(sunStrike, FAIO.castPrediction(myHero, bestTarget, Ability.GetCastPoint(NPC.GetAbility(myHero, "invoker_sun_strike")) + 1.7 + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)))
									return
								end
							end
						end
					end
				end
			end
		end
	end

end

function FAIO.Debugger(time, npc, ability, order)

	--if not Menu.IsEnabled(FAIO.optionDebugEnable) then return end
	--Log.Write(tostring(time) .. " " .. tostring(NPC.GetUnitName(npc)) .. " " .. tostring(ability) .. " " .. tostring(order))

end

function FAIO.TinkerCombo(myHero, enemy)

	if not Menu.IsEnabled(FAIO.optionHeroTinker) then return end

  	local laser = NPC.GetAbilityByIndex(myHero, 0)
 	local missile = NPC.GetAbilityByIndex(myHero, 1)
 	local march = NPC.GetAbilityByIndex(myHero, 2)
 	local rearm = NPC.GetAbility(myHero, "tinker_rearm")

	local lens = NPC.GetItem(myHero, "item_aether_lens", true)
	local blink = NPC.GetItem(myHero, "item_blink", true)

	local myMana = NPC.GetMana(myHero) - 75

	local travels = NPC.GetItem(myHero, "item_travel_boots", true) or NPC.GetItem(myHero, "item_travel_boots_2", true)

	FAIO.itemUsage(myHero, enemy)
	FAIO.TinkerPanicBlink(myHero, blink, rearm)

	if enemy and NPC.IsEntityInRange(myHero, enemy, 2400) then
		if Menu.IsKeyDown(FAIO.optionComboKey) and Wrap.EIsAlive(enemy) then
			FAIO.TinkerStatus = 1
			FAIO.TinkerFullCombo(myHero, enemy, myMana, laser, missile, march, rearm, blink)
		else
			if FAIO.TinkerStatus == 1 then
				FAIO.TinkerStatus = 0
			end
		end
	end

	if Menu.GetValue(FAIO.optionHeroTinkerPushMode) == 1 then
		if Menu.IsKeyDown(FAIO.optionHeroTinkerPushKey) then
			FAIO.TinkerStatus = 2
 			FAIO.TinkerPush(myHero, myMana, march, rearm, blink, travels)
		else
			if FAIO.TinkerStatus == 2 then
				FAIO.TinkerStatus = 0
			end
		end
	else
		if Menu.IsKeyDownOnce(FAIO.optionHeroTinkerPushKey) then
			FAIO.TinkerPusher = not FAIO.TinkerPusher
		end
	end

	if Menu.GetValue(FAIO.optionHeroTinkerPushMode) < 1 then
		if FAIO.TinkerPusher then
			FAIO.TinkerStatus = 2
			FAIO.TinkerPush(myHero, myMana, march, rearm, blink, travels)
		else
			if FAIO.TinkerStatus == 2 then
				FAIO.TinkerStatus = 0
			end
		end
	end

	if Menu.IsEnabled(FAIO.optionHeroTinkerRocket) then
		if Menu.IsKeyDown(FAIO.optionHeroTinkerRocketKey) then
			FAIO.TinkerStatus = 3	
			FAIO.TinkerRocketSpam(myHero, myMana, missile, rearm, blink)
		else
			if FAIO.TinkerStatus == 3 then
				FAIO.TinkerStatus = 0
			end
		end
	end	

end

function FAIO.TinkerPanicBlink(myHero, blink, rearm)

	if not myHero then return end
	if not blink then return end
	if not rearm then return end

	if FAIO.TinkerPanicRearmBlink < 1 then return end
	if os.clock() - FAIO.TinkerPanicRearmBlink > Ability.GetLevelSpecialValueForFloat(rearm, "channel_tooltip") + 0.58 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING) then return end
	
	if Ability.IsChannelling(rearm) then return end

	local blinkPos = Entity.GetAbsOrigin(myHero) + Entity.GetRotation(myHero):GetForward():Normalized():Scaled(1150)
	Ability.CastPosition(blink, blinkPos)

	return

end

function FAIO.TinkerFullCombo(myHero, enemy, myMana, laser, missile, march, rearm, blink)

	if not myHero then return end
	if not enemy then return end
	if NPC.IsChannellingAbility(myHero) then return end
	
	if FAIO.heroCanCastSpells(myHero, enemy) == true then

		if not NPC.IsEntityInRange(myHero, enemy, 900) then
			if Menu.IsEnabled(FAIO.optionHeroTinkerBlink) and blink and Ability.IsReady(blink) and NPC.IsEntityInRange(myHero, enemy, 1150 + Menu.GetValue(FAIO.optionHeroTinkerBlinkRange)) then
				Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(Menu.GetValue(FAIO.optionHeroTinkerBlinkRange))))
				FAIO.lastTick = os.clock() + 0.15
				return
			end
		end	

		if os.clock() > FAIO.lastTick then
			if not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
				if missile and Ability.IsCastable(missile, myMana) then
					Ability.CastNoTarget(missile)
					FAIO.lastTick = os.clock() + 0.15
					return
				end
				
				if NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(laser)) then
					if laser and Ability.IsCastable(laser, myMana) then
						Ability.CastTarget(laser, enemy)
						FAIO.lastTick = os.clock() + 0.4
						return
					end
				end
			end
			if FAIO.TinkerCheckForFullDMGRearm(myHero, myMana, rearm) then
				if rearm and Ability.IsCastable(rearm, myMana) then
					Ability.CastNoTarget(rearm)
					FAIO.lastTick = os.clock() + Ability.GetLevelSpecialValueForFloat(rearm, "channel_tooltip") + 0.53 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING)
					return
				end
			end
		end
	end
				
	FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_ATTACK_TARGET", enemy, nil)
	return

end

function FAIO.TinkerCheckForFullDMGRearm(myHero, myMana, rearm)

	if not myHero then return false end
	if not rearm then return false end

	local rearmMana = Ability.GetManaCost(rearm)

	local laser = NPC.GetAbilityByIndex(myHero, 0)
 	local missile = NPC.GetAbilityByIndex(myHero, 1)
	local soulRing = NPC.GetItem(myHero, "item_soul_ring", true)
	local eBlade = NPC.GetItem(myHero, "item_ethereal_blade", true)
	local shivas = NPC.GetItem(myHero, "item_shivas_guard", true)
	local dagon = NPC.GetItem(myHero, "item_dagon", true)
		if not dagon then
			for i = 2, 5 do
				dagon = NPC.GetItem(myHero, "item_dagon_" .. i, true)
				if dagon then break end
			end
		end
	
	if (laser and Ability.GetLevel(laser) < 1) or (missile and Ability.GetLevel(missile) < 1) then return false end

	local neededMana = 0
		if laser and Ability.GetLevel(laser) > 0 then
			neededMana = neededMana + Ability.GetManaCost(laser)
		end
		if missile and Ability.GetLevel(missile) > 0 then
			neededMana = neededMana + Ability.GetManaCost(missile)
		end
		if soulRing and Menu.IsEnabled(FAIO.optionItemSoulring) then
			neededMana = neededMana - 150
		end
		
		if neededMana + rearmMana > myMana then return false end

	if laser and Ability.IsReady(laser) then return false end
	if missile and Ability.IsReady(missile) then return false end

	if Menu.GetValue(FAIO.optionItemeBlade) > 0 and eBlade and Ability.IsReady(eBlade) then return false end
	if Menu.GetValue(FAIO.optionItemShivas) > 0 and shivas and Ability.IsReady(shivas) then return false end
	if Menu.GetValue(FAIO.optionItemDagon) > 0 and dagon and Ability.IsReady(dagon) then return false end

	return true

end

function FAIO.TinkerRocketSpam(myHero, myMana, missile, rearm, blink)

	if not myHero then return end
	if NPC.IsChannellingAbility(myHero) then return end

	local mousePos = Input.GetWorldCursorPos()
	local glimmer = NPC.GetItem(myHero, "item_glimmer_cape", true)
	local soulRing = NPC.GetItem(myHero, "item_soul_ring", true)

	if not missile then return end
		if Ability.GetLevel(missile) < 1 then return end

	if FAIO.heroCanCastSpells(myHero, enemy) == false then return end
	if FAIO.isHeroChannelling(myHero) == true then return end 

	local harassTarget = nil
		for _, hero in ipairs(Wrap.HeroesInRadius(myHero, 2350, Enum.TeamType.TEAM_ENEMY)) do
			if hero and Entity.IsHero(hero) and not Entity.IsDormant(hero) and not NPC.IsIllusion(hero) then 
				if Wrap.EIsAlive(hero) and not NPC.HasState(hero, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) then
        				harassTarget = hero
					break
				end
      			end			
		end

	if os.clock() < FAIO.lastTick then return end

	if harassTarget ~= nil then

		if soulRing and Ability.IsReady(soulRing) then
			Ability.CastNoTarget(soulRing)
			FAIO.lastTick = os.clock() + 0.05
			return	
		end

		if Menu.IsEnabled(FAIO.optionHeroTinkerMiscGlimmer) then
			if glimmer and Ability.IsCastable(glimmer, myMana) and os.clock() > FAIO.TinkerGlimmerCastTime then
				Ability.CastTarget(glimmer, myHero)
				FAIO.lastTick = os.clock() + 0.05
				FAIO.TinkerGlimmerCastTime = os.clock() + 5
				return
			end
		end

		local bottle = NPC.GetItem(myHero, "item_bottle", true)
		if bottle then
			if Item.GetCurrentCharges(bottle) > 0 then	
				if not NPC.HasModifier(myHero, "modifier_bottle_regeneration") then
					local hpGap = Entity.GetHealth(myHero) / Entity.GetMaxHealth(myHero)
					local manaGap = NPC.GetMana(myHero) / NPC.GetMaxMana(myHero)
					if hpGap > 0.8 or manaGap > 0.8 then
						Ability.CastNoTarget(bottle)
						FAIO.lastTick = os.clock() + 0.05
						return
					end
				end
			end
		end
	
		if missile and Ability.IsCastable(missile, myMana) then
			Ability.CastNoTarget(missile)
			FAIO.lastTick = os.clock() + 0.05
			return
		end

		if rearm and Ability.IsCastable(rearm, myMana) then
			if myMana > Ability.GetManaCost(missile) + Ability.GetManaCost(rearm) then
				Ability.CastNoTarget(rearm)
				FAIO.lastTick = os.clock() + Ability.GetLevelSpecialValueForFloat(rearm, "channel_tooltip") + 0.53 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING)
				return
			end
		end

	else
		if not NPC.IsPositionInRange(myHero, mousePos, 50, 0) then
			if not Menu.IsEnabled(FAIO.optionHeroTinkerRocketBlink) then
				if Menu.IsEnabled(FAIO.optionHeroTinkerRocketMove) then
					FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, mousePos)
					return
				end
			else
				if not NPC.IsPositionInRange(myHero, mousePos, Menu.GetValue(FAIO.optionHeroTinkerRocketBlinkMin), 0) then
					if blink and Ability.IsReady(blink) then
						if NPC.IsPositionInRange(myHero, mousePos, 1180, 0) then
							Ability.CastPosition(blink, mousePos)
							return
						else
							Ability.CastPosition(blink, (Entity.GetAbsOrigin(myHero) + (mousePos - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(1180)))
							return
						end
					else
						FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, mousePos)
						return
					end
				else
					FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, mousePos)
					return
				end
			end
		end
	end

	return	

end

function FAIO.TinkerAmIAtFountain(myHero)

	if not myHero then return false end

	local myFountainPos = FAIO.GetMyFountainPos(myHero)
	local myPos = Entity.GetAbsOrigin(myHero)

	local dist = (myFountainPos - myPos):Length2D()

	if dist < 1600 then
		return true
	end

	return false
	
end

function FAIO.TinkerIsFarmTupleAlive(myHero, camp1, camp2)

	if not myHero then return false end
	if next(FAIO.JungleTrackTable) == nil then return false end

	local check = false
	local checkPos = false
	for _, info in ipairs(FAIO.JungleTrackTable) do
		if info then
			local pos = info[1]
			local alive = info[2]
			if (camp1 - pos):Length2D() < 250 and alive then
				checkPos = true
			end
			if checkPos then
				if (camp2 - pos):Length2D() < 250 and alive then
					check = true
					break
				end
			end
		end
	end

	return check

end

function FAIO.TinkerSetCampsToCleared(myHero, pos)

	if not myHero then return end
	if not pos then return end
		pos:SetZ(0)

	local minute = math.floor((GameRules.GetGameTime() - GameRules.GetGameStartTime()) / 60)

	for i, v in ipairs(FAIO.JungleTrackTable) do
		if v then
			local campPos = v[1]
			local alive = v[2]
			if (pos - campPos):Length2D() < 1500 then
				if alive then
					FAIO.JungleTrackTable[i][2] = false
					FAIO.JungleTrackTable[i][3] = minute
				end
			end
		end
	end

	return

end

function FAIO.TinkerIsShrineAlive(myHero, pos)
	
	if not myHero then return false end
	if not pos then return false end

	for i = 1, NPCs.Count() do
		local npcs = NPCs.Get(i)
		if npcs and Wrap.EIsNPC(npcs) and Entity.IsSameTeam(myHero, npcs) and NPC.IsStructure(npcs) and Wrap.EIsAlive(npcs) then
			if Entity.GetClassName(npcs) == "C_DOTA_BaseNPC_Healer" then
				local entityPos = Entity.GetAbsOrigin(npcs)
				if (entityPos - pos):Length2D() < 6000 then
					return true
				end
			end
		end
	end

	return false

end

function FAIO.GenericJungleTracker(myHero)

	if not myHero then return end
	if GameRules.GetGameStartTime() < 1 then return end
	if GameRules.GetGameTime() - GameRules.GetGameStartTime() < 59 then return end

	local minute = math.floor((GameRules.GetGameTime() - GameRules.GetGameStartTime()) / 60)
	local respawnChecker = false
		if (((GameRules.GetGameTime() - GameRules.GetGameStartTime()) / 60) - minute) > 0.99 or (((GameRules.GetGameTime() - GameRules.GetGameStartTime()) / 60) - minute) < 0.02 then
			respawnChecker = true
		end
	
	if next(FAIO.JungleTrackTable) == nil then
		for i = 1, 14 do
			table.insert(FAIO.JungleTrackTable, { FAIO.JunglePositionTable[i][1], true, minute, FAIO.JunglePositionTable[i][4], FAIO.JunglePositionTable[i][2], FAIO.JunglePositionTable[i][3] })
		end
	end

	if next(FAIO.ShrinePositionTable) == nil then
		if FAIO.GetMyFaction(myHero) == "radiant" then
			FAIO.ShrinePositionTable = {	
				top = Vector(-4389, 211, 0),
				bot = Vector(1313, -4163, 0)
					}
		else
			FAIO.ShrinePositionTable = {	
				bot = Vector(3443, 316, 0),
				top = Vector(-1221, 3905, 0)
					}
		end
	end

	if respawnChecker then
		for key, info in ipairs(FAIO.JungleTrackTable) do
			if info then
				local update = info[3]
				local pos = info[1]
				if minute > update then
					if #Wrap.HInRadius(pos, 800, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_BOTH) < 1 then
						FAIO.JungleTrackTable[key][2] = true
						FAIO.JungleTrackTable[key][3] = minute
					else
						FAIO.JungleTrackTable[key][3] = minute
					end
				end
			end
		end
	end

	return	

end

function FAIO.TinkerGetJunglePos(myHero, march, rearm)

	if not myHero then return end
	if next(FAIO.JungleTrackTable) == nil then return end
	if not march then return end
		if Ability.GetLevel(march) < 4 then return end
	if not rearm then return end

	local soulRing = NPC.GetItem(myHero, "item_soul_ring", true)
	local myMaxMana = NPC.GetMaxMana(myHero)
		local marchCount = 3
		if NPC.HasAbility(myHero, "special_bonus_unique_tinker_2") and Ability.GetLevel(NPC.GetAbility(myHero, "special_bonus_unique_tinker_2")) > 0 then
			marchCount = 2
		end
		local neededMana = Ability.GetManaCost(rearm) * (marchCount - 1) + Ability.GetManaCost(march) * marchCount
			if soulRing then
				neededMana = neededMana - (marchCount * 150)
			end
		if myMaxMana < neededMana then return end

	local farmRadiantTop = {{ Vector(-4862, -477, 0), Vector(-3707, 878, 0) }}
	local farmRadiantBottom = {{ Vector(-1845, -4214, 0), Vector(-416, -3345, 0) }, { Vector(4591, -4354, 0), Vector(2889, -4558, 0) }}
	local farmDireBottom = {{ Vector(4411, 847, 0), Vector(2554, 81, 0) }}
	local farmDireTop = {{ Vector(-2000, 4275, 0), Vector(-2677, 4593, 0) }, { Vector(1349, 3317, 0), Vector(-227, 3396, 0) }}

	local myFaction = FAIO.GetMyFaction(myHero)

	if next(FAIO.TinkerJungleFarmPos) == nil then
		if myFaction == "radiant" then
			if FAIO.TinkerIsFarmTupleAlive(myHero, farmRadiantTop[1][1], farmRadiantTop[1][2]) then
				if FAIO.TinkerIsShrineAlive(myHero, farmRadiantTop[1][1]) then
					FAIO.TinkerJungleFarmPos = { Vector(-4620, 156, 256), Vector(-4568, 252, 256) }
				end
			elseif FAIO.TinkerIsFarmTupleAlive(myHero, farmRadiantBottom[1][1], farmRadiantBottom[1][2]) then
				if FAIO.TinkerIsShrineAlive(myHero, farmRadiantBottom[1][1]) then
					FAIO.TinkerJungleFarmPos = { Vector(-903, -4109, 384), Vector(-1033, -3828, 256) }
				end
			elseif FAIO.TinkerIsFarmTupleAlive(myHero, farmRadiantBottom[2][1], farmRadiantBottom[2][2]) then
				if FAIO.TinkerIsShrineAlive(myHero, farmRadiantBottom[1][1]) then
					FAIO.TinkerJungleFarmPos = { Vector(3670, -4655, 256), Vector(3757, -4497, 256) }
				end
			end
		else
			if FAIO.TinkerIsFarmTupleAlive(myHero, farmDireBottom[1][1], farmDireBottom[1][2]) then
				if FAIO.TinkerIsShrineAlive(myHero, farmDireBottom[1][1]) then
					FAIO.TinkerJungleFarmPos = { Vector(3520, 155, 384), Vector(3696, 321, 384) }
				end
			elseif FAIO.TinkerIsFarmTupleAlive(myHero, farmDireTop[1][1], farmDireTop[1][2]) then
				if FAIO.TinkerIsShrineAlive(myHero, farmDireTop[1][1]) then
					FAIO.TinkerJungleFarmPos = { Vector(-2406, 3738, 256), Vector(-2409, 3863, 256) }
				end
			elseif FAIO.TinkerIsFarmTupleAlive(myHero, farmDireTop[2][1], farmDireTop[2][2]) then
				if FAIO.TinkerIsShrineAlive(myHero, farmDireTop[1][1]) then
					FAIO.TinkerJungleFarmPos = { Vector(474, 3788, 384), Vector(583, 3650, 384) }
				end
			end
		end
	end

	return
	
end

function FAIO.TinkerJungleFarm(myHero, myMana, march, rearm, blink, travels)

	if not myHero then return end

	if next(FAIO.TinkerJungleFarmPos) == nil then return end

	local movePos = FAIO.TinkerJungleFarmPos[1]
	local castPos = FAIO.TinkerJungleFarmPos[2]

	local marchCount = 3
		if NPC.HasAbility(myHero, "special_bonus_unique_tinker_2") and Ability.GetLevel(NPC.GetAbility(myHero, "special_bonus_unique_tinker_2")) > 0 then
			marchCount = 2
		end

	if not NPC.IsPositionInRange(myHero, movePos, 35, 0) then
		if blink and Ability.IsCastable(blink, myMana) and (Entity.GetAbsOrigin(myHero) - movePos):Length2D() > 500 then
			if (Entity.GetAbsOrigin(myHero) - movePos):Length2D() > 1190 then
				local blinkPos = Entity.GetAbsOrigin(myHero) + (movePos - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(1190)
				if #Wrap.TInRadius(blinkPos, 150, true) < 1 then
					Ability.CastPosition(blink, blinkPos)
					FAIO.lastTick = os.clock() + 0.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
					return
				end
			else
				Ability.CastPosition(blink, movePos)
				FAIO.lastTick = os.clock() + 0.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
				return
			end
		end
		FAIO.GenericMainAttack(myHero, "Enum.UnitOrder.DOTA_UNIT_ORDER_MOVE_TO_POSITION", nil, movePos)
	end

	if not NPC.IsRunning(myHero) and NPC.IsPositionInRange(myHero, movePos, 35, 0) then
		if FAIO.TinkerMarched < marchCount then	
			if Ability.IsCastable(march, myMana) then
				Ability.CastPosition(march, castPos)
				FAIO.TinkerMarched = FAIO.TinkerMarched + 1
				FAIO.lastTick = os.clock() + 0.65 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
				return
			else
				if rearm and Ability.IsCastable(rearm, myMana) then
					Ability.CastNoTarget(rearm)
					FAIO.lastTick = os.clock() + Ability.GetLevelSpecialValueForFloat(rearm, "channel_tooltip") + 0.58 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
					return
				else
					if Ability.IsCastable(travels, myMana) then
						Ability.CastPosition(travels, FAIO.GetMyFountainPos(myHero))
						FAIO.lastTick = os.clock() + 3.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
						FAIO.TinkerMarched = 0
						FAIO.TinkerJungle = false
						FAIO.TinkerJungleFarmPos = {}
						FAIO.TinkerSetCampsToCleared(myHero, castPos)
						return
					end
				end
			end
		else
			if Ability.IsCastable(travels, myMana) then
				Ability.CastPosition(travels, FAIO.GetMyFountainPos(myHero))
				FAIO.lastTick = os.clock() + 3.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
				FAIO.TinkerMarched = 0
				FAIO.TinkerJungle = false
				FAIO.TinkerJungleFarmPos = {}
				FAIO.TinkerSetCampsToCleared(myHero, castPos)
				return
			else
				if rearm and Ability.IsCastable(rearm, myMana) then
					Ability.CastNoTarget(rearm)
					FAIO.lastTick = os.clock() + Ability.GetLevelSpecialValueForFloat(rearm, "channel_tooltip") + 0.58 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
					return
				end
			end
		end
	end

	return	
				
end

function FAIO.TinkerPush(myHero, myMana, march, rearm, blink, travels)

	if not myHero then return end
	if NPC.IsChannellingAbility(myHero) then return end

	local mousePos = Input.GetWorldCursorPos()

	if not travels then return end

	if not march then return end
		if Ability.GetLevel(march) < 1 then return end

	local glimmer = NPC.GetItem(myHero, "item_glimmer_cape", true)

	if FAIO.heroCanCastSpells(myHero, enemy) == false then return end
	if FAIO.isHeroChannelling(myHero) == true then return end 

	if os.clock() < FAIO.lastTick then 
		return 
	else
		if NPC.IsRunning(myHero) and FAIO.TinkerJungle == false then
			Player.HoldPosition(Players.GetLocal(), myHero, false)
		end
	end

	if FAIO.TinkerFarmDANGER(myHero) then
		if FAIO.TinkerPushDefend then
			local hex = NPC.GetItem(myHero, "item_sheepstick", true)
			local blood = NPC.GetItem(myHero, "item_bloodthorn", true)
			local eBlade = NPC.GetItem(myHero, "item_ethereal_blade", true)
			local orchid = NPC.GetItem(myHero, "item_orchid", true)
			if FAIO.TinkerFarmFindDANGERnpc(myHero) ~= nil then
				local target = FAIO.TinkerFarmFindDANGERnpc(myHero)
				if hex and Ability.IsCastable(blink, myMana) then
					Ability.CastTarget(hex, target)
					FAIO.lastTick = os.clock() + 0.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
					return
				end
				if eBlade and Ability.IsCastable(eBlade, myMana) and not NPC.HasState(target, Enum.ModifierState.MODIFIER_STATE_HEXED) then
					Ability.CastTarget(eBlade, target)
					FAIO.lastTick = os.clock() + 0.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
					return
				end
				if blood and Ability.IsCastable(blood, myMana) and not NPC.HasState(target, Enum.ModifierState.MODIFIER_STATE_HEXED) then
					Ability.CastTarget(blood, target)
					FAIO.lastTick = os.clock() + 0.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
					return
				end
				if orchid and Ability.IsCastable(orchid, myMana) and not NPC.HasState(target, Enum.ModifierState.MODIFIER_STATE_HEXED) then
					Ability.CastTarget(orchid, target)
					FAIO.lastTick = os.clock() + 0.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
					return
				end
			end
		end	
		if blink and Ability.IsCastable(blink, myMana) then
			local saveSpot = FAIO.TinkerFarmGetSaveSpot(myHero, myHero, blink)
			if saveSpot ~= nil and (Entity.GetAbsOrigin(myHero) - saveSpot):Length2D() > 375 then
				Ability.CastPosition(blink, saveSpot)
				FAIO.lastTick = os.clock() + 0.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
				return
			else
				Ability.CastPosition(blink, Entity.GetAbsOrigin(myHero) + (FAIO.GetMyFountainPos(myHero) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(1150))
				FAIO.lastTick = os.clock() + 0.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
				return
			end
		end
	end
		
	if NPC.HasModifier(myHero, "modifier_fountain_aura_buff") and FAIO.TinkerAmIAtFountain(myHero) then
		if not Ability.IsReady(march) or Ability.SecondsSinceLastUse(travels) > -1 then
			if rearm and Ability.IsCastable(rearm, myMana) then
				Ability.CastNoTarget(rearm)
				FAIO.lastTick = os.clock() + Ability.GetLevelSpecialValueForFloat(rearm, "channel_tooltip") + 0.58 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
				return
			end
		end

		if (NPC.GetMana(myHero) / NPC.GetMaxMana(myHero)) > 0.8 then
			if FAIO.TinkerPorted then
				FAIO.TinkerPorted = false
				FAIO.TinkerJungleFarmPos = {}
				FAIO.TinkerJungle = false
				return
			end
		end
	end

	if not FAIO.TinkerPorted then
		if FAIO.TinkerAmIAtFountain(myHero) then
			if (NPC.GetMana(myHero) / NPC.GetMaxMana(myHero)) > 0.8 then	
				if FAIO.TinkerPort(myHero, blink) ~= nil then
					if Ability.IsCastable(travels, myMana) then
						Ability.CastPosition(travels, FAIO.TinkerPort(myHero, blink))
						FAIO.lastTick = os.clock() + 3.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
						FAIO.TinkerPorted = true
						FAIO.TinkerMarched = 0
						if Menu.IsEnabled(FAIO.optionHeroTinkerMiscGlimmer) then
							if glimmer and Ability.IsCastable(glimmer, myMana) and os.clock() > FAIO.TinkerGlimmerCastTime then
								Ability.CastTarget(glimmer, myHero)
								FAIO.TinkerGlimmerCastTime = os.clock() + 5
								return
							end
						end
						return
					end
				else
					if FAIO.TinkerPushJungle then
						FAIO.TinkerGetJunglePos(myHero, march, rearm)
						if next(FAIO.TinkerJungleFarmPos) ~= nil then
							if Ability.IsCastable(travels, myMana) then
								Ability.CastPosition(travels, FAIO.TinkerJungleFarmPos[1])
								FAIO.lastTick = os.clock() + 3.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
								FAIO.TinkerPorted = true
								FAIO.TinkerJungle = true
								FAIO.TinkerMarched = 0
								return
							end
						end
					end
				end
			end
		else
			if (NPC.GetMana(myHero) / NPC.GetMaxMana(myHero)) > 0.6 then	
				if FAIO.TinkerPort(myHero, blink) ~= nil then
					if Ability.IsCastable(travels, myMana) then
						Ability.CastPosition(travels, FAIO.TinkerPort(myHero, blink))
						FAIO.lastTick = os.clock() + 3.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
						FAIO.TinkerPorted = true
						FAIO.TinkerMarched = 0
						if Menu.IsEnabled(FAIO.optionHeroTinkerMiscGlimmer) then
							if glimmer and Ability.IsCastable(glimmer, myMana) and os.clock() > FAIO.TinkerGlimmerCastTime then
								Ability.CastTarget(glimmer, myHero)
								FAIO.TinkerGlimmerCastTime = os.clock() + 5
								return
							end
						end
						return
					end
				else
					if FAIO.TinkerPushJungle then
						FAIO.TinkerGetJunglePos(myHero, march, rearm)
						if next(FAIO.TinkerJungleFarmPos) ~= nil then
							if Ability.IsCastable(travels, myMana) then
								Ability.CastPosition(travels, FAIO.TinkerJungleFarmPos[1])
								FAIO.lastTick = os.clock() + 3.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
								FAIO.TinkerPorted = true
								FAIO.TinkerJungle = true
								FAIO.TinkerMarched = 0
								return
							end
						end
					end
				end
			else
				if Ability.IsCastable(travels, myMana) then
					Ability.CastPosition(travels, FAIO.GetMyFountainPos(myHero))
					FAIO.lastTick = os.clock() + 3.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
					FAIO.TinkerPorted = false
					FAIO.TinkerMarched = 0
					FAIO.TinkerJungle = false
					return
				end
			end
		end
	end

	local soulRing = NPC.GetItem(myHero, "item_soul_ring", true)
		if soulRing and Ability.IsReady(soulRing) then
			if not FAIO.TinkerAmIAtFountain(myHero) then
				Ability.CastNoTarget(soulRing)
				Player.HoldPosition(Players.GetLocal(), myHero, true)
				FAIO.lastTick = os.clock() + 0.1 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
				return
			else
				if (NPC.GetMana(myHero) / NPC.GetMaxMana(myHero)) > 0.7 then
					Ability.CastNoTarget(soulRing)
					Player.HoldPosition(Players.GetLocal(), myHero, true)
					FAIO.lastTick = os.clock() + 0.1 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
					return
				end
			end	
		end

		if Menu.IsEnabled(FAIO.optionHeroTinkerMiscGlimmer) then
			if glimmer and Ability.IsCastable(glimmer, myMana) and os.clock() > FAIO.TinkerGlimmerCastTime then
				Ability.CastTarget(glimmer, myHero)
				FAIO.lastTick = os.clock() + 0.1 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
				FAIO.TinkerGlimmerCastTime = os.clock() + 5
				return
			end
		end

	local bottle = NPC.GetItem(myHero, "item_bottle", true)
		if bottle then
			if Item.GetCurrentCharges(bottle) > 0 then	
				if not NPC.HasModifier(myHero, "modifier_bottle_regeneration") then
					local hpGap = Entity.GetHealth(myHero) / Entity.GetMaxHealth(myHero)
					local manaGap = NPC.GetMana(myHero) / NPC.GetMaxMana(myHero)
					if hpGap < 0.8 or manaGap < 0.8 then
						Ability.CastNoTarget(bottle)
						FAIO.lastTick = os.clock() + 0.1 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
						return
					end
				end
			end
		end
	
	local targetCreep = nil
	for _, v in ipairs(Wrap.UnitsInRadius(myHero, 1150, Enum.TeamType.TEAM_ENEMY)) do
		if v and Wrap.EIsNPC(v) and Wrap.EIsAlive(v) and not Entity.IsDormant(v) and NPC.IsLaneCreep(v) and not NPC.IsWaitingToSpawn(v) and NPC.GetUnitName(v) ~= nil and NPC.GetUnitName(v) ~= "npc_dota_neutral_caster" then
			if FAIO.TinkerPortGetCreepCount(myHero, myHero, 1250) >= 2 + FAIO.TinkerMarched then
				targetCreep = v
				break
			end
		end
	end

	if FAIO.TinkerJungle then
		FAIO.TinkerJungleFarm(myHero, myMana, march, rearm, blink, travels)
	else
		if targetCreep ~= nil then
			if blink and Ability.IsCastable(blink, myMana) and not FAIO.TinkerFarmAmISave(myHero) then
				local saveSpot = FAIO.TinkerFarmGetSaveSpot(myHero, targetCreep, blink)
				if saveSpot ~= nil and (Entity.GetAbsOrigin(myHero) - saveSpot):Length2D() > 375 then
					Ability.CastPosition(blink, saveSpot)
					Player.HoldPosition(Players.GetLocal(), myHero, true)
					FAIO.lastTick = os.clock() + 0.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
					return
				end
			end

			if FAIO.TinkerMarched < Menu.GetValue(FAIO.optionHeroTinkerPushMarch) then
				if Ability.IsCastable(march, myMana) then
					Ability.CastPosition(march, Entity.GetAbsOrigin(myHero) + (Entity.GetAbsOrigin(targetCreep) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(Ability.GetCastRange(march) - 1))
					FAIO.lastTick = os.clock() + 0.75 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
					FAIO.TinkerMarched = FAIO.TinkerMarched + 1
					return
				else
					if rearm and Ability.IsCastable(rearm, myMana) then
						Ability.CastNoTarget(rearm)
						FAIO.lastTick = os.clock() + Ability.GetLevelSpecialValueForFloat(rearm, "channel_tooltip") + 0.58 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
						return
					else
						if Ability.IsCastable(travels, myMana) then
							Ability.CastPosition(travels, FAIO.GetMyFountainPos(myHero))
							FAIO.lastTick = os.clock() + 3.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
							FAIO.TinkerMarched = 0
							if FAIO.TinkerPushMode then
								FAIO.TinkerPusher = false
							end
							return
						end
					end
				end
			else
				if FAIO.TinkerPushMode then
					if Ability.IsCastable(travels, myMana) then
						if blink and Ability.IsCastable(blink, myMana) and not FAIO.TinkerFarmAmISave(myHero) then
							local saveSpot = FAIO.TinkerFarmGetSaveSpot(myHero, myHero, blink)
							if saveSpot ~= nil and (Entity.GetAbsOrigin(myHero) - saveSpot):Length2D() > 375 then
								Ability.CastPosition(blink, saveSpot)
								FAIO.lastTick = os.clock() + 0.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
								return
							else
								Ability.CastPosition(blink, Entity.GetAbsOrigin(myHero) + (FAIO.GetMyFountainPos(myHero) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(1150))
								FAIO.lastTick = os.clock() + 0.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
								return
							end
						end
						Ability.CastPosition(travels, FAIO.GetMyFountainPos(myHero))
						FAIO.lastTick = os.clock() + 3.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
						FAIO.TinkerMarched = 0
						FAIO.TinkerPusher = false
						return
					else
						if rearm and Ability.IsCastable(rearm, myMana) then
							Ability.CastNoTarget(rearm)
							FAIO.lastTick = os.clock() + Ability.GetLevelSpecialValueForFloat(rearm, "channel_tooltip") + 0.58 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
							return
						end
					end
				else	
					if NPC.GetMana(myHero) / NPC.GetMaxMana(myHero) < 0.6 then
						if Ability.IsCastable(travels, myMana) then
							if blink and Ability.IsCastable(blink, myMana) and not FAIO.TinkerFarmAmISave(myHero) then
								local saveSpot = FAIO.TinkerFarmGetSaveSpot(myHero, myHero, blink)
								if saveSpot ~= nil and (Entity.GetAbsOrigin(myHero) - saveSpot):Length2D() > 375 then
									Ability.CastPosition(blink, saveSpot)
									FAIO.lastTick = os.clock() + 0.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
									return
								else
									Ability.CastPosition(blink, Entity.GetAbsOrigin(myHero) + (FAIO.GetMyFountainPos(myHero) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(1150))
									FAIO.lastTick = os.clock() + 0.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
									return
								end
							end
							Ability.CastPosition(travels, FAIO.GetMyFountainPos(myHero))
							FAIO.lastTick = os.clock() + 3.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
							FAIO.TinkerMarched = 0
							return
						else
							if rearm and Ability.IsCastable(rearm, myMana) then
								Ability.CastNoTarget(rearm)
								FAIO.lastTick = os.clock() + Ability.GetLevelSpecialValueForFloat(rearm, "channel_tooltip") + 0.58 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
								return
							end
						end
					else
						if FAIO.TinkerPort(myHero, blink) ~= nil then
							if Ability.IsCastable(travels, myMana) then
								if blink and Ability.IsCastable(blink, myMana) and not FAIO.TinkerFarmAmISave(myHero) then
									local saveSpot = FAIO.TinkerFarmGetSaveSpot(myHero, myHero, blink)
									if saveSpot ~= nil and (Entity.GetAbsOrigin(myHero) - saveSpot):Length2D() > 375 then
										Ability.CastPosition(blink, saveSpot)
										FAIO.lastTick = os.clock() + 0.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
										return
									else
										Ability.CastPosition(blink, Entity.GetAbsOrigin(myHero) + (FAIO.GetMyFountainPos(myHero) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(1150))
										FAIO.lastTick = os.clock() + 0.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
										return
									end
								end
								if blink and Ability.IsReady(blink) then
									FAIO.TinkerPorted = false
									FAIO.TinkerMarched = 0
									return
								else
									Ability.CastPosition(travels, FAIO.GetMyFountainPos(myHero))
									FAIO.lastTick = os.clock() + 3.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
									FAIO.TinkerMarched = 0
									return
								end	
							else
								if rearm and Ability.IsCastable(rearm, myMana) then
									Ability.CastNoTarget(rearm)
									FAIO.lastTick = os.clock() + Ability.GetLevelSpecialValueForFloat(rearm, "channel_tooltip") + 0.58 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
									return
								end
							end
						else
							if Ability.IsCastable(travels, myMana) then
								if blink and Ability.IsCastable(blink, myMana) and not FAIO.TinkerFarmAmISave(myHero) then
									local saveSpot = FAIO.TinkerFarmGetSaveSpot(myHero, myHero, blink)
									if saveSpot ~= nil and (Entity.GetAbsOrigin(myHero) - saveSpot):Length2D() > 375 then
										Ability.CastPosition(blink, saveSpot)
										FAIO.lastTick = os.clock() + 0.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
										return
									else
										Ability.CastPosition(blink, Entity.GetAbsOrigin(myHero) + (FAIO.GetMyFountainPos(myHero) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(1150))
										FAIO.lastTick = os.clock() + 0.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
										return
									end
								end
								Ability.CastPosition(travels, FAIO.GetMyFountainPos(myHero))
								FAIO.lastTick = os.clock() + 3.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
								FAIO.TinkerMarched = 0
								return
							else
								if rearm and Ability.IsCastable(rearm, myMana) then
									Ability.CastNoTarget(rearm)
									FAIO.lastTick = os.clock() + Ability.GetLevelSpecialValueForFloat(rearm, "channel_tooltip") + 0.58 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
									return
								end
							end
						end
					end
				end
			end
		else
			if not FAIO.TinkerAmIAtFountain(myHero) then
				if FAIO.TinkerPushMode then
					if Ability.IsCastable(travels, myMana) then
						if blink and Ability.IsCastable(blink, myMana) and not FAIO.TinkerFarmAmISave(myHero) then
							local saveSpot = FAIO.TinkerFarmGetSaveSpot(myHero, myHero, blink)
							if saveSpot ~= nil and (Entity.GetAbsOrigin(myHero) - saveSpot):Length2D() > 375 then
								Ability.CastPosition(blink, saveSpot)
								FAIO.lastTick = os.clock() + 0.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
								return
							else
								Ability.CastPosition(blink, Entity.GetAbsOrigin(myHero) + (FAIO.GetMyFountainPos(myHero) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(1150))
								FAIO.lastTick = os.clock() + 0.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
								return
							end
						end
						Ability.CastPosition(travels, FAIO.GetMyFountainPos(myHero))
						FAIO.lastTick = os.clock() + 3.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
						FAIO.TinkerMarched = 0
						FAIO.TinkerPusher = false
						return
					else
						if rearm and Ability.IsCastable(rearm, myMana) then
							Ability.CastNoTarget(rearm)
							FAIO.lastTick = os.clock() + Ability.GetLevelSpecialValueForFloat(rearm, "channel_tooltip") + 0.58 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
							return
						end
					end
				else	
					if NPC.GetMana(myHero) / NPC.GetMaxMana(myHero) < 0.6 then
						if FAIO.TinkerPorted then
							if Ability.IsCastable(travels, myMana) then
								if blink and Ability.IsCastable(blink, myMana) and not FAIO.TinkerFarmAmISave(myHero) then
									local saveSpot = FAIO.TinkerFarmGetSaveSpot(myHero, myHero, blink)
									if saveSpot ~= nil and (Entity.GetAbsOrigin(myHero) - saveSpot):Length2D() > 375 then
										Ability.CastPosition(blink, saveSpot)
										FAIO.lastTick = os.clock() + 0.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
										return
									else
										Ability.CastPosition(blink, Entity.GetAbsOrigin(myHero) + (FAIO.GetMyFountainPos(myHero) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(1150))
										FAIO.lastTick = os.clock() + 0.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
										return
									end
								end
								Ability.CastPosition(travels, FAIO.GetMyFountainPos(myHero))
								FAIO.lastTick = os.clock() + 3.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
								FAIO.TinkerMarched = 0
								return
							else
								if rearm and Ability.IsCastable(rearm, myMana) then
									Ability.CastNoTarget(rearm)
									FAIO.lastTick = os.clock() + Ability.GetLevelSpecialValueForFloat(rearm, "channel_tooltip") + 0.58 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
									return
								end
							end
						end
					else
						if FAIO.TinkerPort(myHero, blink) ~= nil then
							if Ability.IsCastable(travels, myMana) then
								if blink and Ability.IsCastable(blink, myMana) and not FAIO.TinkerFarmAmISave(myHero) then
									local saveSpot = FAIO.TinkerFarmGetSaveSpot(myHero, myHero, blink)
									if saveSpot ~= nil and (Entity.GetAbsOrigin(myHero) - saveSpot):Length2D() > 375 then
										Ability.CastPosition(blink, saveSpot)
										FAIO.lastTick = os.clock() + 0.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
										return
									else
										Ability.CastPosition(blink, Entity.GetAbsOrigin(myHero) + (FAIO.GetMyFountainPos(myHero) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(1150))
										FAIO.lastTick = os.clock() + 0.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
										return
									end
								end
								if blink and Ability.IsReady(blink) then
									FAIO.TinkerPorted = false
									FAIO.TinkerMarched = 0
									return
								else
									Ability.CastPosition(travels, FAIO.GetMyFountainPos(myHero))
									FAIO.lastTick = os.clock() + 3.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
									FAIO.TinkerMarched = 0
									return
								end	
							else
								if rearm and Ability.IsCastable(rearm, myMana) then
									Ability.CastNoTarget(rearm)
									FAIO.lastTick = os.clock() + Ability.GetLevelSpecialValueForFloat(rearm, "channel_tooltip") + 0.58 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
									return
								end
							end
						else
							if FAIO.TinkerPorted then
								if Ability.IsCastable(travels, myMana) then
									if blink and Ability.IsCastable(blink, myMana) and not FAIO.TinkerFarmAmISave(myHero) then
										local saveSpot = FAIO.TinkerFarmGetSaveSpot(myHero, myHero, blink)
										if saveSpot ~= nil and (Entity.GetAbsOrigin(myHero) - saveSpot):Length2D() > 375 then
											Ability.CastPosition(blink, saveSpot)
											FAIO.lastTick = os.clock() + 0.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
											return
										else
											Ability.CastPosition(blink, Entity.GetAbsOrigin(myHero) + (FAIO.GetMyFountainPos(myHero) - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(1150))
											FAIO.lastTick = os.clock() + 0.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
											return
										end
									end
									Ability.CastPosition(travels, FAIO.GetMyFountainPos(myHero))
									FAIO.lastTick = os.clock() + 3.05 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
									FAIO.TinkerMarched = 0
									return
								else
									if rearm and Ability.IsCastable(rearm, myMana) then
										Ability.CastNoTarget(rearm)
										FAIO.lastTick = os.clock() + Ability.GetLevelSpecialValueForFloat(rearm, "channel_tooltip") + 0.58 + NetChannel.GetLatency(Enum.Flow.FLOW_OUTGOING) + NetChannel.GetLatency(Enum.Flow.FLOW_INCOMING)
										return
									end
								end
							end
						end
					end
				end
			end
		end
	end

	return

end

function FAIO.TinkerFarmAmISave(myHero)

	if not myHero then return false end

	local myPos = Entity.GetAbsOrigin(myHero)

	for _, hero in ipairs(Wrap.HeroesInRadius(myHero, 200, Enum.TeamType.TEAM_ENEMY)) do
		if hero and Entity.IsHero(hero) then
			if FAIO.targetChecker(hero) ~= nil then
				return false
			end
		end
	end

	local saveSpotTable = {
		{ Vector(-7332.3, -3269.6, 384.0), 5},
		{ Vector(-7233.3, -1376.7, 384.0), 10}, 
		{ Vector(-7200.2, -1017.2, 384.0), 8}, 
		{ Vector(-7212.0, -551.6, 384.0), 8}, 
		{ Vector(-7125.0, -81.5, 384.0), 8},
		{ Vector(-7114.0, 337.9, 384.0), 5}, 
		{ Vector(-7194.7, 732.3, 384.0), 5}, 
		{ Vector(-7129.5, 1337.3, 384.0), 7},
		{ Vector(-7140.7, 1645.0, 384.0), 7},
		{ Vector(-7176.3, 2070.1, 384.0), 6}, 
		{ Vector(-7089.6, 2307.1, 512.0), 5}, 
		{ Vector(-6847.4, 3532.0, 384.0), 5}, 
		{ Vector(-7226.3, 3989.3, 384.0), 7}, 
		{ Vector(-6994.7, 4915.7, 384.0), 7}, 
		{ Vector(-6900.2, 5118.8, 384.0), 7}, 
		{ Vector(-6732.6, 5540.4, 384.0), 4}, 
		{ Vector(-6581.3, 5919.3, 384.0), 6}, 
		{ Vector(-6273.9, 6178.2, 384.0), 6}, 
		{ Vector(-6104.3, 6542.5, 384.0), 6}, 
		{ Vector(-5458.8, 6709.4, 384.0), 11}, 
		{ Vector(-5130.0, 6783.1, 384.0), 7}, 
		{ Vector(-4631.4, 6760.8, 384.0), 6}, 
		{ Vector(-4308.8, 6977.7, 384.0), 6}, 
		{ Vector(-3791.8, 6757.7, 384.0), 11}, 
		{ Vector(-3497.5, 6873.4, 384.0), 8}, 
		{ Vector(-3117.5, 6930.3, 384.0), 9}, 
		{ Vector(-2696.9, 6878.1, 384.0), 7}, 
		{ Vector(-2321.5, 6938.8, 384.0), 7}, 
		{ Vector(-1731.7, 6864.3, 384.0), 8}, 
		{ Vector(-1100.2, 6951.0, 384.0), 9}, 
		{ Vector(-767.3, 7021.9, 384.0), 11}, 
		{ Vector(-82.5, 6823.9, 384.0), 7}, 
		{ Vector(183.7, 6728.6, 384.0), 7},
		{ Vector(673.7, 6884.9, 384.0), 13}, 
		{ Vector(1009.9, 6861.5, 384.0), 10}, 
		{ Vector(1561.7, 6964.7, 384.0), 6}, 
		{ Vector(2540.2, 6960.1, 384.0), 4}, 
		{ Vector(3445.1, 6863.7, 384.0), 5}, 
		{ Vector(7400.6, 2808.3, 384.0), 6}, 
		{ Vector(7456.3, 2090.7, 256.0), 6}, 
		{ Vector(7226.0, 866.5, 384.0), 7}, 
		{ Vector(7029.8, 494.1, 384.0), 7}, 
		{ Vector(7086.8, -37.7, 384.0), 8}, 
		{ Vector(6932.5, -577.0, 384.0), 4}, 
		{ Vector(6918.2, -908.3, 384.0), 8}, 
		{ Vector(7080.6, -1472.4, 384.0), 7}, 
		{ Vector(7171.4, -1807.0, 384.0), 7}, 
		{ Vector(7297.8, -2177.6, 384.0), 9}, 
		{ Vector(7031.2, -3224.0, 384.0), 5}, 
		{ Vector(6898.3, -3549.7, 384.0), 7}, 
		{ Vector(7460.4, -4648.6, 384.0), 8}, 
		{ Vector(6924.8, -4814.6, 384.0), 6}, 
		{ Vector(6891.3, -5163.1, 384.0), 7}, 
		{ Vector(6701.0, -5480.9, 384.0), 5}, 
		{ Vector(6647.3, -5824.5, 384.0), 10},
		{ Vector(6583.7, -6132.0, 384.0), 11}, 
		{ Vector(6381.3, -6424.0, 384.0), 9}, 
		{ Vector(6059.3, -6451.0, 384.0), 9}, 
		{ Vector(6021.2, -6588.0, 384.0), 8}, 
		{ Vector(5650.1, -6737.3, 384.0), 5}, 
		{ Vector(5378.8, -6735.7, 384.0), 7}, 
		{ Vector(4971.6, -6738.0, 384.0), 7}, 
		{ Vector(4536.9, -6652.2, 384.0), 6}, 
		{ Vector(4333.0, -6725.9, 384.0), 8}, 
		{ Vector(3879.9, -6734.2, 384.0), 10}, 
		{ Vector(3364.7, -6777.9, 384.0), 9}, 
		{ Vector(3013.5, -6804.8, 384.0), 10}, 
		{ Vector(2696.2, -6795.6, 384.0), 9}, 
		{ Vector(2388.5, -6791.8, 384.0), 9}, 
		{ Vector(1970.3, -6840.6, 384.0), 5}, 
		{ Vector(1594.9, -6898.8, 384.0), 2}, 
		{ Vector(1150.0, -6852.4, 384.0), 6}, 
		{ Vector(759.1, -6957.8, 384.0), 6}, 
		{ Vector(289.0, -6964.5, 384.0), 5}, 
		{ Vector(-330.1, -6876.5, 384.0), 8},
		{ Vector(-623.6, -6858.6, 384.0), 6}, 
		{ Vector(-1073.9, -6927.4, 384.0), 5}, 
		{ Vector(-2947.8, -6995.1, 256.0), 1}, 
		{ Vector(-3990.3, -7001.3, 384.0), 7}, 
		{ Vector(-530.9, -5611.3, 384.0), 7}, 
		{ Vector(2463.7, -5622.4, 384.0), 8}, 
		{ Vector(3951.0, -5522.6, 384.0), 7}, 
		{ Vector(5655.3, -3890.3, 384.0), 6}, 
		{ Vector(5565.6, -1369.1, 384.0), 7}, 
		{ Vector(5690.3, 995.4, 384.0), 6}, 
		{ Vector(2228.6, 2684.7, 256.0), 6}, 
		{ Vector(2939.3, 1222.4, 256.0), 8}, 
		{ Vector(1008.6, 1594.0, 256.0), 8}, 
		{ Vector(489.5, 1282.0, 256.0), 7}, 
		{ Vector(1283.7, 19.7, 256.0), 8}, 
		{ Vector(-907.4, -1464.5, 256.0), 7}, 
		{ Vector(-2041.0, -936.2, 256.0), 7}, 
		{ Vector(-2490.0, -1083.8, 256.0), 5}, 
		{ Vector(-1236.1, -1858.3, 256.0), 7}, 
		{ Vector(-2032.8, -2420.4, 256.0), 7}, 
		{ Vector(-2303.3, -2759.6, 256.0), 6}, 
		{ Vector(-2832.8, -1435.9, 256.0), 5}, 
		{ Vector(-3888.1, -2336.0, 256.0), 3}, 
		{ Vector(-2676.4, 5523.4, 384.0), 8}, 
		{ Vector(-1180.0, 5551.6, 384.0), 8}
			}

	for _, saveInfo in ipairs(saveSpotTable) do
		local savePos = saveInfo[1]
		if savePos then
			local distance = (myPos - savePos):Length2D()
			if distance < 75 then
				return true
			end
		end
	end

	if #Wrap.TInRadius(myPos, 250, true) >= 4 then
		return true
	end

	return false

end

function FAIO.TinkerFarmDANGER(myHero)

	if not myHero then return false end
	if FAIO.TinkerAmIAtFountain(myHero) then return false end

	if next(FAIO.dodgeItTable) ~= nil then return true end
	if FAIO.TargetGotDisableModifier(myHero, myHero) == true then return true end
	if NPC.IsSilenced(myHero) then return true end

	for _, v in ipairs(Wrap.HeroesInRadius(myHero, 800, Enum.TeamType.TEAM_ENEMY)) do
		if v and Entity.IsHero(v) and not Entity.IsDormant(v) and not NPC.IsIllusion(v) then
			if NPC.FindFacingNPC(v) == myHero then
				if NPC.IsEntityInRange(myHero, v, NPC.GetAttackRange(v) + 140) then
					if NPC.IsAttacking(v) then
						return true
					end
				end
			end
		end	
	end

	return false

end

function FAIO.TinkerFarmFindDANGERnpc(myHero)

	if not myHero then return end

	local npc = nil
	for _, v in ipairs(Wrap.HeroesInRadius(myHero, 750, Enum.TeamType.TEAM_ENEMY)) do
		if v and Entity.IsHero(v) and not Entity.IsDormant(v) and not NPC.IsIllusion(v) then
			if NPC.IsAttacking(v) then
				if NPC.IsEntityInRange(myHero, v, NPC.GetAttackRange(v) + 140) then
					if NPC.FindFacingNPC(v) == myHero then
						npc = v
						break
					end
				end
			end
			for ability, info in pairs(FAIO.RawDamageAbilityEstimation) do
				if NPC.HasAbility(v, ability) and Ability.IsInAbilityPhase(NPC.GetAbility(v, ability)) then
					local abilityRange = math.max(Ability.GetCastRange(NPC.GetAbility(v, ability)), info[2])
					local abilityRadius = info[3]
					if FAIO.dodgeIsTargetMe(myHero, v, abilityRadius, abilityRange) then
						npc = v
						break
					end
				end
			end	
		end
	end

	return npc

end

function FAIO.TinkerFarmGetSaveSpot(myHero, target, blink)

	if not myHero then return end
	if not target then return end
	if not blink then return end

	local targetPos = Entity.GetAbsOrigin(target)
	local myPos = Entity.GetAbsOrigin(myHero)

	local saveSpotTable = {
		{ Vector(-7332.3, -3269.6, 384.0), 5},
		{ Vector(-7233.3, -1376.7, 384.0), 10}, 
		{ Vector(-7200.2, -1017.2, 384.0), 8}, 
		{ Vector(-7212.0, -551.6, 384.0), 8}, 
		{ Vector(-7125.0, -81.5, 384.0), 8},
		{ Vector(-7114.0, 337.9, 384.0), 5}, 
		{ Vector(-7194.7, 732.3, 384.0), 5}, 
		{ Vector(-7129.5, 1337.3, 384.0), 7},
		{ Vector(-7140.7, 1645.0, 384.0), 7},
		{ Vector(-7176.3, 2070.1, 384.0), 6}, 
		{ Vector(-7089.6, 2307.1, 512.0), 5}, 
		{ Vector(-6847.4, 3532.0, 384.0), 5}, 
		{ Vector(-7226.3, 3989.3, 384.0), 7}, 
		{ Vector(-6994.7, 4915.7, 384.0), 7}, 
		{ Vector(-6900.2, 5118.8, 384.0), 7}, 
		{ Vector(-6732.6, 5540.4, 384.0), 4}, 
		{ Vector(-6581.3, 5919.3, 384.0), 6}, 
		{ Vector(-6273.9, 6178.2, 384.0), 6}, 
		{ Vector(-6104.3, 6542.5, 384.0), 6}, 
		{ Vector(-5458.8, 6709.4, 384.0), 11}, 
		{ Vector(-5130.0, 6783.1, 384.0), 7}, 
		{ Vector(-4631.4, 6760.8, 384.0), 6}, 
		{ Vector(-4308.8, 6977.7, 384.0), 6}, 
		{ Vector(-3791.8, 6757.7, 384.0), 11}, 
		{ Vector(-3497.5, 6873.4, 384.0), 8}, 
		{ Vector(-3117.5, 6930.3, 384.0), 9}, 
		{ Vector(-2696.9, 6878.1, 384.0), 7}, 
		{ Vector(-2321.5, 6938.8, 384.0), 7}, 
		{ Vector(-1731.7, 6864.3, 384.0), 8}, 
		{ Vector(-1100.2, 6951.0, 384.0), 9}, 
		{ Vector(-767.3, 7021.9, 384.0), 11}, 
		{ Vector(-82.5, 6823.9, 384.0), 7}, 
		{ Vector(183.7, 6728.6, 384.0), 7},
		{ Vector(673.7, 6884.9, 384.0), 13}, 
		{ Vector(1009.9, 6861.5, 384.0), 10}, 
		{ Vector(1561.7, 6964.7, 384.0), 6}, 
		{ Vector(2540.2, 6960.1, 384.0), 4}, 
		{ Vector(3445.1, 6863.7, 384.0), 5}, 
		{ Vector(7400.6, 2808.3, 384.0), 6}, 
		{ Vector(7456.3, 2090.7, 256.0), 6}, 
		{ Vector(7226.0, 866.5, 384.0), 7}, 
		{ Vector(7029.8, 494.1, 384.0), 7}, 
		{ Vector(7086.8, -37.7, 384.0), 8}, 
		{ Vector(6932.5, -577.0, 384.0), 4}, 
		{ Vector(6918.2, -908.3, 384.0), 8}, 
		{ Vector(7080.6, -1472.4, 384.0), 7}, 
		{ Vector(7171.4, -1807.0, 384.0), 7}, 
		{ Vector(7297.8, -2177.6, 384.0), 9}, 
		{ Vector(7031.2, -3224.0, 384.0), 5}, 
		{ Vector(6898.3, -3549.7, 384.0), 7}, 
		{ Vector(7460.4, -4648.6, 384.0), 8}, 
		{ Vector(6924.8, -4814.6, 384.0), 6}, 
		{ Vector(6891.3, -5163.1, 384.0), 7}, 
		{ Vector(6701.0, -5480.9, 384.0), 5}, 
		{ Vector(6647.3, -5824.5, 384.0), 10},
		{ Vector(6583.7, -6132.0, 384.0), 11}, 
		{ Vector(6381.3, -6424.0, 384.0), 9}, 
		{ Vector(6059.3, -6451.0, 384.0), 9}, 
		{ Vector(6021.2, -6588.0, 384.0), 8}, 
		{ Vector(5650.1, -6737.3, 384.0), 5}, 
		{ Vector(5378.8, -6735.7, 384.0), 7}, 
		{ Vector(4971.6, -6738.0, 384.0), 7}, 
		{ Vector(4536.9, -6652.2, 384.0), 6}, 
		{ Vector(4333.0, -6725.9, 384.0), 8}, 
		{ Vector(3879.9, -6734.2, 384.0), 10}, 
		{ Vector(3364.7, -6777.9, 384.0), 9}, 
		{ Vector(3013.5, -6804.8, 384.0), 10}, 
		{ Vector(2696.2, -6795.6, 384.0), 9}, 
		{ Vector(2388.5, -6791.8, 384.0), 9}, 
		{ Vector(1970.3, -6840.6, 384.0), 5}, 
		{ Vector(1594.9, -6898.8, 384.0), 2}, 
		{ Vector(1150.0, -6852.4, 384.0), 6}, 
		{ Vector(759.1, -6957.8, 384.0), 6}, 
		{ Vector(289.0, -6964.5, 384.0), 5}, 
		{ Vector(-330.1, -6876.5, 384.0), 8},
		{ Vector(-623.6, -6858.6, 384.0), 6}, 
		{ Vector(-1073.9, -6927.4, 384.0), 5}, 
		{ Vector(-2947.8, -6995.1, 256.0), 1}, 
		{ Vector(-3990.3, -7001.3, 384.0), 7}, 
		{ Vector(-530.9, -5611.3, 384.0), 7}, 
		{ Vector(2463.7, -5622.4, 384.0), 8}, 
		{ Vector(3951.0, -5522.6, 384.0), 7}, 
		{ Vector(5655.3, -3890.3, 384.0), 6}, 
		{ Vector(5565.6, -1369.1, 384.0), 7}, 
		{ Vector(5690.3, 995.4, 384.0), 6}, 
		{ Vector(2228.6, 2684.7, 256.0), 6}, 
		{ Vector(2939.3, 1222.4, 256.0), 8}, 
		{ Vector(1008.6, 1594.0, 256.0), 8}, 
		{ Vector(489.5, 1282.0, 256.0), 7}, 
		{ Vector(1283.7, 19.7, 256.0), 8}, 
		{ Vector(-907.4, -1464.5, 256.0), 7}, 
		{ Vector(-2041.0, -936.2, 256.0), 7}, 
		{ Vector(-2490.0, -1083.8, 256.0), 5}, 
		{ Vector(-1236.1, -1858.3, 256.0), 7}, 
		{ Vector(-2032.8, -2420.4, 256.0), 7}, 
		{ Vector(-2303.3, -2759.6, 256.0), 6}, 
		{ Vector(-2832.8, -1435.9, 256.0), 5}, 
		{ Vector(-3888.1, -2336.0, 256.0), 3}, 
		{ Vector(-2676.4, 5523.4, 384.0), 8}, 
		{ Vector(-1180.0, 5551.6, 384.0), 8}
			}

	for _, saveInfo in ipairs(saveSpotTable) do
		local savePos = saveInfo[1]
		local treesAround = saveInfo[2]
		if savePos and #Wrap.TInRadius(savePos, 251, true) >= treesAround - 1 then
			local distance = (myPos - savePos):Length2D()
			if distance > 200 and distance < 1125 then
				local distanceCreep = (savePos - targetPos):Length2D()
				if distanceCreep < 1050 then
					return savePos
				end
			end
		end
	end

	local treeCount = 0
	local targetTree = nil
	for _, tree in ipairs(Wrap.TInRadius(targetPos, 900, true)) do
		if tree then
			local treePos = Entity.GetAbsOrigin(tree)
			local myDist = myPos:__sub(treePos):Length2D()
			if myDist >= 315 and myDist < 1100 then
				local treesAround = #Wrap.TInRadius(treePos, 350, true)
				if treesAround > treeCount then
					treeCount = treesAround
					targetTree = tree
				end
			end
		end
	end

	local treeTargetPos = nil
	if treeCount >= 4 then
		if targetTree ~= nil then
			local bestPos = FAIO.getBestPosition(Wrap.TInRadius(Entity.GetAbsOrigin(targetTree), 400, true), 200)
			if bestPos ~= nil and bestPos:__sub(targetPos):Length2D() < 1000 and bestPos:__sub(myPos):Length2D() < 1125 then
				treeTargetPos = bestPos
			end		
		end
	end

	if treeTargetPos ~= nil then
		if #Wrap.TInRadius(treeTargetPos, 25, true) > 0 then
			return (treeTargetPos + (treeTargetPos - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(35))
		else
			return treeTargetPos
		end
	else
		local myFountainPos = FAIO.GetMyFountainPos(myHero)
		local myDist = myPos:__sub(targetPos):Length2D()
		local gap = 1050 - myDist
		local searchPosition =  myPos + (myFountainPos - myPos):Normalized():Scaled(gap)
		local treesArcoundPos = Wrap.TInRadius(searchPosition, gap, true)
		local myPosZ = myPos:GetZ()
		for _, tree in ipairs(treesArcoundPos) do
			if tree then
				local treePos = Entity.GetAbsOrigin(tree)
				local treePosZ = treePos:GetZ()
				if (treePos - myPos):Length2D() < 1050 then
					if treePosZ > myPosZ and math.abs(treePosZ - myPosZ) > 50 then
						return myPos + (treePos - myPos):Scaled(0.9)
					end
				end
			end
		end
	end

	return

end

function FAIO.TinkerPortGetCreepCount(myHero, target, range)

	if not myHero then return 0 end
	if not target then return 0 end

	local count = 0
	for _, npc in ipairs(Wrap.UnitsInRadius(target, range, Enum.TeamType.TEAM_ENEMY)) do
		if npc and Wrap.EIsNPC(npc) and Wrap.EIsAlive(npc) and NPC.IsLaneCreep(npc) and not Entity.IsDormant(npc) and not NPC.IsWaitingToSpawn(npc) and NPC.GetUnitName(npc) ~= "npc_dota_neutral_caster" then
			if (Entity.GetHealth(npc) / Entity.GetMaxHealth(npc)) > 0.6 then
				count = count + 1
			end
		end
	end

	return count
		
end

function FAIO.TinkerPortGetHeroCount(myHero, target, range)

	if not myHero then return 0 end
	if not target then return 0 end

	local count = 0
	for _, hero in ipairs(Wrap.HeroesInRadius(target, range, Enum.TeamType.TEAM_ENEMY)) do
		if hero and Entity.IsHero(hero) and Wrap.EIsAlive(hero) and not Entity.IsDormant(hero) and not NPC.IsIllusion(hero) then
			count = count + 1
		end
	end

	return count
		
end

function FAIO.TinkerPort(myHero, blink)

	if not myHero then return end

	local enemyFountainPos = FAIO.GetEnemyFountainPos(myHero)
	local myFountainPos = FAIO.GetMyFountainPos(myHero)

	if FAIO.TinkerPushMode then
		local targetCreep
		local maxDistance = 99999
		if NPC.HasItem(myHero, "item_travel_boots", true) or NPC.HasItem(myHero, "item_travel_boots_2", true) then
			for i = 1, NPCs.Count() do 
			local npc = NPCs.Get(i)
    				if npc and Entity.IsSameTeam(myHero, npc) and Wrap.EIsAlive(npc) and NPC.IsLaneCreep(npc) and NPC.IsRanged(npc) and not Entity.IsDormant(npc) and not NPC.IsWaitingToSpawn(npc) and NPC.GetUnitName(npc) ~= "npc_dota_neutral_caster" then
					if npc ~= nil then
						local creepPosition = Entity.GetAbsOrigin(npc)
						local distanceToMouse = (creepPosition - Input.GetWorldCursorPos()):Length2D()
						if distanceToMouse < maxDistance then
							targetCreep = npc
							maxDistance = distanceToMouse
						end
					end
				end
			end
		end

		if targetCreep == nil then
			maxDistance = 99999
		end

		if targetCreep then
			return Entity.GetAbsOrigin(targetCreep)
		end
	else
		local targetCreep = nil
		local creepCount = 0
		if NPC.HasItem(myHero, "item_travel_boots", true) or NPC.HasItem(myHero, "item_travel_boots_2", true) then
			for i = 1, NPCs.Count() do 
			local npc = NPCs.Get(i)
    				if npc and Entity.IsSameTeam(myHero, npc) and NPC.IsLaneCreep(npc) and NPC.IsRanged(npc) and not Entity.IsDormant(npc) and not NPC.IsWaitingToSpawn(npc) and NPC.GetUnitName(npc) ~= "npc_dota_neutral_caster" then
					if (Entity.GetHealth(npc) / Entity.GetMaxHealth(npc)) >= 0.6 and #Wrap.UnitsInRadius(npc, 500, Enum.TeamType.TEAM_FRIEND) >= 2 then
						if (Entity.GetAbsOrigin(npc) - Entity.GetAbsOrigin(myHero)):Length2D() > 3000 then	
							if FAIO.TinkerPortGetCreepCount(myHero, npc, 900) >= FAIO.TinkerPushCreeps and FAIO.TinkerPortGetHeroCount(myHero, npc, 900) <= FAIO.TinkerPushEnemies and #Wrap.HeroesInRadius(npc, 900, Enum.TeamType.TEAM_FRIEND) <= FAIO.TinkerPushAllies then
								if FAIO.TinkerPushSave then
									if not blink then
										if FAIO.TinkerPortGetCreepCount(myHero, npc, 900) > creepCount then
											creepCount = FAIO.TinkerPortGetCreepCount(myHero, npc, 900)
											targetCreep = npc
										end
									else
										if FAIO.TinkerFarmGetSaveSpot(npc, npc, blink) ~= nil then
											if FAIO.TinkerPortGetCreepCount(myHero, npc, 900) > creepCount then
												creepCount = FAIO.TinkerPortGetCreepCount(myHero, npc, 900)
												targetCreep = npc
											end
										end
									end
								else
									if FAIO.TinkerPortGetCreepCount(myHero, npc, 900) > creepCount then
										creepCount = FAIO.TinkerPortGetCreepCount(myHero, npc, 900)
										targetCreep = npc
									end
								end
							end
						end
					end
				end
			end
		end

		if targetCreep == nil then
			creepCount = 0
		end

		if targetCreep ~= nil then
			return Entity.GetAbsOrigin(targetCreep)
		end
	end

	return
end

function FAIO.drawTinkerPanel(myHero)

	if not myHero then return end
	if not Menu.IsEnabled(FAIO.optionHeroTinker) then return end
	
	if Menu.IsKeyDownOnce(FAIO.optionHeroTinkerPanelKey) then
		FAIO.Toggler = not FAIO.Toggler
	end
	
	if FAIO.Toggler then return end

	local w, h = Renderer.GetScreenSize()
	Renderer.SetDrawColor(255, 255, 255)
	if FAIO.TinkerPanelX ~= Config.ReadInt("tinker", "panelX", w/2) then
		FAIO.TinkerPanelX = Config.ReadInt("tinker", "panelX", w/2)
	end
	if FAIO.TinkerPanelY ~= Config.ReadInt("tinker", "panelY", h/2) then
		FAIO.TinkerPanelY = Config.ReadInt("tinker", "panelY", h/2)
	end

	if Menu.IsEnabled(FAIO.optionHeroTinkerPanelMove) then
		if Input.IsKeyDownOnce(Enum.ButtonCode.KEY_UP) then
			FAIO.TinkerPanelY = FAIO.TinkerPanelY - 10
			Config.WriteInt("tinker", "panelY", FAIO.TinkerPanelY)
		end
		if Input.IsKeyDownOnce(Enum.ButtonCode.KEY_DOWN) then
			FAIO.TinkerPanelY = FAIO.TinkerPanelY + 10
			Config.WriteInt("tinker", "panelY", FAIO.TinkerPanelY)
		end
		if Input.IsKeyDownOnce(Enum.ButtonCode.KEY_LEFT) then
			FAIO.TinkerPanelX = FAIO.TinkerPanelX - 10
			Config.WriteInt("tinker", "panelX", FAIO.TinkerPanelX)
		end
		if Input.IsKeyDownOnce(Enum.ButtonCode.KEY_RIGHT) then
			FAIO.TinkerPanelX = FAIO.TinkerPanelX + 10
			Config.WriteInt("tinker", "panelX", FAIO.TinkerPanelX)
		end
	end

	local startX = FAIO.TinkerPanelX
	local startY = FAIO.TinkerPanelY

	local width = 140
	local height = 320

	 -- black background
	Renderer.SetDrawColor(0, 0, 0, 125)
	Renderer.DrawFilledRect(startX, startY, width, height)


	-- black border
	Renderer.SetDrawColor(0, 0, 0, 255)
	Renderer.DrawOutlineRect(startX, startY, width, height)

	Renderer.SetDrawColor(255, 0, 0, 255)
	Wrap.DrawTextCentered(FAIO.arcWardenfont, startX + width/2, startY + 10, "PUSH OPTIONS", 1)
	Renderer.SetDrawColor(0, 0, 0, 45)
	Renderer.DrawFilledRect(startX+1, startY+1, width-2, 20-2)

	Renderer.SetDrawColor(0, 191, 255, 255)
	Wrap.DrawTextCentered(FAIO.arcWardenfont, startX + width/2, startY + 30, "Push target", 1)
	Renderer.SetDrawColor(255, 255, 255, 45)
	Renderer.DrawFilledRect(startX+1, startY+21, width-2, 20-2)
	Renderer.SetDrawColor(0, 0, 0, 255)
	Renderer.DrawOutlineRect(startX, startY+40, width/2, 20)
	Renderer.DrawOutlineRect(startX + width/2, startY+40, width/2, 20)

	local hoveringOverAuto = Input.IsCursorInRect(startX, startY+40, width/2, 20)
	local hoveringOverCursor = Input.IsCursorInRect(startX + width/2, startY+40, width/2, 20)

	if hoveringOverAuto and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) then
		if FAIO.TinkerPushMode then
			FAIO.TinkerPushMode = not FAIO.TinkerPushMode
		end
	end

	if hoveringOverCursor and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) then
		if not FAIO.TinkerPushMode then
			FAIO.TinkerPushMode = not FAIO.TinkerPushMode
		end
	end
	
	if not FAIO.TinkerPushMode then
		Renderer.SetDrawColor(0, 255, 0, 255)
		Wrap.DrawTextCenteredX(FAIO.arcWardenfont, startX + width/4, startY + 40, "auto", 0)
		Renderer.SetDrawColor(255, 255, 255, 75)
		Wrap.DrawTextCenteredX(FAIO.arcWardenfont, startX + width/4*3, startY + 40, "cursor", 0)
	else
		Renderer.SetDrawColor(255, 255, 255, 75)
		Wrap.DrawTextCenteredX(FAIO.arcWardenfont, startX + width/4, startY + 40, "auto", 0)
		Renderer.SetDrawColor(0, 255, 0, 255)
		Wrap.DrawTextCenteredX(FAIO.arcWardenfont, startX + width/4*3, startY + 40, "cursor", 0)
	end

	Renderer.SetDrawColor(0, 191, 255, 255)
	Wrap.DrawTextCentered(FAIO.arcWardenfont, startX + width/2, startY + 70, "Auto line options", 1)
	Renderer.SetDrawColor(255, 255, 255, 45)
	Renderer.DrawFilledRect(startX+1, startY+61, width-2, 20-2)
	Renderer.SetDrawColor(0, 0, 0, 255)

	Renderer.DrawOutlineRect(startX + width/4*3, startY+80, width/4, 20)
	Renderer.SetDrawColor(0, 0, 0, 255)	
	Renderer.DrawText(FAIO.arcWardenfont, startX + 5, startY + 81, "Min. creeps", 1)

	local hoveringOverCreeps = Input.IsCursorInRect(startX + width/4*3, startY+80, width/4, 20)
	if hoveringOverCreeps and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) and not FAIO.TinkerPushMode then
		if FAIO.TinkerPushCreeps < 5 then
			FAIO.TinkerPushCreeps = FAIO.TinkerPushCreeps + 1
		end
	end

	if hoveringOverCreeps and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_RIGHT) and not FAIO.TinkerPushMode then
		if FAIO.TinkerPushCreeps > 1 then
			FAIO.TinkerPushCreeps = FAIO.TinkerPushCreeps - 1
		end
	end

	if FAIO.TinkerPushCreeps > 0 then
		if not FAIO.TinkerPushMode then
			Renderer.SetDrawColor(0, 255, 0, 255)	
		else
			Renderer.SetDrawColor(255, 255, 255, 75)
		end
		Wrap.DrawTextCenteredX(FAIO.arcWardenfont, startX + width/4*3 + 18, startY + 81, FAIO.TinkerPushCreeps, 0)
	else
		Renderer.SetDrawColor(255, 255, 255, 75)
		Wrap.DrawTextCenteredX(FAIO.arcWardenfont, startX + width/4*3 + 18, startY + 81, FAIO.TinkerPushCreeps, 0)
	end	

	
	Renderer.SetDrawColor(0, 0, 0, 255)
	Renderer.DrawOutlineRect(startX + width/4*3, startY+100, width/4, 20)
	Renderer.SetDrawColor(0, 0, 0, 255)
	Renderer.DrawText(FAIO.arcWardenfont, startX + 5, startY + 101, "Max. enemies", 1)

	local hoveringOverEnemies = Input.IsCursorInRect(startX + width/4*3, startY+100, width/4, 20)
	if hoveringOverEnemies and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) and not FAIO.TinkerPushMode then
		if FAIO.TinkerPushEnemies < 5 then
			FAIO.TinkerPushEnemies = FAIO.TinkerPushEnemies + 1
		end
	end

	if hoveringOverEnemies and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_RIGHT) and not FAIO.TinkerPushMode then
		if FAIO.TinkerPushEnemies > 0 then
			FAIO.TinkerPushEnemies = FAIO.TinkerPushEnemies - 1
		end
	end

	if FAIO.TinkerPushEnemies > 0 then
		if not FAIO.TinkerPushMode then
			Renderer.SetDrawColor(255, 64, 64, 255)
		else
			Renderer.SetDrawColor(255, 255, 255, 75)
		end
		Wrap.DrawTextCenteredX(FAIO.arcWardenfont, startX + width/4*3 + 18, startY + 101, FAIO.TinkerPushEnemies, 0)
	else
		Renderer.SetDrawColor(255, 255, 255, 75)
		Wrap.DrawTextCenteredX(FAIO.arcWardenfont, startX + width/4*3 + 18, startY + 101, FAIO.TinkerPushEnemies, 0)
	end

	Renderer.SetDrawColor(0, 0, 0, 255)
	Renderer.DrawOutlineRect(startX + width/4*3, startY+120, width/4, 20)
	Renderer.SetDrawColor(0, 0, 0, 255)
	Renderer.DrawText(FAIO.arcWardenfont, startX + 5, startY + 121, "Max. allies", 1)

	local hoveringOverAllies = Input.IsCursorInRect(startX + width/4*3, startY+120, width/4, 20)
	if hoveringOverAllies and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) and not FAIO.TinkerPushMode then
		if FAIO.TinkerPushAllies < 5 then
			FAIO.TinkerPushAllies = FAIO.TinkerPushAllies + 1
		end
	end

	if hoveringOverAllies and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_RIGHT) and not FAIO.TinkerPushMode then
		if FAIO.TinkerPushAllies > 0 then
			FAIO.TinkerPushAllies = FAIO.TinkerPushAllies - 1
		end
	end

	if FAIO.TinkerPushAllies > 0 then
		if not FAIO.TinkerPushMode then
			Renderer.SetDrawColor(0, 255, 255, 255)
		else
			Renderer.SetDrawColor(255, 255, 255, 75)
		end
		Wrap.DrawTextCenteredX(FAIO.arcWardenfont, startX + width/4*3 + 18, startY + 121, FAIO.TinkerPushAllies, 0)
	else
		Renderer.SetDrawColor(255, 255, 255, 75)
		Wrap.DrawTextCenteredX(FAIO.arcWardenfont, startX + width/4*3 + 18, startY + 121, FAIO.TinkerPushAllies, 0)
	end

	Renderer.SetDrawColor(0, 0, 0, 255)
	Renderer.DrawOutlineRect(startX + width/4*3, startY+140, width/4, 20)
	Renderer.SetDrawColor(0, 0, 0, 255)
	Renderer.DrawText(FAIO.arcWardenfont, startX + 5, startY + 141, "Only save TP", 1)

	local hoveringOverSave = Input.IsCursorInRect(startX + width/4*3, startY+140, width/4, 20)
	if hoveringOverSave and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) and not FAIO.TinkerPushMode then
		FAIO.TinkerPushSave = not FAIO.TinkerPushSave
	end

	if FAIO.TinkerPushSave then
		if not FAIO.TinkerPushMode then
			Renderer.SetDrawColor(0, 255, 0, 255)
		else
			Renderer.SetDrawColor(255, 255, 255, 75)
		end
		Wrap.DrawTextCenteredX(FAIO.arcWardenfont, startX + width/4*3 + 18, startY + 141, "on", 0)
	else
		Renderer.SetDrawColor(255, 255, 255, 75)
		Wrap.DrawTextCenteredX(FAIO.arcWardenfont, startX + width/4*3 + 18, startY + 141, "off", 0)
	end


	Renderer.SetDrawColor(0, 0, 0, 255)
	Renderer.DrawOutlineRect(startX + width/4*3, startY+160, width/4, 20)
	Renderer.SetDrawColor(0, 0, 0, 255)
	Renderer.DrawText(FAIO.arcWardenfont, startX + 5, startY + 161, "Auto defend", 1)

	local hoveringOverDefend = Input.IsCursorInRect(startX + width/4*3, startY+160, width/4, 20)
	if hoveringOverDefend and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) then
		FAIO.TinkerPushDefend = not FAIO.TinkerPushDefend
	end

	if FAIO.TinkerPushDefend then
		Renderer.SetDrawColor(0, 255, 0, 255)	
		Wrap.DrawTextCenteredX(FAIO.arcWardenfont, startX + width/4*3 + 18, startY + 161, "on", 0)
	else
		Renderer.SetDrawColor(255, 255, 255, 75)
		Wrap.DrawTextCenteredX(FAIO.arcWardenfont, startX + width/4*3 + 18, startY + 161, "off", 0)
	end

	Renderer.SetDrawColor(0, 0, 0, 255)
	Renderer.DrawOutlineRect(startX + width/4*3, startY+180, width/4, 20)
	Renderer.SetDrawColor(0, 0, 0, 255)
	Renderer.DrawText(FAIO.arcWardenfont, startX + 5, startY + 181, "Allow jungle", 1)

	local hoveringOverJungle = Input.IsCursorInRect(startX + width/4*3, startY+180, width/4, 20)
	if hoveringOverJungle and Input.IsKeyDownOnce(Enum.ButtonCode.MOUSE_LEFT) and not FAIO.TinkerPushMode then
		FAIO.TinkerPushJungle = not FAIO.TinkerPushJungle
	end

	if FAIO.TinkerPushJungle then
		if not FAIO.TinkerPushMode then
			Renderer.SetDrawColor(0, 255, 0, 255)
		else
			Renderer.SetDrawColor(255, 255, 255, 75)
		end
		Wrap.DrawTextCenteredX(FAIO.arcWardenfont, startX + width/4*3 + 18, startY + 181, "on", 0)
	else
		Renderer.SetDrawColor(255, 255, 255, 75)
		Wrap.DrawTextCenteredX(FAIO.arcWardenfont, startX + width/4*3 + 18, startY + 181, "off", 0)
	end

	local startXinfo = startX
	local startYinfo = startY + 210

	Renderer.SetDrawColor(255, 0, 0, 255)
	Wrap.DrawTextCentered(FAIO.arcWardenfont, startXinfo + width/2, startYinfo + 10, "INFORMATION", 1)
	Renderer.SetDrawColor(0, 0, 0, 45)
	Renderer.DrawFilledRect(startXinfo+1, startYinfo+1, width-2, 20-2)

	Renderer.SetDrawColor(0, 191, 255, 255)
	Wrap.DrawTextCentered(FAIO.arcWardenfont, startXinfo + width/2, startYinfo + 30, "Tinker action", 1)
	Renderer.SetDrawColor(255, 255, 255, 45)
	Renderer.DrawFilledRect(startX+1, startYinfo+21, width-2, 20-2)


		if FAIO.TinkerStatus == 0 then
			Renderer.SetDrawColor(255, 100, 0, 255)
			Wrap.DrawTextCenteredX(FAIO.arcWardenfont, startX + width/2, startYinfo + 40, "manual", 0)

		elseif FAIO.TinkerStatus == 1 and FAIO.LockedTarget ~= nil then
			Renderer.SetDrawColor(0, 255, 0, 255)
			Wrap.DrawTextCenteredX(FAIO.arcWardenfont, startXinfo + width/2, startYinfo + 40, "comboing", 0)
			local heroName = NPC.GetUnitName(FAIO.LockedTarget)
			local heroNameShort = string.gsub(heroName, "npc_dota_hero_", "")
			local imageHandle
				if FAIO.heroIconHandler[heroNameShort] ~= nil then
					imageHandle = FAIO.heroIconHandler[heroNameShort]
				else
					imageHandle = Renderer.LoadImage(FAIO.heroIconPath .. heroNameShort .. ".png")
					FAIO.heroIconHandler[heroNameShort] = imageHandle
				end
			Renderer.SetDrawColor(255, 255, 255, 255)
			Renderer.DrawImage(imageHandle, startX + width/2 - 35, startYinfo + 58, 67, 48)

		elseif FAIO.TinkerStatus == 2 then
			Renderer.SetDrawColor(0, 255, 0, 255)
			Wrap.DrawTextCenteredX(FAIO.arcWardenfont, startXinfo + width/2, startYinfo + 40, "TP pushing", 0)

		elseif FAIO.TinkerStatus == 3 then
			Renderer.SetDrawColor(0, 255, 0, 255)
			Wrap.DrawTextCenteredX(FAIO.arcWardenfont, startXinfo + width/2, startYinfo + 40, "Rocket spam", 0)
		end


end
	
function FAIO.KunkkaShipCombo(myHero, enemy)

	if not Menu.IsEnabled(FAIO.optionHeroKunkkaShip) then return end

  	local Q = NPC.GetAbilityByIndex(myHero, 0)
 	local X = NPC.GetAbility(myHero, "kunkka_x_marks_the_spot")
	local Xreturn = NPC.GetAbility(myHero, "kunkka_return")
	local Ship = NPC.GetAbility(myHero, "kunkka_ghostship")

	local blink = NPC.GetItem(myHero, "item_blink", true)

	local myMana = NPC.GetMana(myHero)

	FAIO.itemUsage(myHero, enemy)

	if os.clock() < FAIO.lastTick then return end

	if FAIO.kunkkaGhostshipTimer < os.clock() then
		if enemy and Wrap.EIsAlive(enemy) and not NPC.HasState(enemy, Enum.ModifierState.MODIFIER_STATE_MAGIC_IMMUNE) and not NPC.IsLinkensProtected(enemy) and FAIO.heroCanCastSpells(myHero, enemy) == true then
			if not NPC.HasModifier(enemy, "modifier_kunkka_x_marks_the_spot") then
				if Menu.IsKeyDownOnce(FAIO.optionHeroKunkkaShipKey) then
					if Ship and Ability.IsCastable(Ship, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(Ship)) then
						if X and Ability.IsCastable(X, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(X)) then
							Ability.CastTarget(X, enemy)
							FAIO.kunkkaXMarkPosition = Entity.GetAbsOrigin(enemy)
							FAIO.kunkkaXMarkCastTime = os.clock() + 1
							FAIO.lastTick = os.clock() + 0.1
							return
						end
					end
				end
			else
				if Ship and Ability.IsCastable(Ship, myMana) and NPC.IsEntityInRange(myHero, enemy, Ability.GetCastRange(Ship)) then
					Ability.CastPosition(Ship, FAIO.kunkkaXMarkPosition)
					FAIO.kunkkaGhostshipTimer = os.clock() + 3.08
					FAIO.lastTick = os.clock() + 0.1
					return
				end
			end
		end
	else
		if FAIO.kunkkaGhostshipTimer - os.clock() <= 2.05 then
			if Q and Ability.IsCastable(Q, myMana) then
				Ability.CastPosition(Q, FAIO.kunkkaXMarkPosition)
				FAIO.lastTick = os.clock() + 0.1
				return
			end
		end

		if FAIO.kunkkaGhostshipTimer - os.clock() <= 0.55 then
			if Xreturn and Ability.IsCastable(Xreturn, myMana) then
				Ability.CastNoTarget(Xreturn)
				FAIO.lastTick = os.clock() + 0.1
				return
			end
		end
	end

	return

end

return FAIO
			